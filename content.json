{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【题解】牛客小白月赛109-C","slug":"牛客小白月赛109-C","date":"2025-01-17T14:16:39.000Z","updated":"2025-01-17T16:40:16.647Z","comments":true,"path":"2025/01/17/牛客小白月赛109-C/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B109-C/","excerpt":"","text":"题目描述 Tobo 养了 nnn 只猪猪，猪猪们的编号为 。我们规定两种操作： 1. 对于给定的 l,r 表示 Tobo 要和编号为 l 到 r的猪猪按顺序玩耍，但因为 Tobo 喜新厌旧，所以已经玩耍过的猪猪不会再一起玩，会直接跳过它。 2. 对于给定的 x ，表示编号为 x 的猪猪想知道自己是第几个和 Tobo 玩耍的，如果没有玩耍过则输出 0 。 你一共需要处理 q 次操作。 输入描述: 第一行输入两个整数 代表 Tobo 养的猪猪数量、操作次数。 此后 q 行，每行先输入一个整数 表示操作类型，随后： 若 op=1，在同一行上输入两个整数 代表 Tobo 将依次和编号为 l 到 r的猪猪玩耍。 若 op=2，在同一行上输入一个整数 代表一次询问。 输出描述: 对于每一次询问，在单独的一行上输出一个整数，表示询问的猪猪是第几个和 Tobo 玩耍的；若没有玩耍过，则直接输出 0。 输入 123456785 7 1 2 3 2 3 1 3 5 2 4 2 1 1 1 5 2 1 输出 12342 3 0 5 说明 123对于第一次操作，Tobo 将依次和编号为 2,3 的猪猪玩耍； 对于第二次操作，编号为 3 的猪猪想知道自己是第几个和 Tobo 玩的，输出 2 ； 对于第三次操作，Tobo 将依次和编号为 3,4,5的猪猪玩耍，这其中，由于编号为 3 的猪猪已经和 Tobo 玩过，所以 Tobo 会跳过它，直接和编号为 4 的猪猪玩耍。 错解 每次操作1遍历区间，暴力枚举每一只猪，若没有玩过则赋值为当前玩过的第n只猪，若玩过则直接跳过 该方法会TLE（后面又加强数据了优化后的暴力也差一点点ww） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; int play[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; int tep = 0; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (tep&gt;=n) continue; // 全部玩过后直接跳过 if (play[l]==0) { // 遍历区间的左端赋值 tep++; play[l]+=tep; } for(int i = l; i&lt;r;i++){ // 遍历l到r并赋值为第tep只玩过的猪 if (play[i+1]==0) { tep++; play[i+1]=tep; } } } else { // 询问操作 int p; cin &gt;&gt;p; cout &lt;&lt; play[p]&lt;&lt;endl; } } return 0; } 正解 前置知识 lower_bound()函数： 定义：const_iterator lower_bound( const K&amp; x ) const; STL内置函数，用于寻找第一个大于等于key的值，返回值为指向刚好大于等于key的下一个元素，若不存在则返回末尾迭代器（指向最后一个元素） 我们可以使用set来优化 由于每只猪的编号都连续且不相同，我们可以用set来存储 使用lower_bound()函数查找在待查找区间里下一个没有玩过的猪 然后将该猪标记为第n个玩的，从集合中删除 这样可以保证集合里始终都是没有被玩过的猪，每次查找都找到离l最近的一个没有被玩过的猪，直到区间删空，即所有猪都被玩过 询问操作直接输出标记 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; set&lt;int&gt; pig; int tag[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; pig.insert(1e9); // 防止最后全删完后剩下索引0处无法跳出 for (int i = 1;i&lt;=n;i++) pig.insert(i); // 把所有猪存入集合 int cnt = 1; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l,r; cin &gt;&gt; l &gt;&gt; r; while(1){ int tep = (*pig.lower_bound(l)); // 用lower_bound()返回第一个大于l的数，即找到下一个在区间内且没有玩过的猪 if (tep&gt;r) break; // 区间为空，寻找结束 tag[tep]=cnt; // 标记找到的猪是第几个被玩的 cnt++; pig.erase(tep); // 把被玩过的猪从集合中删除 } } else { // 询问猪是第几个玩的 int p; cin &gt;&gt; p; cout &lt;&lt; tag[p]&lt;&lt;endl; } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【C/C++】指针","slug":"指针","date":"2025-01-17T06:53:15.466Z","updated":"2025-01-17T07:16:56.235Z","comments":true,"path":"2025/01/17/指针/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E6%8C%87%E9%92%88/","excerpt":"","text":"指针 数据在内存中的存储 这是一段内存，他被分成了许多段，每段一个byte 当我们声明一个变量int a，计算机会给该变量分配一块空间，分配取决于数据类型与编译器 如：int 与float占4bytes，char占1bytes 当我们给变量a赋值a=5，计算机会去寻找该变量，去到他的地址，以二进制写入数据 指针的基础使用 指针是一种变量，它可以存储变量的地址 使用数据类型* 变量名创建一个指针：int *p char *c 使用取地址符&amp;获取一个变量的地址，并可以将指针指向该变量地址：p=&amp;a print p，print &amp;a，print &amp;p分别对应打印p指向(a)的地址，a的地址，p的地址 将一个*放在指针变量前，可以对指针进行解引用，即获取p指向地址的值 则print *p会返回a的值，*p = 8会更改a的值到8 实例代码： 1234567891011121314151617181920#include&lt;stdio.h&gt; int main(){ int a=5; int* p; // 若该指针p没有被初始化，p会变成一个野指针，会因为指向任意位置而报错 p = &amp;a; // 储存a的地址 // 上两行等同于int* p = &amp;a; printf(\"A:%d\\n\",p); // a的地址 printf(\"V:%d\\n\",*p); // a的值 printf(\"A:%d\\n\",&amp;a); // a的地址 *p = 12; // 更改p指向地址(a)的元素值 printf(\"A:%d\\n\",a); // 更改后的a值 int b = 20; *p = b; // p不会指向b，只会将b的值赋给a printf(\"A:%d\\n\",p); // 还是a的地址 printf(\"V:%d\\n\",*p); // b的值 return 0; } 指针类型 不同的数据类型占据不同的内存： int：4bytes char：1byte float：4bytes void指针： 可以存放任意类型的指针，且无需强制类型转换 需要进行显式转换后才能赋值给其他类型 可以与其他类型指针直接比较地址值 只有强制类型转换后才能操作（解引用、算术运算等） 可以和普通指针一样传入NULL或nullptr表示空指针 作为函数输入输出时，表示可以接受任意类型和输出任意类型的指针 指针类型间的转换 定义一个变量int a=1025： 他在内存中的布局为（从右到左分别为第0 1 2 3个字节，他们的地址也是连续的）： 其中，最左边的一位为符号位，0为整数1为负数 若我们定义一个字符指针c指向a，由于字符只占一个字节，故c只会指向a的第一个字节： 对c进行算术运算(+1)会让他指向下一个字节 以至于得到4 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; int main(){ // 一个整形指针 int a = 1025; // 在二进制中为四字节:00000000 00000000 00000100 00000001 int* p; p = &amp;a; printf(\"size of integer is %d\\n\", sizeof(int)); printf(\"Address = %d, value = %d\\n\",p,*p); // 一个字符指针 char *c; c = (char*)p; // 进行强制类型转换 printf(\"size of integer is %d\\n\", sizeof(char)); // 由于char指针只有一个字节,则机器只看从右边开始的一个字节 即00000001 printf(\"Address = %d, value = %d\\n\",c,*c); // 增加一个字节,则指针指向从右边开始的第一个字节 即00000100 printf(\"Address = %d, value = %d\\n\",c+1,*(c+1)); // 一个void指针 void *p0; p0 = p; // 不需要显式的类型转换 // 当p0没指向任何特定类型时,不能解引用 printf(\"Address = %d, value = %d\\n\",p0,*p0); // 也不要进行算术运算 printf(\"Address = %d %d\\n\",p0,p0+1); } 指针算术运算 对一个指针进行加1操作，相当于将该指针增加一个该指针数据类型所占字节数的字节数 例如对int *p=&amp;a; p++;得到p的值为a的地址加4 123456789101112#include &lt;stdio.h&gt; int main(){ int a = 10; int *p; p = &amp;a; // 指针加法 : +1代表增加一个数据类型的字节数 printf(\"Address p is %d\\n\",p); // p的地址 printf(\"Value at address p is %d\\n\",*p); // p指向的值 printf(\"size of integer is %d bytes\\n\", sizeof(int)); // int类型所占的字节数 printf(\"Address p+1 is %d\\n\",p+1); // p+1指向的地址 printf(\"Value at address p+1 is %d\\n\",*(p+1)); // p+1指向的值(垃圾值) } 指向指针的指针 假设定义了一个数据int x = 5; 我们定义一个指针指向x int *p = &amp;x 此时我们可以再定义一个指针指向指针p int **q = &amp;p 甚至还可以定义一个指针指向指针q int ***r = &amp;q (r是205) 示例代码 123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int x =5; int* p = &amp;x; *p = 6; int** q = &amp;p; int*** r = &amp;q; printf(\"%d\\n\",*p); // p指向x的值 printf(\"%d\\n\",*q); // q指向p的值(x的地址) printf(\"%d\\n\",*(*q)); // q指向p的值指向x的值 printf(\"%d\\n\",*(*r)); // r指向q的值,q指向p的值 printf(\"%d\\n\",*(*(*r))); // r指向q的值,q指向p的值,p指向x的值 // 更改x的值 ***r = 10; print(\"x = %d\\n\", x); // **q与*p都指向x的值,则相当于x自加2 **q = *p +2; print(\"x = %d\\n\", x); } 指针用例—函数传引用 or 传值？ e.g. 局部变量与全局变量： 有以下代码 12345678910#include &lt;stdio.h&gt; void f(int x){ x=x+1; } int main(){ int x=10; f(x); printf(\"%d\\n\",x); return 0; } 该代码中的函数想让变量+1，但输出的结果显然还是10，这是为什么呢？ 看以下代码： 1234567891011#include &lt;stdio.h&gt; void f(int x){ printf(\"Address of x in f is:%d\\n\",&amp;x); x=x+1; } int main(){ int x=10; f(x); printf(\"Address of x in main is:%d\\n\",&amp;x); return 0; } 你会惊奇的发现，f函数中的x与main函数中的x的地址不一样，这也就说明了为什么+1不成立 当程序运行时，计算机会预留一部分内存给程序，他们被分为四个部分：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等）。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧 让一个函数调用另一个函数时，两个函数分别称为主调函数与被调函数，在主调函数中调用其他函数用到的参数称为实际参数，被调函数中的函数称为形式参数，实参会被映射到形参。这个操作即传值 当main函数调用f函数时，一块它的栈帧会被创建，其中的参数会被分配到对应空间，执行+1操作后，这个函数的栈帧中的变量执行了+1，但不影响其他地方的变量。 当f函数执行完毕，程序回到main函数，此时f的栈帧会被清除，main函数会被继续执行，故局部变量的生命周期只是函数执行期间。 接下来进行的函数是printf函数，这是一个库函数，在栈中创建它的栈帧并指型。这一个结构被称为(函数)调用栈，即：是将一个个函数的栈帧，按照调用的顺序依次压入栈中，等最上层的函数执行完了，就弹出相应的栈帧的过程 注意：栈是有大小的，如果因为无限递归等原因导致栈帧一直被创建而不清除，程序会因为栈溢出而终止 那传引用能否实现？ 1234567891011#include &lt;stdio.h&gt; void f(int *p){ *p = (*p)+1; } int main(){ int a; a = 10; f(&amp;a); printf(\"a = %d\", a); return 0; } 该函数传的是地址 当调用main函数，它的栈帧被创建，a=10进入栈。 调用f函数，它的栈帧被创建，则p接收到a的地址，入栈，此时p指向a。 在函数中解引用p，并执行操作，p指向的内存(a)的值就会增加，即a的值增加1 回到main函数，a的值就是11 这就是传引用，它可以节省很多内存空间，也可以处理一些复杂数据类型以节省内存 指针与数组 让我们声明一个数组 int a[5] 即我们创建了五个整型变量，在内存中连续存在(int 占四个字节)，则整个数组占的大小为20bytes，作为一个连续的块 我们定义一个指针int* p，将p指向a的第一个元素，则p解引用后打印的是a[0]的值 回忆之前说的指针算术，若我们将p+1，则p会往前移动四个字节，**此时*(p+1)即a[0]后四个字节的值，即a[1]** 与之前不同，一个值它的地址+1后会移动到一个未知内容的地址，而数组a中+1后p指向的值是已知的 若直接将数组名赋值给p，则p默认接收到的是数组a首元素的地址，称为数组的基地址 若想获得数组某个值的地址，可以使用&amp;a[i]或者a+i 若想获得数组某个值，可以使用a[i]或者*(a+i) 注意：对数组名（常量 ）自加是非法的，可以定义一个指针指向数组名让该指针自加 实例代码： 1234567891011#include &lt;stdio.h&gt; int main(){ int a[]={2,4,5,8,1}; for (int i = 0;i&lt;5;i++){ printf(\"Address = %d\\n\",&amp;a[i]); printf(\"Address = %d\\n\",a+i); printf(\"Value = %d\\n\",a[i]); printf(\"Value = %d\\n\", *(a+i)); } } 指针用例—数组传参 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int suma(int a[],int size){ int sum = 0; for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int sumb(int a[]){ int sum = 0; int size = sizeof(a)/sizeof(a[0]); printf(\"In sumb - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int main(){ int a[]={1,2,3,4,5}; // 计算数组大小 printf(\"In main - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); int size = sizeof(a)/sizeof(a[0]); // 传入数组大小后进行加和 int tot = suma(a,size); // 在函数中计算数组大小并加和 int tot2 = sumb(a); printf(\"tot = %d\\n\", tot); printf(\"tot2 = %d\\n\", tot2); } 以上代码会出现一些问题： 在调用main与sumb函数时，它们的栈帧会被创建 调用sumb函数时，编译器只会创建一个同名的指针在sumb的栈帧中，即它只指向main函数中数组a的首元素地址（即int a[]等同于int *a） 因此函数中的sizeof a是一个8字节的指针。 指针与字符数组 字符数组 C中的字符串存储在数组中，必须以’\\0’结束 字符数组赋值： 可以指定每一位进行赋值， 或者使用字符串字面值（用双引号括起来的字符串）赋值，该方法会隐式地添加一个’\\0’ 或者使用大括号初始化每一位，以逗号间隔并在结尾加上’\\0’ 注意：只能在声明同时用字符串字面值赋值 使用指针 字符数组中数组名代表的是数组首元素的地址，可以用一个指针变量指向它，该变量也可以对字符数组进行操作 12345678910#include &lt;stdio.h&gt; int main(){ char c1[6]=\"Hello\"; char *c2; c2 = c1; c2[0]='A'; // equal to c1[0]='A'; c2++; // 指向下一个元素 c1++; // 非法 } 有等价关系： c2[i]等同于*(c2+i) c1[i]等同于*(c1+i) 函数传参 12345678910111213141516171819#include&lt;stdio.h&gt; void print(char *c){ int i = 0; // while (c[i]!='\\0'){ // *(c+i)也可以 // printf(\"%c\",c[i]); // i++; // } // 由于c是指针，故可以通过自增与解引用来进行访问 while(*c!='\\0'){ printf(\"%c\",*c); c++; } printf(\"\\n\"); } int main(){ char c[20] = \"Hello\"; print(c); return 0; } 指针与二维数组 如果我们要创建一个二维数组b[2][3] 此时，b[0]与b[1]表示三个整数的一维数组，在内存中占用3*4=12个字节，是按行存储的 故int *p=b;指代的是返回一个指向一维数组的指针，此时不能指针运算或解引用，故不能这么用 故应使用int (*p)[3]来创建一个二维指针数组，其中3表示三个指向一维数组的指针 这时print b or &amp;b[0]都指代第一个元素的地址 ​ print *b or b[0] or &amp;b[0][0]都指代第一个元素地址的值 ​ print b+1 or &amp;b[1]会跳到下一个数组的首地址（+12） 使用print *(b+ 1)or b[i]or&amp;b[1][0]指代下一个指向一维数组的并返回 值 解引用时，需要一步步解 例 *(*b+1) *b 为b[0]，一个一维数组的首元素地址，*b+1会让指针移动四个字节带到下一个整型变量， 相当于&amp;b[0][1] 我们解引用后，*(*b+1)就相当于b[0][1] 指针运算：b[i][j]=*(b[i]+j)=*(*(b+i)+j) 指针与多维数组 原理 与二维数组类似 假如我们有一个int数组c[3][2][2]，在内存中的存储如下 简化为三个二维数组线性存储，每个二维数组内两个一维数组线性存储 故我们可以声明一个指针int (*p)[2][2] = c;，指向2*2的二维数组 这时print c，print *c，print c[0]，print &amp;c[0][0]均输出第一个一维数组的地址 同理，使用指针运算有关系：c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) 可以理解为解引用一次就脱一层[] e.g. print *(c[0][1]+1)指向的是c[0][1][1] print *(c[1]+1)指向的是c[1][1]，即c[1][1][0] 用于函数传参 如一维数组传参，我们可以通过传值或传引用两种方法传参 注意：传值时除了最高维度，其他维度必须要指定偏移量（即形参定义时必须和传入数组长度一样） 123456int two_dim(int a[][3]){ } int three_dim(int a[][2][2]){ } 而根据数组名就是指向第一个元素的指针，我们可以直接传引用来实现降维度 注意：只能降到次一级维度，且其余的必须指定偏移量 123456int two_dim(int (*a)[3]){ } int three_dim(int (*a)[2][2]){ } 指针与动态内存 内存的分配 在一个典型架构中，分配给应用程序的内存分为四个区段：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等），函数调用信息。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 栈 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧，大小在编译期间决定 所有函数从下往上开辟栈帧后，在执行时总是栈顶的函数在执行，其余函数暂停，等待上方函数返回值等。当上方函数返回后，它占用栈的内存也会被清除，下一个函数运行。任何时候正在执行的函数都是栈顶的那个函数 预留给栈的空间在运行期间并不会增长，也不能请求更多内存。如果运行时的栈增长超过了程序预留的栈内存大小，那么会造成栈溢出(stack overflow) 因此栈有两个限制： 在栈上的变量无法操作骑作用域 当声明一个很大的数据类型，可能会造成溢出；且只能在编译时分配他的大小，无法在程序运行时分配它的大小 堆(动态内存) 这时我们需要用到堆来分配或销毁或内存。我们可以任意使用堆上的内存，只要不超过系统内存限制。 堆又称为动态内存，使用堆内存称为动态内存分配 (注意这里的堆并不是数据结构) C风格： 12345678910111213#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; // 分配到栈上 int *p; // 指向堆内存的指针 p = (int*)malloc(sizeof(int)); // 在堆上开辟一块四字节的内存，让指针p指向其地址 *p=10; // 解引用将值存入堆 free(p); // 释放内存 p = (int*)malloc(20*sizeof(int)); // 在堆上再开辟一块20个四字节的内存作为数组，让指针p指向其首元素地址 // 可以用以下两种方式访问 p[0] = 1; *(p+1) = 2; } 定义一个指针变量p，它被存储在栈中，指向堆中分配的内存地址 通过malloc在堆上分配一块四字节的内存，malloc会返回一个指向这块内存起始地址的指针，void类型。故我们需要进行一个强制类型转换，并赋给指针变量p 使用堆上内存的唯一方式是通过引用，自己维护一个指针指向这块内存。我们通过对指针变量p解引用并赋值来使用。 若我们再以同样方式分配一块四字节内存，让p指向它，并赋值为20，p此时指向的便是堆中的另一块内存。而之前那块内存仍在堆上，并不会被自动回收，此时称为内存泄漏，因此我们需要在用完一块内存后，及时调用free()释放内存。 如果要分配一个数组内存，我们只需要传入数组大小字节数即可，返回的是内存的初始地址 若malloc无法在堆上成功分配内存，会返回NULL C++风格： 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; int *p; // 指向堆内存的指针 p = new int; // 在堆上开辟一块int大小的内存(四字节) *p = 10; // 解引用并赋值 delete p; // 释放内存 p = new int[20]; // 在堆上开辟一个20大小的int数组 delete[] p; // 释放数组内存 } c++中使用关键字new与delete开辟与释放内存，不需要类型转换 相关函数 malloc 定义：void* malloc(size_t size)(size_t相当于无符号整数) 用法：int *p = (int*)malloc(分配空间大小) 分配空间大小一般习惯通过sizeof计算，如想要开辟一个存储三个int变量的数组，我们可以用3*sizeof(int)来计算大小，一般不直接写。 由于malloc返回的是void指针，指向其初始地址，而void指针无法解引用，因此我们一般在前面进行强制类型转换来转化成int指针以方便操作 malloc不会将分配的空间初始化，建议使用memset(p,0x00,sizeof(p))初始化 calloc 定义：void* calloc(size_t num, size_t size) 用法：int *p = (int*)calloc(分配元素个数, 每个元素空间大小) calloc可以指定分配的元素个数 calloc在分配空间后会自动将其初始化为0 realloc 定义：void* realloc(void* ptr, size_t size) 用法：realloc(已指向某处内存的指针, 修改空间大小) realloc用于修改分配的内存大小 若需要的新内存块比原来大，程序会创建一块新内存并将内容复制过去 若之前的内存的相邻部分还有可用内存，程序会直接拓展原空间 若需要的新内存块比原来小，则多余部分的内存会被释放掉 注意以下用法： 12int *a = (int*)realloc(a,0); // 相当于free(a) int *b = (int*)realloc(NULL,n*sizeof(int)); // 相当于malloc 内存泄漏 当我们动态申请了内存后，忘记去释放，此时程序占用了一些未使用的内存，称为内存泄露 对于栈：由于栈帧在使用完后会被自动销毁，故不会发生内存泄漏 对于堆：在开辟空间后，堆上的内存必须要被显式地释放掉，否则会一直存在 任何未使用和未引用的堆上内存都是垃圾，程序员要确保不要浪费内存 函数返回指针 我们可以在函数类型处加上*来声明函数返回值是一个指针。 注意以下情况： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int c = (*a)+(*b); return &amp;c; } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 该程序对print的输出正常，而输出sum时出现了异常，从底层原理分析： 执行main函数，开辟栈帧，执行add函数，在main函数上再开辟栈帧，main函数会等待add返回 此时add中a与b存储了main函数中x与y的地址，c存储了*a与*b的和，返回的是c的地址，故main函数中的p指针存储的是c的地址 add执行完毕，占用空间被清除。但注意，此时p指向的内存仍未变化，即此时它指向了被释放掉的内存空间，值是随机的 现在执行print函数，开辟栈帧，原空间被覆盖，因此p存储的地址对应的值已经不是c的值了，因此输出异常。 还有一种情况：若不执行print函数，输出的值可能会正确。因为此时程序还没重写或清除那个空间上的数据（虽然已经释放空间） 而对于main与add函数，由于被调函数的栈空间总是在主调函数之上，因此被调函数执行时主调函数仍在栈内存中，因此add可以访问main函数中的变量。但若我们想要返回被调函数的一个局部变量给主调函数，当被调函数结束后，内存已被释放，因此会出问题。 因此可以从栈底向上传局部变量或局部变量的地址，但不能从栈顶向下传局部变量或局部变量的地址 因此我们可以修改： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int *c = (int*)malloc(sizeof(int)); // 在堆上开辟内存 *c = (*a)+(*b); return c; // 返回的是堆上的指针 } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 我们将c开辟在堆上，此时就不会被清除了，返回c是安全的 函数指针 我们可以用指针指向函数地址，即指向函数的指针。我们可以用这种指针解引用和调用函数。 函数的地址 在内存中，一个函数就是一块连续的内存。 一般程序执行指令会按照地址依次执行，而函数调用可以让程序跳到某一个地址开始执行其中的指令。 此时对应的函数地址可以称为函数的入口点，即函数第一条指令的地址 函数指针的使用 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(char *name){ printf(\"hello\"); } int add(int a, int b){ return a+b; } int main(){ int c; int (*p)(int,int); // 函数指针 p = &amp;add; // 指针指向add函数的地址(不用&amp;也可) c = (*p)(2,3); // 解引用，并传入参数执行函数(不用解引用也行) printf(\"%d\\n\",c); void (*ptr)(char*); ptr = print; // 不用&amp;的情况 ptr(\"mixbp\"); // 不用解引用的情况 } 注意：为了指向一个函数，函数指针的类型必须是正确的 由于单纯的函数名代表函数入口点，故不用&amp;与解引用也可以 回调函数 将函数指针作为函数参数传入，并在函数内部通过该函数指针调用函数，被调用的函数即为回调函数 123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(){ printf(\"hello\"); } void b(void (*ptr)()){ ptr(); // 用ptr回调传进来的函数 } int main(){ void (*p)() = print; // 定义一个指针指向print b(p); // 传入该函数指针 b(print); // 这样也可以传 } 代码中，函数b可以通过函数指针来回调函数print 可以定义一个指向print函数的指针传入，也可以直接传入print，此时指代的是print函数的首地址 应用：排序 设计一个排序函数，并可以按照不同逻辑进行排序 我们可以在普通排序函数中添加一个函数指针参数(比较函数)，通过设计蚂蚁比较逻辑并传入排序函数，可以灵活实现不同情景的比较，而不用每次都根据不同逻辑重新写一遍排序函数 如实现正序、逆序、按绝对值排序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;math.h&gt; int compare(int a,int b){ if (a&gt;b) return 1; else return -1; } int r_compare(int a, int b){ if (a&gt;b) return -1; else return 1; } int abs_compare(int a, int b){ if (abs(a)&gt;abs(b)) return 1; else return -1; } void sort(int *a, int n, int (*cmp)(int,int)){ int tep; for (int i = 0;i&lt;n;i++){ for (int j = 0;j&lt;n-1;j++){ if (cmp(a[j],a[j+1])&gt;0){ tep = a[j]; a[j] = a[j+1]; a[j+1]=tep; } } } } int main(){ int a[]={3,2,1,5,6,4}; int b[]={-2,-3,5,4,1,-6}; sort(a,6,compare); // 正序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(a,6,r_compare); // 逆序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(b,6,abs_compare); // 绝对值排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",b[i]); printf(\"\\n\"); } 同样的逻辑，在c的stdlib.h库中有一个qsort函数，只要给予它排序逻辑并传入就可以对任意数组排序","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"【算法】快速幂","slug":"快速幂","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-17T07:01:52.295Z","comments":true,"path":"2024/12/20/快速幂/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 问题引入 如何计算 朴素算法：让n个a相乘，时间复杂度为，当n特别大的时候，耗时特别长 而快速幂算法可以大大减少时间复杂度 n的分类 n为2的幂次时 如 我们可以用上一次的结果当作下一次的乘数： 快速幂原理 这样只需要进行六次乘法就可以得出结果，时间复杂度为 即使用了倍增原理，将每次a的数量翻倍 n不为2的幂次时 我们可以将不是2的幂的数写成若干个2的幂的数的和，如 可以改写为，再根据以上方法计算 如何将n分解为2的幂次之和？ 答案是位运算 让我们看看这几个数的二进制表示形式 二进制表示分解n的原理 会发现，目标数n的二进制中的1的个数与位置正好对应它分解后的数字 伪代码 12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r 逻辑 行3，7：每次除二，让二进制位从右到左减少一位，相当于右移一位 行6：每次让翻倍（,,,,…） 行2，4，5，8：如果mod2==1，代表该位是1，则将该位代表的与结果相乘，即让幂次相加 位运算改进 n mod 2==1等同于n&amp;1，n/2等同于n&gt;&gt;1 时间复杂度 ，循环次数为n的二进制位数，对于整数n，它的二进制位数为 板子 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } 应用1：幂取模 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } 注： 应用2：斐波那契数列 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } 用矩阵形式表示斐波那契数列，如下图 斐波那契矩阵表示 我们可以发现它可以分为n个矩阵相乘 再乘列向量F1 F0","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数学】逆元","slug":"逆元","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/逆元/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"逆元 前置知识 单位元 在一个集合中，对于某种运算，如果对于任何的集合元素 a，和元素 e 运算，得到还是集合元素 a 本身，则称 e 为这个运算下的单位元。 在加法运算中，对于任意实数，有，则单位元 (可以认作相反数) 在乘法运算中，对于任意实数，有，则单位元 (可以认作倒数) 模乘的单位元是 (证明自己搜) 逆元 在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 模意义下的乘法逆元 若 且(a与p互质)，则称a关于模p的乘法逆元为x 逆元即数论中的广义倒数。 费马小定理 若p为质数，则，则 或对于任意整数a，有 欧拉函数 ，表示小于等于n的正整数中和n互质的数的个数，如 当n是质数时，有 欧拉函数是积性函数，即对任意满足的整数a,b，有 特别地，当n是奇数时 求一个数的欧拉函数值：在质因数分解的同时求解即可 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } 欧拉定理 若，则 则对于费马小定理，有更一般的结论： 应用 求除法的模运算时，经常会因为精度或溢出问题而导致结果产生误差。 故我们可以将求转化为的逆元 将除法转为乘法，精度问题便就解决了 扩展欧几里得定理求逆元 给定正整数a，b，求满足的x的最小正整数解，若无解返回-1 结论 当a与b不互质时，逆元必定不存在 当a与b互质时，有 对应系数可得： 若改为求满足 的最小正整数解，经过变形 原式可以由变为，则和上方一致 模板 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } 费马小定理 给定素数p和正整数a，求满足的最小正整数x，若不存在返回-1 此时模数固定为素数，故直接可以用费马小定理求解 当a为p的倍数时，，所以一定不存在，返回-1 根据费马小定理有，又 则，逆元x满足 代码 12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } 线性求逆元 对于求一连串数字模p的逆元，上两种方法容易超时，用这种方法更快一些 结论 (证明见oi-wiki) 有递推式 代码 123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } 线性求任意逆元 首先我们求出n个数的前缀积，这时我们可以用exgcd或费马小定理求出的乘法逆元 又因为，，故我们可以将，就会和其逆元抵消，以求出 求出所有前缀积的逆元后，我们可以让前缀积的逆元乘i-1的前缀积来消除其他逆元，以得到的逆元，即 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // 也可以用exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【数据结构】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-17T07:01:25.837Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set) 概念 不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1 如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率 查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素， 123find1(x){ return set[x]; } 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素， 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } 实现2 每个集合用一颗有根树表示 定义一个数组set 若set[i]=i, 则i为该树的根节点，i代表本集合 若set[i]=j, 若ji, 则j是i的父节点 效率 查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏，一般 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } 并：只需要将根节点改为另一个集合的根节点即可， 123merge2(a,b){ set[a]=b; } 改进 如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } 此时查找操作的时间复杂度变成了 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 路径压缩示意 代码 1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; } 模板 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 ,表示共有 个元素和 个操作。 接下来 行，每行包含三个整数 。 当 时，将 与 所在的集合合并。 当 时，输出 与 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1234N Y N Y 提示 对于 的数据，，。 对于 的数据，，。 对于 的数据，，，，。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // 并查集 // 查找操作，使用路径压缩 int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // 初始化每一位的根节点是他自己 for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // 进行合并 if (z==1){ merge(x,y); } else { // 如果两者的根节点相同，则属于同一集合 if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://izayoisakuye.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-17T07:00:58.279Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 这是一个测试帖子 三级标题 四级标题 五级标题 测试代码 123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ ### じや……一生 ACMしてくれる?","categories":[{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"},{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","permalink":"https://izayoisakuye.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]}