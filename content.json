{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【算法】快速幂","slug":"快速幂","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-13T04:35:14.356Z","comments":true,"path":"2024/12/20/快速幂/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 问题引入 如何计算 朴素算法：让n个a相乘，时间复杂度为，当n特别大的时候，耗时特别长 而快速幂算法可以大大减少时间复杂度 n的分类 n为2的幂次时 如 我们可以用上一次的结果当作下一次的乘数： 快速幂原理 这样只需要进行六次乘法就可以得出结果，时间复杂度为 即使用了倍增原理，将每次a的数量翻倍 n不为2的幂次时 我们可以将不是2的幂的数写成若干个2的幂的数的和，如 可以改写为，再根据以上方法计算 如何将n分解为2的幂次之和？ 答案是位运算 让我们看看这几个数的二进制表示形式 二进制表示分解n的原理 会发现，目标数n的二进制中的1的个数与位置正好对应它分解后的数字 伪代码 12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r 逻辑 行3，7：每次除二，让二进制位从右到左减少一位，相当于右移一位 行6：每次让翻倍（,,,,…） 行2，4，5，8：如果mod2==1，代表该位是1，则将该位代表的与结果相乘，即让幂次相加 位运算改进 n mod 2==1等同于n&amp;1，n/2等同于n&gt;&gt;1 时间复杂度 ，循环次数为n的二进制位数，对于整数n，它的二进制位数为 板子 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } 应用1：幂取模 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } 注： 应用2：斐波那契数列 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } 用矩阵形式表示斐波那契数列，如下图 斐波那契矩阵表示 我们可以发现它可以分为n个矩阵相乘 再乘列向量F1 F0","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数学】逆元","slug":"逆元","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/逆元/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"逆元 前置知识 单位元 在一个集合中，对于某种运算，如果对于任何的集合元素 a，和元素 e 运算，得到还是集合元素 a 本身，则称 e 为这个运算下的单位元。 在加法运算中，对于任意实数，有，则单位元 (可以认作相反数) 在乘法运算中，对于任意实数，有，则单位元 (可以认作倒数) 模乘的单位元是 (证明自己搜) 逆元 在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 模意义下的乘法逆元 若 且(a与p互质)，则称a关于模p的乘法逆元为x 逆元即数论中的广义倒数。 费马小定理 若p为质数，则，则 或对于任意整数a，有 欧拉函数 ，表示小于等于n的正整数中和n互质的数的个数，如 当n是质数时，有 欧拉函数是积性函数，即对任意满足的整数a,b，有 特别地，当n是奇数时 求一个数的欧拉函数值：在质因数分解的同时求解即可 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } 欧拉定理 若，则 则对于费马小定理，有更一般的结论： 应用 求除法的模运算时，经常会因为精度或溢出问题而导致结果产生误差。 故我们可以将求转化为的逆元 将除法转为乘法，精度问题便就解决了 扩展欧几里得定理求逆元 给定正整数a，b，求满足的x的最小正整数解，若无解返回-1 结论 当a与b不互质时，逆元必定不存在 当a与b互质时，有 对应系数可得： 若改为求满足 的最小正整数解，经过变形 原式可以由变为，则和上方一致 模板 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } 费马小定理 给定素数p和正整数a，求满足的最小正整数x，若不存在返回-1 此时模数固定为素数，故直接可以用费马小定理求解 当a为p的倍数时，，所以一定不存在，返回-1 根据费马小定理有，又 则，逆元x满足 代码 12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } 线性求逆元 对于求一连串数字模p的逆元，上两种方法容易超时，用这种方法更快一些 结论 (证明见oi-wiki) 有递推式 代码 123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } 线性求任意逆元 首先我们求出n个数的前缀积，这时我们可以用exgcd或费马小定理求出的乘法逆元 又因为，，故我们可以将，就会和其逆元抵消，以求出 求出所有前缀积的逆元后，我们可以让前缀积的逆元乘i-1的前缀积来消除其他逆元，以得到的逆元，即 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // 也可以用exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【数据结构】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-13T04:35:32.484Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set) 概念 不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1 如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率 查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素， 123find1(x){ return set[x]; } 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素， 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } 实现2 每个集合用一颗有根树表示 定义一个数组set 若set[i]=i, 则i为该树的根节点，i代表本集合 若set[i]=j, 若ji, 则j是i的父节点 效率 查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏，一般 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } 并：只需要将根节点改为另一个集合的根节点即可， 123merge2(a,b){ set[a]=b; } 改进 如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } 此时查找操作的时间复杂度变成了 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 djsj 代码 1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; } 模板 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 ,表示共有 个元素和 个操作。 接下来 行，每行包含三个整数 。 当 时，将 与 所在的集合合并。 当 时，输出 与 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1234N Y N Y 提示 对于 的数据，，。 对于 的数据，，。 对于 的数据，，，，。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // 并查集 // 查找操作，使用路径压缩 int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // 初始化每一位的根节点是他自己 for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // 进行合并 if (z==1){ merge(x,y); } else { // 如果两者的根节点相同，则属于同一集合 if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://izayoisakuye.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-13T04:25:29.950Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 这是一个测试帖子 三级标题 四级标题 五级标题 测试代码 123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ ### じや……一生 ACMしてくれる?","categories":[{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","permalink":"https://izayoisakuye.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]}