{"meta":{"title":"çº¢é­”å’–å•¡é¦†","subtitle":"éšæ‰‹è®°å½•å­¦ä¹ ç‚¹æ»´","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"ã€æ•°æ®ç»“æ„ã€‘æ ˆ","slug":"æ ˆ","date":"2025-03-21T14:21:59.923Z","updated":"2025-03-21T14:22:16.434Z","comments":true,"path":"2025/03/21/æ ˆ/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E6%A0%88/","excerpt":"","text":"æ ˆ ç‰¹ç‚¹ ä»…å¯åœ¨è¡¨å°¾æ“ä½œ è¡¨å°¾ç§°ä¸ºæ ˆé¡¶(top)ï¼Œè¡¨å¤´ç§°ä¸ºæ ˆåº• ä¸å«å…ƒç´ çš„ç©ºè¡¨ä¸ºç©ºæ ˆ æ ˆéµå¾ªåè¿›å…ˆå‡ºï¼ˆLIFOï¼‰çš„åŸåˆ™ åŸºæœ¬æ“ä½œåŒ…æ‹¬pushï¼Œpop é¡ºåºè¡¨å®ç° åˆå§‹åŒ– 123456789typedef struct{ ElemType data[MAXSIZE]; int top; }Stack; // æ ˆçš„åˆå§‹åŒ– void initStack(Stack *s){ s-&gt;top = -1; // è¡¨ç¤ºç©ºæ ˆ } åˆ¤æ–­ç©ºæ ˆ 123456789int isEmpty(Stack *s){ if (s-&gt;top==-1){ printf(\"Empty\"); return 1; } else { return 0; } } å‹æ ˆ 12345678910// å‹æ ˆ int push(Stack *s, ElemType e){ if (s-&gt;top&gt;=MAXSIZE-1){ printf(\"Full\"); return 0; } s-&gt;top++; // æ ˆé¡¶ä¸Šç§»ä¸€ä½ s-&gt;data[s-&gt;top]= e; // å‹å…¥æ•°æ® return 1; } å‡ºæ ˆ 12345678910// å‡ºæ ˆ int pop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; // å¼¹å‡ºæ ˆé¡¶å…ƒç´  s-&gt;top--; // æ ˆé¡¶ä¸‹ç§»ä¸€ä½ return 1; } è·å–æ ˆé¡¶å…ƒç´  123456789// è·å–æ ˆé¡¶å…ƒç´  int getTop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; return 1; } åŠ¨æ€åˆ†é…å†…å­˜ 123456789101112typedef struct{ ElemType *data; int top; }Stack; // æ ˆçš„åˆå§‹åŒ– Stack* initStack(){; Stack *s = (Stack*)malloc(sizeof(Stack)); s-&gt;data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); s-&gt;top = -1; // è¡¨ç¤ºç©ºæ ˆ return s; } é“¾è¡¨å®ç° ä½¿ç”¨å•å‘é“¾è¡¨æ¥å®ç°æ ˆ å°¾èŠ‚ç‚¹ä¸ºæ ˆåº•ï¼Œé¦–èŠ‚ç‚¹ä¸ºæ ˆé¡¶ å‹æ ˆï¼šé“¾è¡¨å¤´æ’æ³• å‡ºæ ˆï¼šåˆ é™¤å¤´èŠ‚ç‚¹åçš„é¦–èŠ‚ç‚¹ åˆ¤ç©ºï¼šåªæœ‰å¤´èŠ‚ç‚¹ï¼ˆhead-&gt;next == NULLï¼‰ è·å–æ ˆé¡¶æ•°æ®ï¼šæ‰¾å¤´èŠ‚ç‚¹çš„nextçš„dataï¼ˆhead-&gt;next-&gt;dataï¼‰ åˆå§‹åŒ– 12345typedef int ElemType; typedef struct stack{ ElemType data; struct stack *next; }Stack; åˆ¤ç©º 12345678910// åˆ¤ç©º int isEmpty(Stack *s){ if (s-&gt;next == NULL){ // å¤´èŠ‚ç‚¹çš„nextæŒ‡å‘NULL printf(\"Empty\"); return 1; } else { return 0; } } å‹æ ˆ 123456789// å‹æ ˆ int push(Stack *s, ElemType e){ Stack* p = (Stack*)malloc(sizeof(Stack)); p-&gt;data = e; p-&gt;next = s-&gt;next; s-&gt;next = p; return 1; } å‡ºæ ˆ 123456789101112// å‡ºæ ˆ int pop(Stack *s, ElemType *e){ if (s-&gt;next==NULL){ printf(\"Empty\"); return 0; } Stack *q = s-&gt;next; *e = q-&gt;data; s-&gt;next = q-&gt;next; free(q); return 1; } è·å–æ ˆé¡¶å…ƒç´  123456789// è·å–æ ˆé¡¶å…ƒç´  int getTop(Stack *s,ElemType *e){ if (s-&gt;next == NULL){ printf(\"Empty\"); return 0; } *e = s-&gt;next-&gt;data; return 1; }","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"è¡¨","slug":"è¡¨","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘è¡¨","slug":"è¡¨","date":"2025-03-21T14:21:27.493Z","updated":"2025-03-21T14:21:50.714Z","comments":true,"path":"2025/03/21/è¡¨/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E8%A1%A8/","excerpt":"","text":"è¡¨ çº¿æ€§è¡¨ nä¸ªæ•°æ®ç±»å‹ç›¸åŒçš„å…ƒç´ æ„æˆçš„æœ‰é™åºåˆ— ç©ºè¡¨ï¼šå¤§å°ä¸º0çš„è¡¨ é¦–èŠ‚ç‚¹ï¼šå­˜åœ¨å”¯ä¸€ä¸€ä¸ªè¢«ç§°ä¸ºç¬¬ä¸€ä¸ªçš„å…ƒç´  å°¾èŠ‚ç‚¹ï¼šå­˜åœ¨å”¯ä¸€ä¸€ä¸ªè¢«ç§°ä¸ºæœ€åä¸€ä¸ªçš„å…ƒç´  å‰é©±ï¼šå‰é©± åç»§ï¼šåç»§ å¯¹äºé™¤äº†é¦–å°¾èŠ‚ç‚¹çš„å…ƒç´ ï¼Œå®ƒåªä¼šæœ‰ä¸€ä¸ªå‰é©±ã€ä¸€ä¸ªåç»§ é¡ºåºè¡¨å®ç° é¡ºåºè¡¨ï¼šä¸€ç»„è¿ç»­å†…å­˜å•å…ƒå­˜å‚¨çº¿æ€§è¡¨çš„å„ä¸ªå…ƒç´  å¯¹äºé™æ€è¡¨ï¼Œmainå‡½æ•°è°ƒç”¨æ—¶ï¼Œåº”ä¼ å…¥åˆ—è¡¨çš„åœ°å€(&amp;) å»ºè¡¨ 123456789#define MAXSIZE 100 typedef int ElemType; // æ–¹ä¾¿å­˜å‚¨ä¸åŒç±»å‹æ•°æ®çš„æƒ…å†µä¸‹ä¿®æ”¹æ•°æ®ç±»å‹ // å»ºè¡¨ typedef struct SeqList { ElemType data[MAXSIZE]; int length; // é¡ºåºè¡¨æ•°æ®ä¸ªæ•° }; åˆå§‹åŒ– 1234// åˆå§‹åŒ– void initList(SeqList *L){ L-&gt;length = 0; } å°¾æ’å…ƒç´  12345678910// å°¾æ’å…ƒç´  int appendElem(SeqList *L, ElemType e){ if (L-&gt;length&gt;=MAXSIZE){ // åˆ¤æ»¡ printf(\"å·²æ»¡\\n\"); return 0; } L-&gt;data[L-&gt;length] = e; // åœ¨æœ«å°¾æ·»åŠ å…ƒç´  L-&gt;length++; // å°†é¡ºåºè¡¨é•¿åº¦åŠ ä¸€ return 1; } æ’å…¥å…ƒç´  123456789101112131415161718// æ’å…¥å…ƒç´  int insertElem(SeqList *L, ElemType e, int pos){ if (L-&gt;length&gt;=MAXSIZE){ // åˆ¤æ»¡ printf(\"å·²æ»¡\\n\"); return 0; } if (pos&lt;1 || pos&gt; L-&gt;length){ printf(\"ä½ç½®é”™è¯¯\\n\"); return 0; } for (int i = L-&gt;length-1; i&gt;=pos-1;i--){ // å€’åºè®©æ’å…¥å…ƒç´ åé¢çš„å…ƒç´ åç§»ä¸€ä½ L-&gt;data[i+1] = L-&gt;data[i]; // å‘åç§»åŠ¨å…ƒç´  } L-&gt;data[pos-1] = e; // æ’å…¥å…ƒç´  L-&gt;length++; // å°†é¡ºåºè¡¨é•¿åº¦åŠ ä¸€ return 1; } æœ€åæ—¶é—´å¤æ‚åº¦ éœ€è¦å°†æ’å…¥ä½ç½®åçš„å…ƒç´ éƒ½åç§»ä¸€ä½ éå†åˆ—è¡¨ 1234567// éå†å…ƒç´  void listElem(SeqList *L){ for (int i = 0; i &lt; L-&gt;length; i++){ printf(\"%d \", L-&gt;data[i]); } printf(\"\\n\"); } åˆ é™¤å…ƒç´  1234567891011// åˆ é™¤å…ƒç´ å¹¶è¿”å›åˆ é™¤çš„å…ƒç´  int delElem(SeqList *L, int pos, ElemType *e){ *e = L-&gt;data[pos-1]; // å–å‡ºåˆ é™¤å…ƒç´  if (pos &lt; L-&gt;length){ for (int i = pos; i&lt;L-&gt;length; i++){ L-&gt;data[i-1] = L-&gt;data[i]; // ä»poså¼€å§‹å‘åï¼Œå°†åé¢ä¸€ä½è¦†ç›–åˆ°å‰ä¸€ä½å®ç°åˆ é™¤ } } L-&gt;length--; // è¡¨é•¿åº¦å‡ä¸€ï¼Œè¿™æ ·æœ€åä¸€ä¸ªå…ƒç´ ä¸ç”¨è¦†ç›–ä¹Ÿå¯ä»¥ return 1; } è¯¥åˆ é™¤å¯ä»¥è¿”å›åˆ é™¤æ‰çš„å…ƒç´ ï¼Œç”¨eå˜é‡å­˜å‚¨ æŸ¥æ‰¾å…ƒç´  123456789// æŸ¥æ‰¾å…ƒç´  int findElem(SeqList *L, ElemType e){ for (int i = 0; i&lt;L-&gt;length; i++){ if (e==L-&gt;data[i]){ // æ‰¾åˆ°å…ƒç´  return i+1; // è¿”å›ä½ç½® } } return -1; // æ‰¾ä¸åˆ°è¿”å›-1 } ä½¿ç”¨åŠ¨æ€é¡ºåºè¡¨å®ç° é€šè¿‡mallocå‡½æ•°åœ¨å †ä¸­åŠ¨æ€åˆ†é…å†…å­˜å»ºè¡¨ ä¸åŒçš„åœ°æ–¹åªæ˜¯åœ¨å»ºè¡¨ä¸åˆå§‹åŒ–ä¸Š 12345678910111213// å»ºè¡¨ typedef struct { ElemType *data; int length; }SeqList; // åˆå§‹åŒ– åˆ†é…å†…å­˜ SeqList* initList(){ SeqList *L = (SeqList*)malloc(sizeof(SeqList)); L -&gt; data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); L -&gt; length = 0; return L; } æ­¤æ—¶åœ¨mainå‡½æ•°å»ºè¡¨æ—¶åªéœ€è¦è°ƒç”¨initListå‡½æ•°åˆå§‹åŒ–å¹¶å°†è¿”å›çš„ç»“æ„ä½“æŒ‡é’ˆå­˜å…¥ä¸€ä¸ªå¯¹åº”å˜é‡å³å¯ ç”±äºæ­¤æ—¶è·å¾—çš„ç›´æ¥æ˜¯åœ°å€ï¼Œæ•…å¯¹åº”æ“ä½œæ—¶ä¾¿ä¸éœ€è¦å–åœ°å€äº† é“¾è¡¨å®ç° é“¾è¡¨å­˜å‚¨çš„ç‰¹ç‚¹æ˜¯ç”¨ä¸€ç»„ä»»æ„çš„å­˜å‚¨å•å…ƒå­˜å‚¨æ•°æ®ï¼ˆå¯è¿ç»­å¯ä¸è¿ç»­ï¼‰ å¯¹æ¯ä¸€ä¸ªå­˜å‚¨å•å…ƒï¼Œé™¤äº†è¦å­˜å‚¨å½“å‰æ•°æ®ï¼Œè¿˜éœ€è¦å­˜å‚¨ä¸€ä¸ªæŒ‡ç¤ºå…¶ç›´æ¥åç»§çš„ä¿¡æ¯ï¼ˆåœ°å€ï¼‰ï¼Œè¿™ä¸¤éƒ¨åˆ†ä¿¡æ¯ç»„æˆäº†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œnä¸ªèŠ‚ç‚¹é“¾æ¥æˆäº†ä¸€ä¸ªé“¾è¡¨ï¼Œå³ä¸ºçº¿æ€§è¡¨ èŠ‚ç‚¹åŒ…æ‹¬ä¸¤ä¸ªåŸŸï¼š æ•°æ®åŸŸï¼šå­˜å‚¨æ•°æ®å…ƒç´ ä¿¡æ¯ æŒ‡é’ˆåŸŸï¼šå­˜å‚¨ç›´æ¥åç»§å­˜å‚¨ä½ç½® å•é“¾è¡¨ nextä¸­å­˜å‚¨äº†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ï¼Œå…¶ä¸­å°¾èŠ‚ç‚¹ä¸­çš„nextæŒ‡å‘NULLï¼Œè¡¨ç¤ºåˆ°è¾¾é“¾è¡¨å°¾éƒ¨ åˆå§‹åŒ– 123456789101112// å•é“¾è¡¨åˆå§‹åŒ–-å»ºç«‹å¤´èŠ‚ç‚¹ Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // åˆ†é…ä¸€ä¸ªèŠ‚ç‚¹å¤§å°çš„ç©ºé—´ head-&gt;data = 0; // æ•°æ®è®¾ä¸º0 head-&gt;next = NULL; // ä¸‹ä¸€ä¸ªåœ°å€è®¾ä¸ºNULL return head; } int main(){ Node* test = initList(); return 0; } å»ºç«‹ä¸€ä¸ªå¤´èŠ‚ç‚¹ï¼Œä½œä¸ºçº¿æ€§è¡¨çš„å¼€å§‹ï¼Œå…¶æ•°æ®ä¸º0ï¼Œåœ°å€é»˜è®¤ä¸ºNULL åˆ›å»ºé“¾è¡¨æ—¶ï¼Œåªéœ€è¦è°ƒç”¨initListå‡½æ•°å¹¶å°†è¿”å›çš„ç»“æ„ä½“æŒ‡é’ˆèµ‹ç»™å¯¹åº”å˜é‡å³å¯ å¤´æ’å…ƒç´  å¤´æ’å…ƒç´ å®ç°äº†åœ¨å¤´èŠ‚ç‚¹åæ’å…¥æ•°æ® å…ˆè®©æ–°èŠ‚ç‚¹çš„nextæŒ‡å‘åŸå¤´èŠ‚ç‚¹æŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ å†è®©å¤´èŠ‚ç‚¹æŒ‡å‘çš„èŠ‚ç‚¹æ›´æ”¹ä¸ºæ–°çš„èŠ‚ç‚¹ é¡ºåºå¾ˆé‡è¦ 123456int insertHead(Node* L, ElemType e){ Node *p = (Node*)malloc(sizeof(Node)); // åˆ†é…å­˜å‚¨æ•°æ®çš„èŠ‚ç‚¹çš„ç©ºé—´ p-&gt;data = e; // å°†æ’å…¥å…ƒç´ èµ‹å€¼ç»™è¯¥èŠ‚ç‚¹ p-&gt;next = L-&gt;next; // å°†è¯¥èŠ‚ç‚¹çš„nextæŒ‡å‘åŸå¤´èŠ‚ç‚¹æŒ‡å‘çš„èŠ‚ç‚¹ L-&gt;next = p; // å°†åŸå¤´èŠ‚ç‚¹çš„nextæŒ‡å‘è¯¥æ–°èŠ‚ç‚¹ } å°¾æ’å…ƒç´  å¤´æ’å…ƒç´ å®ç°äº†åœ¨å°¾èŠ‚ç‚¹åæ’å…¥æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¯»æ‰¾å°¾èŠ‚ç‚¹ æ‰¾åˆ°æŸèŠ‚ç‚¹çš„next==NULLæ—¶ä¾¿æ‰¾åˆ°äº†å°¾èŠ‚ç‚¹ 12345678// è·å¾—å°¾èŠ‚ç‚¹åœ°å€ Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // å½“èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ p = p-&gt;next; // é¡ºç€å¯»æ‰¾ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ } return p; } å…ˆè®©å…ˆå‰çš„å°¾èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹ å†è®©æ–°èŠ‚ç‚¹æŒ‡å‘NULL 12345678// å°¾æ’æ³•æ’å…¥å…ƒç´  Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; tail-&gt;next = p; p-&gt;next = NULL; return p; } æ³¨æ„ï¼Œå°¾æ’æ³•æ¯æ¬¡è¿”å›å°¾èŠ‚ç‚¹ï¼Œè¿™æ ·ä¸‹æ¬¡æ’å…¥æ—¶å°±å¯ä»¥æ¥ç€ä¸Šä¸€æ¬¡çš„æ’å…¥äº†ï¼Œä¸éœ€è¦å†get æŒ‡å®šä½ç½®æ’å…¥å…ƒç´  é¦–å…ˆè¦æ‰¾åˆ°å¾…æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªå…ƒç´ ï¼Œç„¶åè®©æ–°èŠ‚ç‚¹æŒ‡å‘è¯¥å…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´  ç„¶åè®©å‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹çš„ä½ç½® 1234567891011121314151617// æŒ‡å®šä½ç½®æ’å…¥å…ƒç´  int insertNode(Node* L, int pos, ElemType e){ Node* p = L; // è®©æŒ‡é’ˆæŒ‡å‘éœ€è¦æ’å…¥ä½ç½®çš„å‰é©±èŠ‚ç‚¹ for(int i = 0; i&lt;pos-1;i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); // è¦æ’å…¥çš„æ–°èŠ‚ç‚¹ q-&gt;data = e; // è¾“å…¥æ•°æ® q-&gt;next = p-&gt;next; // æ–°èŠ‚ç‚¹ä¸‹ä¸€ä¸ªä½ç½®èµ‹å€¼ä¸ºå‰é©±èŠ‚ç‚¹æŒ‡å‘çš„åä¸€ä¸ªèŠ‚ç‚¹ p-&gt;next = q; // å‰é©±èŠ‚ç‚¹æŒ‡å‘æ’å…¥çš„æ–°èŠ‚ç‚¹ return 1; } åˆ é™¤èŠ‚ç‚¹ æ‰¾åˆ°åˆ é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹p ç”¨æŒ‡é’ˆqæŒ‡å‘è¦åˆ é™¤çš„èŠ‚ç‚¹ é€šè¿‡æ”¹å˜pçš„åç»§èŠ‚ç‚¹å®ç°åˆ é™¤ å¹¶é‡Šæ”¾åˆ é™¤èŠ‚ç‚¹çš„ç©ºé—´ 1234567891011121314151617181920// åˆ é™¤èŠ‚ç‚¹ int delNode(Node* L, int pos){ Node* p = L; // è®©æŒ‡é’ˆæŒ‡å‘éœ€è¦åˆ é™¤ä½ç½®çš„å‰é©±èŠ‚ç‚¹ for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p == NULL) { return 0; } } if (p-&gt;next == NULL){ printf(\"ä½ç½®é”™è¯¯\\n\"); } Node* q = p-&gt;next; // qæŒ‡å‘è¦åˆ é™¤çš„èŠ‚ç‚¹ p-&gt;next = q-&gt;next; // è¦åˆ é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹æŒ‡å‘å…¶åç»§èŠ‚ç‚¹ free(q); return 1; } è·å–é“¾è¡¨é•¿åº¦ 12345678910// è·å–é“¾è¡¨é•¿åº¦ int listLength(Node* L){ Node* p = L; int cnt = 0; while(p!=NULL){ p = p-&gt;next; cnt++; } return cnt; } é‡Šæ”¾é“¾è¡¨ æŠŠå¤´ç»“ç‚¹åçš„èŠ‚ç‚¹éƒ½é‡Šæ”¾æ‰ è®©æŒ‡é’ˆpæŒ‡å‘å¤´èŠ‚ç‚¹åçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ è‹¥pä¸ä¸ºNULLï¼Œè®©qæŒ‡å‘pçš„åç»§èŠ‚ç‚¹ï¼Œå¹¶é‡Šæ”¾pæŒ‡å‘çš„èŠ‚ç‚¹ è®©p, qæŒ‡å‘åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¾ªç¯ä»¥ä¸Šæ“ä½œ 12345678910111213// é‡Šæ”¾é“¾è¡¨ void freeList(Node* L){ Node* p = L-&gt;next; // pæŒ‡é’ˆæŒ‡å‘å¤´èŠ‚ç‚¹åçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ Node* q; while(p!=NULL){ // åˆ¤æ–­pæŒ‡å‘æ˜¯å¦æ˜¯ç©ºèŠ‚ç‚¹ q = p-&gt;next; // qæŒ‡å‘pçš„åç»§ free(p); // é‡Šæ”¾p p = q; // pæŒ‡å‘å…¶åç»§ï¼ˆqæŒ‡å‘çš„èŠ‚ç‚¹ï¼‰ } L-&gt;next = NULL; //é‡Šæ”¾ååŸé“¾è¡¨å¤´èŠ‚ç‚¹æŒ‡å‘NULL } æ³¨æ„ æ—¶é—´å¤æ‚åº¦ï¼šè¯»å–æ•°æ®â€“é¡ºåºè¡¨&gt;é“¾è¡¨ ä¿®æ”¹æ•°æ®â€“é“¾è¡¨&gt;é¡ºåºè¡¨ ä¸è¦å¿˜è®°åˆå§‹åŒ–æŒ‡é’ˆå˜é‡ï¼Œé˜²æ­¢å…¶å˜ä¸ºé‡æŒ‡é’ˆ ä½•æ—¶ä½¿ç”¨mallocï¼Ÿ å£°æ˜æŒ‡å‘ä¸€ä¸ªç»“æ„çš„æŒ‡é’ˆä¸ä¼šåˆ›å»ºè¯¥ç»“æ„ï¼Œè€Œæ˜¯ç»™å‡ºè¶³å¤Ÿç©ºé—´å®¹çº³ç»“æ„å¯èƒ½ä¼šä½¿ç”¨çš„åœ°å€ ä½¿ç”¨mallocå¯ä»¥ä½¿ç³»ç»Ÿåˆ›å»ºä¸€ä¸ªæ–°çš„ç»“æ„å¹¶è¿”å›æŒ‡å‘è¯¥ç»“æ„çš„æŒ‡é’ˆ æ•…è‹¥æƒ³ä½¿ç”¨æŒ‡é’ˆå˜é‡æ²¿ç€ä¸€ä¸ªè¡¨è¡Œè¿›ï¼Œå°±æ²¡å¿…è¦åˆ›å»ºæ–°çš„ç»“æ„ï¼Œä¸å®œä½¿ç”¨malloc freeçš„ç»“æœï¼šæŒ‡é’ˆæŒ‡å‘çš„åœ°å€æ²¡å˜ï¼Œä½†è¯¥ä½ç½®å¤„çš„æ•°æ®å·²ç»æ— å®šä¹‰äº†ï¼ˆé‡æŒ‡é’ˆï¼‰ è‹¥æœªå¯¹é“¾è¡¨è¿›è¡Œè¿‡åˆ é™¤æ“ä½œï¼Œåˆ™è°ƒç”¨mallocçš„æ¬¡æ•°åº”è¯¥ç­‰äºè¡¨çš„å¤§å°ï¼Œå«è¡¨å¤´å†+1 å•é¡¹å¾ªç¯é“¾è¡¨ ç‰¹ç‚¹ï¼šè¡¨ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸæŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œå½¢æˆä¸€ä¸ªç¯ ç»ˆæ­¢æ¡ä»¶ï¼šp!=Læˆ–p-&gt;next!=L åˆ¤æ–­æ˜¯å¦æœ‰ç¯ å¿«æ…¢æŒ‡é’ˆ è®©å¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ¬¡èµ°ä¸€æ­¥ å½“é‡ä¸åˆ°NULLæ—¶ï¼Œè‹¥æœ‰ç¯ï¼Œåˆ™ä¸¤è€…ä¼šä¸€ç›´è¿½èµ¶ï¼Œæ ¹æ®æ¦‚ç‡ä¸€å®šä¼šæœ‰ä¸€ä¸ªæ—¶å€™ç›¸é‡ è‹¥èƒ½ç›¸é‡åˆ™è¯´æ˜æœ‰ç¯ï¼Œå¦åˆ™è‹¥ç¢°åˆ°NULLè¯æ˜æ²¡æœ‰ç¯ æ³¨æ„ç‰¹åˆ¤åªæœ‰ä¸€ä¸ªå…ƒç´ æˆ–æ²¡æœ‰å…ƒç´ æ—¶ï¼Œä¸ç„¶å½“å‰èŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸä¼šèµ‹å€¼ç»™ç©ºæŒ‡é’ˆè€ŒæŠ¥RE 1234567891011121314class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return false; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow) return true; } return false; } }; æ‰¾åˆ°ç¯çš„å…¥å£ è®¾èµ·ç‚¹åˆ°å…¥å£è·ç¦»ä¸ºï¼Œå…¥å£åˆ°ç›¸é‡è·ç¦»ä¸ºï¼Œç›¸é‡å†åˆ°å…¥å£è·ç¦»ä¸ºï¼Œåˆ™å¿«æ…¢æŒ‡é’ˆèµ°çš„è·¯ç¨‹å¦‚ä¸‹ï¼š å…¶ä¸­nä¸ºåœˆæ•°ï¼Œç”±äºå¿«æŒ‡é’ˆçš„é€Ÿåº¦ä¸ºæ…¢æŒ‡é’ˆçš„ä¸¤å€ï¼Œæ•…æ…¢æŒ‡é’ˆä¸€å®šä¼šåœ¨ä¸€åœˆå†…ä¸å¿«æŒ‡é’ˆç›¸é‡ æœ‰ åŒ–ç®€å¾—$ = n(y+z)-yï¼Œç”±äºå¿«æŒ‡é’ˆå…ˆå…¥ç¯ï¼Œä¸”é€Ÿåº¦å¿«äºæ…¢æŒ‡é’ˆï¼Œæ•…å¿«æŒ‡é’ˆè‡³å°‘è½¬ä¸€åœˆæ‰èƒ½ä¸æ…¢æŒ‡é’ˆç›¸é‡ï¼Œå³n$è‡³å°‘ä¸º1 å¤šæ‹¿å‡ºä¸€åœˆæ¥å°†yçº¦æ‰ï¼Œåˆ™ å½“æ—¶ï¼Œå³å¿«æŒ‡é’ˆè½¬ä¸€åœˆä¸æ…¢æŒ‡é’ˆç›¸é‡çš„æƒ…å†µä¸‹ï¼Œï¼Œå³ä¸¤è€…ä¼šåœ¨ç¯çš„å…¥å£å¤„ç›¸é‡ å½“æ—¶ï¼Œç”±äºæ˜¯ä¸€æ•´åœˆçš„è·¯ç¨‹ï¼Œå³èµ°å®Œè‹¥å¹²åœˆåå¿«æŒ‡é’ˆè¿˜ä¼šå†èµ°è·ç¦»ï¼Œæœ€åä¸æ…¢æŒ‡é’ˆåœ¨ç¯çš„å…¥å£å¤„ç›¸é‡ æ•…æˆ‘ä»¬å¯ä»¥åœ¨ç›¸é‡ä½ç½®è®¾ç½®ä¸€ä¸ªæŒ‡é’ˆï¼Œåœ¨èµ·å§‹ä½ç½®è®¾ç½®ä¸€ä¸ªæŒ‡é’ˆï¼Œä¸¤è€…ç›¸é‡å¤„å³ä¸ºå…¥å£ 12345678910111213141516171819202122232425262728struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; class Solution { public: ListNode* detectCycle(ListNode *head) { int cnt[10005]; ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return nullptr; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow){ ListNode* index1 = fast; ListNode* index2 = head; while(index1!=index2){ index1 = index1-&gt;next; index2 = index2-&gt;next; } return index1; } } return nullptr; } }; åŒå‘é“¾è¡¨ ç‰¹ç‚¹ï¼šåŒå‘é“¾è¡¨çš„èŠ‚ç‚¹ä¸­æœ‰ä¸¤ä¸ªæŒ‡é’ˆåŸŸï¼šä¸€ä¸ªæŒ‡å‘ç›´æ¥åç»§ï¼Œå¦ä¸€ä¸ªæŒ‡å‘ç›´æ¥å‰é©± å»ºè¡¨ 12345typedef int ElemType; typedef struct node{ ElemType data; struct node *prev, *next; }Node; åˆå§‹åŒ– ä¸å•é“¾è¡¨ç›¸åŒ 1234567// åˆå§‹åŒ–å»ºç«‹å¤´èŠ‚ç‚¹ Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // åˆ†é…ä¸€ä¸ªèŠ‚ç‚¹å¤§å°çš„ç©ºé—´ head-&gt;data = 0; // æ•°æ®è®¾ä¸º0 head-&gt;next = NULL; // ä¸‹ä¸€ä¸ªåœ°å€è®¾ä¸ºNULL return head; } å¤´æ’æ³• è®©æ–°èŠ‚ç‚¹çš„prevæŒ‡å‘å¤´èŠ‚ç‚¹ è®©æ–°èŠ‚ç‚¹çš„nextæŒ‡å‘å¤´èŠ‚ç‚¹çš„next è®©å¤´èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„prevæŒ‡å‘æ–°èŠ‚ç‚¹ï¼Œè®©å¤´èŠ‚ç‚¹çš„nextæŒ‡å‘æ–°èŠ‚ç‚¹ 123456789101112// å¤´æ’æ³• int insertHead(Node* L, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = L; // æ–°èŠ‚ç‚¹çš„prevæŒ‡å‘å¤´èŠ‚ç‚¹ p-&gt;next = L-&gt;next; // æ–°èŠ‚ç‚¹çš„nextæŒ‡å‘å¤´èŠ‚ç‚¹åçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ if (L-&gt;next!=NULL){ // ä¿è¯å¹¶éåªæœ‰ä¸€ä¸ªå¤´èŠ‚ç‚¹ L-&gt;next-&gt;prev = p; // æ–°èŠ‚ç‚¹çš„nextèŠ‚ç‚¹çš„prevæŒ‡å‘æ–°èŠ‚ç‚¹ } L-&gt;next = p; // å¤´èŠ‚ç‚¹çš„nextèŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹ return 1; } å°¾æ’æ³• è®©æ–°èŠ‚ç‚¹çš„prevæŒ‡å‘å°¾èŠ‚ç‚¹ è®©å°¾èŠ‚ç‚¹çš„nextæŒ‡å‘æ–°èŠ‚ç‚¹ å°†NULLå€¼èµ‹ç»™æ–°èŠ‚ç‚¹çš„next 123456789101112131415161718// è·å¾—å°¾èŠ‚ç‚¹åœ°å€ Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // å½“èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ p = p-&gt;next; // é¡ºç€å¯»æ‰¾ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ } return p; } // å°¾æ’æ³• Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = tail; tail-&gt;next = p; p-&gt;next = NULL; return p; } æŒ‡å®šä½ç½®æ’å…¥ å¯»æ‰¾å‰ç½®èŠ‚ç‚¹ï¼Œè®©æ–°èŠ‚ç‚¹prevæŒ‡å‘å‰ç½®èŠ‚ç‚¹ è®©æ–°èŠ‚ç‚¹çš„nextæŒ‡å‘åç½®èŠ‚ç‚¹ è®©å‰ç½®èŠ‚ç‚¹çš„nextçš„prevæŒ‡å‘æ–°èŠ‚ç‚¹ å‰ç½®èŠ‚ç‚¹çš„nextæŒ‡å‘æ–°èŠ‚ç‚¹ 1234567891011121314151617// æŒ‡å®šä½ç½®æ’å…¥æ•°æ® int insertNode(Node* L, int pos, ElemType e){ Node* p = L; for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); q-&gt;data = e; q-&gt;prev = p; q-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = q; p-&gt;next = q; return 1; } åˆ é™¤å…ƒç´  æ‰¾åˆ°è¦åˆ é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ï¼Œç”¨æŒ‡é’ˆè®°å½•è¦åˆ é™¤çš„èŠ‚ç‚¹ æ”¹å˜pçš„åç»§èŠ‚ç‚¹ä»¥åŠåˆ é™¤èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹çš„å‰é©±æ¥åˆ é™¤èŠ‚ç‚¹ 12345678910111213141516171819// åˆ é™¤å…ƒç´  int delNode(Node* L, int pos){ Node *p = L; for (int i = 0;i&lt;pos-1;i++){ // æ‰¾åˆ°å‰é©±èŠ‚ç‚¹ p = p-&gt;next; if (p==NULL){ return 0; } } if (p-&gt;next==NULL){ // åˆ¤æ–­åˆ é™¤ä½ç½®æ˜¯å¦è¶…å‡ºäº†è¡¨é•¿åº¦ printf(\"è¦åˆ é™¤çš„ä½ç½®é”™è¯¯\"); return 0; } Node* q = p-&gt;next; // qæŒ‡å‘è¦åˆ é™¤çš„èŠ‚ç‚¹ p-&gt;next = q-&gt;next; // pçš„nextæŒ‡å‘qçš„åç»§èŠ‚ç‚¹ q-&gt;next-&gt;prev = p; // qçš„åç»§èŠ‚ç‚¹çš„prevæŒ‡å‘p free(q); // åˆ é™¤q return 1; } é¡ºåºè¡¨ä¸é“¾è¡¨","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"è¡¨","slug":"è¡¨","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"ã€è®¡ç®—æœºç½‘ç»œã€‘Webåº”ç”¨çš„è¯·æ±‚ä¸å“åº”æœºåˆ¶","slug":"Webåº”ç”¨çš„è¯·æ±‚ä¸å“åº”æœºåˆ¶","date":"2025-03-21T14:20:01.860Z","updated":"2025-03-21T14:26:06.491Z","comments":true,"path":"2025/03/21/Webåº”ç”¨çš„è¯·æ±‚ä¸å“åº”æœºåˆ¶/","permalink":"https://izayoisakuye.github.io/2025/03/21/Web%E5%BA%94%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Webåº”ç”¨çš„è¯·æ±‚ä¸å“åº”æœºåˆ¶ HTTPåè®® HTTPæ˜¯webé€šä¿¡çš„åŸºç¡€åè®®ï¼Œæ˜¯å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨è¿›è¡Œäº¤äº’çš„æ ‡å‡†ï¼Œæ‰€æœ‰wwwæ–‡ä»¶å¿…é¡»éµå®ˆè¿™ä¸ªæ ‡å‡†ï¼Œå…¶ç«¯å£å·ä¸º80 HTTPSæ˜¯HTTPçš„å®‰å…¨ç‰ˆï¼Œåœ¨HTTPä¸‹åŠ å…¥SSLå±‚ SSLæ˜¯ä¸»è¦ç”¨äºwebçš„å®‰å…¨ä¼ è¾“åè®®ï¼Œåœ¨ä¼ è¾“å±‚å¯¹ç½‘ç»œè¿æ¥è¿›è¡ŒåŠ å¯†ï¼Œå…¶ç«¯å£å·ä¸º443 å·¥ä½œåŸç† HTTPé€šä¿¡ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šå®¢æˆ·ç«¯è¯·æ±‚ä¿¡æ¯ã€æœåŠ¡å™¨å“åº”ä¿¡æ¯ - å½“ç”¨æˆ·åœ¨åœ°å€æ è¾“å…¥ä¸€ä¸ªURLå¹¶å›è½¦åï¼Œå®¢æˆ·ç«¯å‘webæœåŠ¡å™¨å‘é€HTTPè¯·æ±‚ï¼Œå»ºç«‹ä¸€ä¸ªåˆ°æœåŠ¡å™¨æŒ‡å®šç«¯å£çš„TCPè¿æ¥ - æœåŠ¡å™¨åœ¨é‚£ä¸ªç«¯å£ç›‘å¬å®¢æˆ·ç«¯å‘é€è¿‡æ¥çš„è¯·æ±‚ï¼Œæ”¶åˆ°è¯·æ±‚åï¼ŒæœåŠ¡å™¨æ ¹æ®å†…å®¹ä¸ç±»å‹è¿›è¡Œå¤„ç†ï¼Œå¹¶ç”ŸæˆHTTPå“åº”ï¼ŒåŒ…æ‹¬ä¸€ä¸ªçŠ¶æ€è¡Œä¸ç›¸åº”çš„ä¿¡æ¯ - å®¢æˆ·ç«¯æ¥å—æœåŠ¡å™¨è¿”å›çš„å“åº”ï¼Œå¹¶æ ¹æ®å†…å®¹å‘ˆç°ç»™ç”¨æˆ· URL ç»Ÿä¸€èµ„æºå®šä½ç¬¦ï¼ˆUniform / Universal Resource Locatorï¼‰ï¼Œæ˜¯ç”¨äºå®Œæ•´æè¿°ç½‘é¡µå’Œå…¶ä»–èµ„æºçš„åœ°å€çš„ä¸€ç§æ ‡è¯†æ–¹æ³• åŸºæœ¬æ ¼å¼ï¼š scheme://host[:port#]/path/â€¦/[?query-string][#anchor] - schemeï¼šåè®®ï¼ˆå¦‚httpä¸httpsï¼‰ - hostï¼šæœåŠ¡å™¨ipåœ°å€æˆ–åŸŸå - portï¼šæœåŠ¡å™¨ç«¯å£ï¼ˆå¦‚æœèµ°åè®®é»˜è®¤ç«¯å£ï¼Œç¼ºçœç«¯å£80ï¼‰ - pathï¼šè®¿é—®èµ„æºçš„è·¯å¾„ - query-stringï¼šå‚æ•°ï¼Œå‘é€ç»™httpæœåŠ¡å™¨çš„æ•°æ® - anchorï¼šé”šï¼Œè·³è½¬åˆ°ç½‘é¡µçš„æŒ‡å®šé”šç‚¹ä½ç½® HTTPè¯·æ±‚ HTTPç”¨æ¥æäº¤å’Œè·å–èµ„æºï¼Œå®¢æˆ·ç«¯å‘é€ä¸€ä¸ªHTTPè¯·æ±‚è¯·æ±‚åˆ°æœåŠ¡å™¨çš„è¯·æ±‚ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼šè¯·æ±‚è¡Œã€è¯·æ±‚å¤´éƒ¨ã€ç©ºè¡Œã€è¯·æ±‚æ•°æ®å››ä¸ªéƒ¨åˆ†ï¼Œæ ¼å¼å¦‚ä¸‹ HTTPè¯·æ±‚ ä¸€äº›å¸¸ç”¨çš„è¯·æ±‚æŠ¥å¤´ï¼š - Hostï¼šå¯¹åº”URLä¸­çš„webåç§°ä¸ç«¯å£å·ï¼Œç”¨äºæŒ‡å®šè¢«è¯·æ±‚èµ„æºçš„Internetä¸»æœºä¸ç«¯å£å· - Connectionï¼šè¡¨ç¤ºå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨è¿æ¥ç±»å‹ Client å‘èµ·ä¸€ä¸ªåŒ…å« Connection:keep-alive çš„è¯·æ±‚ï¼Œ HTTP/1.1 ä½¿ç”¨ keep-alive ä¸ºé»˜è®¤å€¼ã€‚ Server æ”¶åˆ°è¯·æ±‚åï¼šå¦‚æœ Server æ”¯æŒ keep-aliveï¼ˆé•¿è¿æ¥ï¼‰ï¼Œ å›å¤ä¸€ä¸ªåŒ…å« Connection:keep-alive çš„å“åº”ï¼Œ ä¸å…³é—­è¿æ¥ï¼›å¦‚æœ Server ä¸æ”¯æŒ keep-aliveï¼Œ å›å¤ä¸€ä¸ªåŒ…å« Connection:close çš„å“åº”ï¼Œ å…³é—­è¿æ¥ã€‚å¦‚æœ client æ”¶åˆ°åŒ…å« Connection:keep-alive çš„å“åº”ï¼Œ å‘åŒä¸€ä¸ªè¿æ¥å‘é€ä¸‹ä¸€ä¸ªè¯·æ±‚ï¼Œ ç›´åˆ°ä¸€æ–¹ä¸»åŠ¨å…³é—­è¿æ¥ã€‚ keep-alive åœ¨å¾ˆå¤šæƒ…å†µä¸‹èƒ½å¤Ÿé‡ç”¨è¿æ¥ï¼Œ å‡å°‘èµ„æºæ¶ˆè€—ï¼Œ ç¼©çŸ­å“åº”æ—¶é—´ï¼Œ æ¯”å¦‚å½“æµè§ˆå™¨éœ€è¦å¤šä¸ªæ–‡ä»¶æ—¶(æ¯”å¦‚ä¸€ä¸ª HTML æ–‡ä»¶å’Œç›¸å…³çš„å›¾å½¢æ–‡ä»¶)ï¼Œ ä¸éœ€è¦æ¯æ¬¡éƒ½å»è¯·æ±‚å»ºç«‹è¿æ¥ã€‚ - Upgrade-Insecure-Requestsï¼šå‡çº§ä¸å®‰å…¨çš„è¯·æ±‚ï¼Œ æ„æ€æ˜¯ä¼šåœ¨åŠ è½½ http èµ„æºæ—¶è‡ªåŠ¨æ›¿æ¢æˆ https è¯·æ±‚ï¼Œ è®©æµè§ˆå™¨ä¸å†æ˜¾ç¤º https é¡µé¢ä¸­çš„ http è¯·æ±‚è­¦æŠ¥ã€‚ - User-Agentï¼šå®¢æˆ·æµè§ˆå™¨çš„è¯¦ç»†ä¿¡æ¯ï¼ŒæœåŠ¡å™¨æ ¹æ®è¿™æ¡ä¿¡æ¯æ¥åˆ¤æ–­æ¥è®¿ç”¨æˆ·æ˜¯å¦ä¸ºçœŸå®ç”¨æˆ· - Acceptï¼šæŒ‡æµè§ˆå™¨æˆ–å…¶ä»–å®¢æˆ·ç«¯å¯ä»¥æ¥å—çš„MIMEï¼ˆMultipurpose Internet Mail Extensionsï¼‰æ–‡ä»¶ç±»å‹ï¼ŒæœåŠ¡å™¨æ ¹æ®å…¶åˆ¤æ–­å¹¶è¿”å›é€‚å½“æ–‡ä»¶æ ¼å¼ - Accept: /ï¼š è¡¨ç¤ºä»€ä¹ˆéƒ½å¯ä»¥æ¥æ”¶ã€‚ - Accept: text/html, application/xhtml+xml;q=0.9, image/;q=0.8ï¼š è¡¨ç¤ºæµè§ˆå™¨æ”¯æŒçš„ MIME ç±»å‹åˆ†åˆ«æ˜¯htmlæ–‡æœ¬ã€xhtmlå’Œxmlæ–‡æ¡£ã€ æ‰€æœ‰çš„å›¾åƒæ ¼å¼èµ„æºã€‚ qæ˜¯æƒé‡ç³»æ•°ï¼Œ èŒƒå›´ ï¼Œqå€¼è¶Šå¤§ï¼Œè¯·æ±‚è¶Šå€¾å‘äºè·å¾—å…¶â€œ;â€ä¹‹å‰çš„ç±»å‹è¡¨ç¤ºçš„å†…å®¹ã€‚è‹¥æ²¡æœ‰æŒ‡å®š q å€¼ï¼Œ åˆ™é»˜è®¤ä¸º1ï¼ŒæŒ‰ä»å·¦åˆ°å³æ’åºé¡ºåºï¼›è‹¥è¢«èµ‹å€¼ä¸º 0ï¼Œåˆ™ç”¨äºè¡¨ç¤ºæµè§ˆå™¨ä¸æ¥å—æ­¤å†…å®¹ç±»å‹ã€‚ Textï¼šç”¨äºæ ‡å‡†åŒ–åœ°è¡¨ç¤ºçš„æ–‡æœ¬ä¿¡æ¯ï¼Œæ–‡æœ¬æ¶ˆæ¯å¯ä»¥æ˜¯å¤šç§å­—ç¬¦é›†å’Œæˆ–è€…å¤šç§æ ¼å¼çš„ï¼› Applicationï¼šç”¨äºä¼ è¾“åº”ç”¨ç¨‹åºæ•°æ®æˆ–è€…äºŒè¿›åˆ¶æ•°æ®ã€‚ - Refererï¼šè¡¨æ˜äº§ç”Ÿè¯·æ±‚çš„ç½‘é¡µæ¥è‡ªäºå“ªä¸ªURLï¼Œç”¨æˆ·æ˜¯ä»è¯¥refereré¡µé¢è®¿é—®åˆ°å½“å‰è¯·æ±‚çš„é¡µé¢ï¼Œå¯ä»¥ç”¨æ¥è·Ÿè¸ªwebè¯·æ±‚æ¥è‡ªå“ªä¸ªé¡µé¢ï¼Œå“ªä¸ªç½‘ç«™ - Accept-Encodingï¼šæŒ‡å‡ºæµè§ˆå™¨å¯ä»¥æ¥å—çš„ç¼–ç æ–¹å¼ã€‚ ç¼–ç æ–¹å¼ä¸åŒäºæ–‡ä»¶æ ¼å¼ï¼Œ å®ƒæ˜¯ä¸ºäº†å‹ç¼©æ–‡ä»¶å¹¶åŠ é€Ÿæ–‡ä»¶ä¼ é€’é€Ÿåº¦ã€‚ æµè§ˆå™¨åœ¨æ¥æ”¶åˆ° Web å“åº”ä¹‹åå…ˆè§£ç ï¼Œ ç„¶åå†æ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼Œ è®¸å¤šæƒ…å½¢ä¸‹è¿™å¯ä»¥å‡å°‘å¤§é‡çš„ä¸‹è½½æ—¶é—´ã€‚ å¦‚Accept-Encoding:gzip;q=1.0, identity; q=0.5, ;q=0 å¦‚æœæœ‰å¤šä¸ª Encoding åŒæ—¶åŒ¹é…, æŒ‰ç…§qå€¼é¡ºåºæ’åˆ—ï¼Œæœ¬ä¾‹ä¸­æŒ‰é¡ºåºæ”¯æŒ gzip, identityå‹ç¼©ç¼–ç ï¼Œ æ”¯æŒgzipçš„æµè§ˆå™¨ä¼šè¿”å›ç»è¿‡gzipç¼–ç çš„HTMLé¡µé¢ã€‚ å¦‚æœè¯·æ±‚æ¶ˆæ¯ä¸­æ²¡æœ‰è®¾ç½®è¿™ä¸ªåŸŸæœåŠ¡å™¨å‡å®šå®¢æˆ·ç«¯å¯¹å„ç§å†…å®¹ç¼–ç éƒ½å¯ä»¥æ¥å—ã€‚ - Accept-Languageï¼šæŒ‡è¯­è¨€å¯ä»¥æ¥å—çš„è¯­è¨€ç§ç±»ï¼Œå¦‚zhæˆ–zh-cnæŒ‡ä¸­æ–‡ - Accept-Charsetï¼šæŒ‡æµè§ˆå™¨å¯ä»¥æ¥å—çš„å­—ç¬¦ç¼–ç ï¼Œç¼ºçœä¸ºä»»ä½•å­—ç¬¦é›† - Cookieï¼šæµè§ˆå™¨ç”¨è¿™ä¸ªå±æ€§å‘æœåŠ¡å™¨å‘é€ Cookieã€‚ - Content-Typeï¼šPOSTè¯·æ±‚é‡Œç”¨æ¥è¡¨ç¤ºçš„å†…å®¹ç±»å‹ã€‚ ç¤ºä¾‹ï¼š HTTPè¯·æ±‚ç¤ºä¾‹ å¸¸è§HTTPæ–¹æ³• GETï¼šè¯·æ±‚æŒ‡å®šèµ„æºï¼Œé€šå¸¸é™„åŠ åœ¨URLä¸­ï¼Œä¸é€‚åˆä¼ é€’å¤§é‡æ•°æ®ä¸éšç§æ•°æ® POSTï¼šå‘æœåŠ¡å™¨æäº¤æ•°æ®ï¼Œé€šå¸¸ç”¨äºæäº¤è¡¨å•ä¸ä¸Šä¼ æ–‡ä»¶ PUTï¼šæ›´æ–°æŒ‡å®šèµ„æºå†…å®¹ HEADï¼šåªè¿”å›å“åº”å¤´ï¼Œä¸è¿”å›å“åº”ä½“ OPTIONSï¼šæŸ¥è¯¢æœåŠ¡å™¨æ”¯æŒçš„HTTPæ–¹æ³• HTTPå“åº” ç”±å››éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«ä¸ºçŠ¶æ€è¡Œã€æ¶ˆæ¯æŠ¥å¤´ã€ç©ºè¡Œã€å“åº”æ­£æ–‡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š HTTPå“åº” ç†è®ºä¸Šæ‰€æœ‰å“åº”å¤´ä¿¡æ¯éƒ½æ˜¯å›åº”è¯·æ±‚å¤´çš„ï¼Œä½†è¿˜ä¼šæ·»åŠ å¯¹åº”çš„å“åº”å¤´ä¿¡æ¯ ç¤ºä¾‹ï¼š HTTPå“åº”ç¤ºä¾‹ HTTPçŠ¶æ€ç  webæœåŠ¡å™¨å¯¹HTTPè¯·æ±‚çš„å›åº”ï¼Œè¡¨ç¤ºè¯·æ±‚æ˜¯å¦æˆåŠŸå¤„ç† 1xxï¼šæœåŠ¡å™¨æˆåŠŸæ¥å—éƒ¨åˆ†è¯·æ±‚ 2xxï¼šæˆåŠŸï¼ˆ200 OKï¼‰ 3xxï¼šé‡å®šå‘ï¼ˆ301 Moved Permanentlyï¼‰ 4xxï¼šå®¢æˆ·ç«¯é”™è¯¯ï¼ˆ404 Not Foundï¼‰ 5xxï¼šæœåŠ¡å™¨é”™è¯¯ï¼ˆ500 Internal Server Errorï¼‰ Cookieä¸Sessionï¼š æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯çš„äº¤äº’ä»…é™äºè¯·æ±‚/å“åº”è¿‡ç¨‹ï¼Œç»“æŸä¹‹åä¾¿æ–­å¼€ï¼Œåœ¨ä¸‹ä¸€æ¬¡è¯·æ±‚æ—¶ï¼ŒæœåŠ¡å™¨ä¼šè®¤ä¸ºæ–°çš„å®¢æˆ·ç«¯ã€‚ä¸ºäº†ç»´æŠ¤ä»–ä»¬ä¹‹é—´çš„é“¾æ¥ï¼Œè®©æœåŠ¡å™¨çŸ¥é“è¿™æ˜¯å‰ä¸€ä¸ªç”¨æˆ·å‘é€çš„è¯·æ±‚ï¼Œå¿…é¡»åœ¨ä¸€ä¸ªåœ°æ–¹ä¿å­˜å®¢æˆ·ç«¯çš„ä¿¡æ¯ã€‚ - Cookieï¼šé€šè¿‡åœ¨ å®¢æˆ·ç«¯ è®°å½•çš„ä¿¡æ¯ç¡®å®šç”¨æˆ·çš„èº«ä»½ã€‚ - Sessionï¼šé€šè¿‡åœ¨ æœåŠ¡å™¨ç«¯ è®°å½•çš„ä¿¡æ¯ç¡®å®šç”¨æˆ·çš„èº«ä»½ è¯·æ±‚å‚æ•°çš„è·å–ä¸å¤„ç† HTTPæºå¸¦å¤šç§æ•°æ®ï¼Œè¿™é‡Œé€šè¿‡pythonï¼Œä½¿ç”¨urllibä¸requestsåº“æ¥å¤„ç†è¿™äº›æ•°æ® å¤„ç†URLè·¯å¾„ä¸æŸ¥è¯¢å‚æ•° â€‹ URL æŸ¥è¯¢å‚æ•°æ˜¯æŒ‡åœ¨ URL ä¸­é€šè¿‡é”®å€¼å¯¹çš„å½¢å¼ä¼ é€’çš„å‚æ•°ï¼Œç”¨äºåœ¨ URL ä¸­å¢åŠ é¢å¤–çš„ä¿¡æ¯ï¼Œå¦‚æŸ¥è¯¢æ¡ä»¶ã€æ’åºæ–¹å¼ã€é¡µç ç­‰ã€‚æŸ¥è¯¢å‚æ•°é€šå¸¸ä½¿ç”¨é”®å€¼å¯¹çš„å½¢å¼å®šä¹‰ï¼Œé”®å’Œå€¼ä¹‹é—´ç”¨ = ç¬¦å·åˆ†éš”ï¼Œå¤šä¸ªå‚æ•°ä¹‹é—´ç”¨ &amp; ç¬¦å·åˆ†éš”ã€‚ä¾‹å¦‚ï¼Œå®šä¹‰ä¸€ä¸ªæŸ¥è¯¢å‚æ•° page çš„å€¼ä¸º 2ï¼Œå¯ä»¥å†™æˆ page=2 â€‹ æŸ¥è¯¢å‚æ•°çš„ä¸»è¦ç”¨é€”æ˜¯é€šè¿‡ URL ä¼ é€’ä¿¡æ¯ï¼Œå®ç°æœç´¢æŸ¥è¯¢ã€è¿‡æ»¤å™¨ç­‰åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·åœ¨è¾“å…¥æ¡†è¾“å…¥ abcï¼ŒæŒ‰ä¸‹å›è½¦ä¹‹åï¼Œä¼šè¿”å›ä¸€æ¡åœ°å€ä¸º https://www.example.com/?keyword=abc çš„ URLã€‚åœ¨ç”¨æˆ·è®¿é—®æ—¶ï¼ŒæœåŠ¡å™¨ä¼šé€šè¿‡ URL å‚æ•° keyword æ£€ç´¢ç›¸å…³å†…å®¹ï¼Œç„¶åè¿”å›ç»™ç”¨æˆ· â€‹ åœ¨pythonä¸­ï¼Œå¯ä»¥ä½¿ç”¨urllibåº“ä¸­urllib.parseæ¨¡å—ä¸­çš„parse_qså‡½æ•°æ¥è§£ææŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œä»¥ä¸‹ä¸ºç¤ºä¾‹ç¨‹åºï¼Œç¨‹åºè¿”å›å­—å…¸ï¼Œé”®å€¼å¯¹åˆ†åˆ«ä¸ºç­‰å·å·¦å³çš„å†…å®¹ 123456789101112131415from urllib.parse import urlparse, parse_qs # ç¤ºä¾‹URL url = 'http://example.com/path/to/resource?name=John&amp;age=30' # è§£æURL parsed_url = urlparse(url) # è·å–è·¯å¾„ path = parsed_url.path print(\"Path:\", path) # è§£ææŸ¥è¯¢å‚æ•° query_params = parse_qs(parsed_url.query) print(\"Query Parameters:\", query_params) Path: /path/to/resource Query Parameters: {'name': ['John'], 'age': ['30']} å¤„ç†è¡¨å•æ•°æ® è¡¨å•æ•°æ®æ˜¯é€šè¿‡ç½‘é¡µä¸Šçš„è¡¨å•æ”¶é›†å¹¶æäº¤ç»™æœåŠ¡å™¨çš„ä¿¡æ¯ï¼Œç”¨æˆ·å¯ä»¥å¡«å†™è¡¨å•æ¥æä¾›å„ç§ä¿¡æ¯ã€‚å½“ç”¨æˆ·ç‚¹å‡»è¡¨å•ä¸Šçš„æäº¤æŒ‰é’®æ—¶ï¼Œè¡¨å•æ•°æ®ä¼šè¢«å‘é€åˆ°æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨åˆ™æ ¹æ®æ¥æ”¶åˆ°çš„æ•°æ®æ‰§è¡Œç›¸åº”æ“ä½œ è¡¨å•çš„åŸºæœ¬ç»“æ„å¦‚ä¸‹ 123456789&lt;form action=\"/submit\" method=\"post\"&gt; &lt;label for=\"username\"&gt;ç”¨æˆ·å:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt;&lt;br&gt;&lt;br&gt; &lt;label for=\"password\"&gt;å¯†ç :&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"æäº¤\"&gt; &lt;/form&gt; &lt;form&gt;æ ‡ç­¾å®šä¹‰äº†ä¸€ä¸ªè¡¨å•ï¼Œactionå±æ€§æŒ‡å®šäº†è¡¨å•æ•°æ®æäº¤çš„ç›®æ ‡urlï¼Œmethodå±æ€§åˆ¶å®šäº†æäº¤æ•°æ®æ—¶ä½¿ç”¨çš„HTTPæ–¹æ³• - GETï¼šå½“methodå±æ€§è¢«è®¾ç½®ä¸ºGETæ—¶ï¼Œè¡¨å•æ•°æ®ä¼šè¢«é™„åŠ åœ¨urlåé¢ä½œä¸ºæŸ¥è¯¢å‚æ•°æäº¤ã€‚è¿™ç§æ–¹æ³•é€‚åˆæäº¤å°‘é‡çš„éæ•æ„Ÿæ•°æ® - POSTï¼šå½“methodå±æ€§è¢«è®¾ç½®ä¸ºPOSTæ—¶ï¼Œè¡¨å•æ•°æ®ä¼šåœ¨è¯·æ±‚ä½“ä¸­å‘é€ï¼Œä¸ä¼šå‡ºç°åœ¨urlä¸­ã€‚è¿™ç§æ–¹æ³•é€‚åˆæäº¤æ•æ„Ÿä¸å¤§é‡æ•°æ® &lt;input&gt;æ ‡ç­¾ç”¨äºåˆ›å»ºè¾“å…¥æ§ä»¶ï¼Œtypeå±æ€§å®šä¹‰äº†è¾“å…¥æ§ä»¶çš„ç±»å‹ï¼Œnameå±æ€§ä¸ºæäº¤å±æ€§æ—¶çš„é”®åï¼Œidç”¨äºå…³è”&lt;label&gt;æ ‡ç­¾ &lt;label&gt;æ ‡ç­¾ç”¨äºæè¿°æ¯ä¸ªè¾“å…¥æ§ä»¶çš„ç”¨é€” è¡¨å•æ•°æ®çš„ç¼–ç ï¼š - application/x-www-form-urlencodedï¼šè¿™æ˜¯é»˜è®¤çš„ç¼–ç æ–¹å¼ï¼Œè¡¨å•æ•°æ®è¢«ç¼–ç æˆé”®å€¼å¯¹çš„å½¢å¼ï¼Œå¦‚ username=John&amp;password=Doeã€‚ - multipart/form-dataï¼šå½“è¡¨å•ä¸­åŒ…å«æ–‡ä»¶ä¸Šä¼ å­—æ®µæ—¶ï¼Œå¿…é¡»ä½¿ç”¨æ­¤ç¼–ç æ–¹å¼ã€‚å®ƒå…è®¸å°†æ–‡ä»¶å’Œå…¶ä»–æ•°æ®ä¸€èµ·å‘é€ã€‚ æˆ‘ä»¬å¯ä»¥åœ¨pythonä¸­é€šè¿‡requeståº“å‘é€POSTè¯·æ±‚æ¥è·å–è¡¨å•æ•°æ®å¹¶å¤„ç†ï¼Œè¿”å›çš„æ˜¯htmlç±»å‹çš„è¡¨å•æ•°æ® 1234567891011121314import requests # ç¤ºä¾‹è¡¨å•æ•°æ® form_data = { 'username': 'john_doe', 'password': 'securepassword' } # å‘é€POSTè¯·æ±‚ response = requests.post('https://www.baidu.com/', data=form_data) # æŸ¥çœ‹å“åº” print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text) å¤„ç†JSONæ•°æ® pythonä¸­å¯ä»¥ä½¿ç”¨requeståº“æ¥å¤„ç†jsonæ•°æ® 123456789101112131415import requests import json # ç¤ºä¾‹JSONæ•°æ® json_data = { 'name': 'John', 'age': 30 } # å‘é€POSTè¯·æ±‚ response = requests.post('https://www.baidu.com/', json=json_data) # æŸ¥çœ‹å“åº” print(\"Response Status Code:\", response.status_code) print(\"Response JSON:\", response.json()) å¤„ç†æ–‡ä»¶ä¸Šä¼  HTTPæ–‡ä»¶ä¸Šä¼ æ˜¯é€šè¿‡HTTPåè®®å°†æ–‡ä»¶ä»å®¢æˆ·ç«¯ä¼ è¾“åˆ°æœåŠ¡å™¨çš„ä¸€ç§æ–¹å¼ã€‚é€šå¸¸ä½¿ç”¨POSTæ–¹æ³•ï¼Œå¹¶ä¸”æ•°æ®æ ¼å¼ä¸ºmultipart/form-dataã€‚è¿™ç§æ ¼å¼å…è®¸åœ¨åŒä¸€ä¸ªè¯·æ±‚ä¸­ä¼ è¾“å¤šä¸ªå­—æ®µå’Œæ–‡ä»¶ã€‚ HTTPæ–‡ä»¶ä¸Šä¼ ä¸­ï¼Œè¯·æ±‚å¤´éœ€è¦åŒ…å«Content-Typeï¼Œå…¶å€¼ä¸ºmultipart/form-dataï¼Œå¹¶æŒ‡å®šä¸€ä¸ªè¾¹ç•Œï¼ˆboundaryï¼‰ï¼Œç”¨äºåˆ†éš”ä¸åŒçš„å­—æ®µå’Œæ–‡ä»¶ã€‚ä¾‹å¦‚ 12345678910POST /upload HTTP/1.1 Host: www.example.com Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycz5DOEJKqu7XXB7k ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name=\"file\"; filename=\"example.png\" Content-Type: image/png &lt;æ–‡ä»¶å†…å®¹&gt; ------WebKitFormBoundarycz5DOEJKqu7XXB7k-- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨pythonçš„requeståº“æ¥å¤„ç†æ–‡ä»¶ä¸Šä¼ å“åº” 1234567891011import requests # æ‰“å¼€æ–‡ä»¶ files = {'file': open('example.txt', 'rb')} # å‘é€POSTè¯·æ±‚ response = requests.post('http://example.com/upload', files=files) # æŸ¥çœ‹å“åº” print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text)","categories":[{"name":"è®¡ç®—æœºç½‘ç»œ","slug":"è®¡ç®—æœºç½‘ç»œ","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"è®¡ç®—æœºç½‘ç»œ","slug":"è®¡ç®—æœºç½‘ç»œ","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Mutablity","slug":"CS61Aâ€”â€”Mutablity","date":"2025-03-19T11:10:30.067Z","updated":"2025-03-19T11:11:00.592Z","comments":true,"path":"2025/03/19/CS61Aâ€”â€”Mutablity/","permalink":"https://izayoisakuye.github.io/2025/03/19/CS61A%E2%80%94%E2%80%94Mutablity/","excerpt":"","text":"Mutablity Objects å¯¹è±¡ç”¨äºè¡¨è¾¾ä¿¡æ¯ï¼Œæ˜¯ä¸€ç§åŒ…å«äº†æ•°æ®ä¸è¡Œä¸ºçš„æ•°æ®æŠ½è±¡ æœ‰å±æ€§çš„ä¸œè¥¿éƒ½å¯ä»¥ä½œä¸ºå¯¹è±¡ï¼Œpythonä¸­ä¸€åˆ‡çš†å¯¹è±¡ Pythonä¸­ï¼Œä¼˜å…ˆçº§æœ€é«˜çš„å¯¹è±¡è¢«ç§°ä¸ºç±»ï¼ˆclassï¼‰ é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰ï¼š å¯¹è±¡æ˜¯OOPçš„æ ¸å¿ƒ OOPä½¿ç”¨ä¸€ç§æš—å–»æ¥ç»„ç»‡å¤§å‹ç¨‹åº ä½¿ç”¨ä¸€ç§ç‰¹æ®Šè¯­æ³•å¯ä»¥æé«˜ç¨‹åºçš„å¯è¯»æ€§ä¸ç»„ç»‡ å¾ˆå¤šæ•°æ®æ“ä½œéƒ½æ˜¯é€šè¿‡å¯¹è±¡å®ç°çš„ å¯¹è±¡å¯ä»¥åšè®¸å¤šç›¸å…³çš„äº‹æƒ…ï¼Œè€Œå‡½æ•°åªèƒ½åšä¸€ä»¶äº‹ e.g. String å­—ç¬¦ä¸²æ˜¯ä¸€ç§è¡¨è¾¾æ–‡æœ¬çš„æ•°æ®æŠ½è±¡ ### å­—ç¬¦ä¸²çš„è¡¨ç¤º ç›®å‰å¸¸è§çš„è¡¨ç¤ºæ–¹æ³•æ˜¯ç”¨ASCIIä¸Unicodeå­—ç¬¦é›†è¡¨ç¤ºå­—ç¬¦ å‰è€…åŒ…å«äº†æ§åˆ¶å­—ç¬¦ã€æ•°å­—ã€å­—æ¯ä¸æ ‡ç‚¹ï¼Œåè€…åˆ™åŒ…å«äº†ä¸åŒè¯­è¨€ä¸­çš„æ›´å¤šå­—ç¬¦ 1234from unicodedata import name, lookup print(name('A')) # æŸ¥è¯¢å­—ç¬¦é›†ä¸­çš„å­—ç¬¦åç§° print(lookup('BABY')) # æ ¹æ®å­—ç¬¦åç§°è¾“å‡ºå¯¹åº”å­—ç¬¦ print(lookup('BABY').encode()) # æŸ¥çœ‹è¯¥å­—ç¬¦çš„å­—èŠ‚ç¼–ç  LATIN CAPITAL LETTER A ğŸ‘¶ b'\\xf0\\x9f\\x91\\xb6' Mutation Operations ä¸€äº›å¯¹è±¡æ˜¯å¯ä»¥æ”¹å˜çš„ 1234567891011suits = ['coin', 'string', 'myriad'] original_suits = suits print(suits.pop()) # å¼¹å‡ºä¸€ä¸ªå…ƒç´ ï¼ˆé»˜è®¤æœ€åä¸€ä¸ªï¼‰ suits.remove('string') # ç§»é™¤æŒ‡å®šå…ƒç´  print(suits) suits.append('cup') # åœ¨å°¾éƒ¨å¢åŠ ä¸€ä¸ªå…ƒç´  suits.extend(['sword', 'club']) # æ·»åŠ åºåˆ—ä¸­çš„å¤šä¸ªå…ƒç´ æ¥æ‹“å±•åˆ—è¡¨ print(suits) suits[2] = 'spade' suits[0:2] = ['heart', 'diamond'] print(original_suits) myriad ['coin'] ['coin', 'cup', 'sword', 'club'] ['heart', 'diamond', 'spade', 'club'] æ ¹æ®ä»¥ä¸Šä»£ç å‘ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸€ä¸ªå¯¹è±¡ï¼ˆsuitsï¼‰è¿›è¡Œè‹¥å¹²æ“ä½œæ¥å˜åŒ–å…¶å€¼ è€Œæˆ‘ä»¬åœ¨æœ€åˆå°†suitsä¸original_suitsè¿›è¡Œç»‘å®šï¼Œæ•…å˜åŒ–ä¹Ÿä¼šåœ¨original_suitsä¸­ä½“ç° ç»¼ä¸Šï¼Œæ‰€æœ‰æŒ‡å‘ç›¸åŒå¯¹è±¡çš„nameséƒ½ä¼šå—åˆ°Mutationçš„å½±å“ï¼Œå…¶ä¸­è¿™é‡Œçš„mutationæŒ‡å¯¹è±¡å‘ç”Ÿçš„å˜åŒ– åªæœ‰å¯å˜ç±»å‹çš„å¯¹è±¡æ‰èƒ½æ›´æ”¹ï¼Œå¦‚åˆ—è¡¨ä¸å­—å…¸ å‡½æ•°è°ƒç”¨æ—¶å‘ç”Ÿçš„Mutation å‡½æ•°å¯ä»¥æ›´æ”¹å…¶ä½œç”¨åŸŸä¸­ä»»ä½•å¯å˜å¯¹è±¡çš„å€¼ 12345def mystery(s): s.pop() s.pop() four = [1,2,3,4] mystery(four) mysteryå‡½æ•°å®ç°äº†å¯¹åˆ—è¡¨å¯¹è±¡å€¼çš„æ›´æ”¹ï¼Œç”šè‡³mysteryä¸éœ€è¦ä¼ å…¥å‚æ•°ï¼Œç›´æ¥æ›´æ”¹å…¶æ‰€åœ¨ä½œç”¨åŸŸï¼ˆå…¨å±€ä½œç”¨åŸŸï¼‰ä¸­fouråˆ—è¡¨çš„å†…å®¹ è¡¨è¾¾å¼çš„Mutation è¡¨è¾¾å¼çš„å€¼ä¼šéšç€namesç»‘å®šå€¼æˆ–å¯¹è±¡çš„æ”¹å˜è€Œæ”¹å˜ 1234x = [1,2] print(x+x) x.append(3) print(x+x) [1, 2, 1, 2] [1, 2, 3, 1, 2, 3] Tuples å…ƒç»„æ˜¯ä¸€ç§ä¸å¯å˜çš„åºåˆ—ï¼Œä½¿ç”¨åœ†æ‹¬å·åŒ…è£¹èµ·æ¥ å®é™…ä¸Šï¼Œä»»ä½•ä»¥é€—å·éš”å¼€çš„å…ƒç´ éƒ½ä¼šè¢«è§£é‡Šæˆå…ƒç»„ï¼Œéå¿…é¡»åŠ åœ†æ‹¬å· ä½¿ç”¨tuple()åˆ›å»ºå…ƒç»„æˆ–å°†å…¶ä»–åºåˆ—è½¬åŒ–ä¸ºå…ƒç»„ åœ¨å•ä¸ªå…ƒç´ ååŠ ä¸€ä¸ªé€—å·å¯ä»¥å°†å•ä¸ªå…ƒç´ è½¬åŒ–æˆå…ƒç»„ å…ƒç»„å¯ä»¥ç›¸åŠ ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æˆå‘˜è¿ç®—ç¬¦inæ¥åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨ ç”±äºå…ƒç»„ä¸å¯å˜ï¼Œå¯ä»¥å°†å…¶ä½œä¸ºå­—å…¸çš„é”®ä½¿ç”¨ è‹¥å…ƒç»„ä¸­åŒ…å«äº†å¯å˜å¯¹è±¡ï¼Œåˆ™è¯¥å¯¹è±¡å¯ä»¥è¢«æ›´æ”¹ 123s = ([1,2],3) s[0][0]=4 print(s) ([4, 2], 3) Mutation ç›¸åŒä¸æ”¹å˜ 12345a = [10] b = a print(a==b) a.append(20) print(a==b) True True åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¯´aä¸bæ˜¯ç›¸åŒçš„ï¼Œå› ä¸ºbä¸aç»‘å®šåˆ°äº†åŒä¸€ä¸ªå¯¹è±¡ï¼Œå½“å¯¹å…¶ä¸­ä¸€ä¸ªå‘ç”Ÿå˜åŒ–ï¼Œå¦ä¸€ä¸ªä¹Ÿä¼šåŒæ—¶æ”¹å˜ 12345a = [10] b = [10] print(a==b) b.append(20) print(a==b) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œaä¸bæ˜¯ä¸åŒçš„ï¼Œå°½ç®¡å®ƒä»¬æ›¾æœ‰è¿‡ç›¸åŒçš„å†…å®¹ï¼Œä½†å¯¹bè¿›è¡Œæ”¹å˜åï¼Œaä¼šéšä¹‹æ”¹å˜ï¼Œå› æ­¤è¿™æ—¶äºŒè€…ä¾¿ä¸åŒäº† Identity Operators Identityï¼š &lt;exp0&gt; is &lt;exp1&gt; å½“ä¸¤ä¸ªè¡¨è¾¾å¼æŒ‡å‘ç›¸åŒå¯¹è±¡æ—¶è¿”å›True Equality &lt;exp0&gt; == &lt;exp1&gt; å½“ä¸¤ä¸ªè¡¨è¾¾å¼æ‹¥æœ‰ç›¸åŒå€¼æ—¶è¿”å›True ç›¸åŒå¯¹è±¡å§‹ç»ˆæ‹¥æœ‰ç›¸ç­‰çš„å€¼ï¼Œä½†åä¹‹ä¸ä¸€å®šæˆç«‹ 12345a = [10] b = [10] c = b print(a is b) print(b is c) False True å¯å˜å¯¹è±¡åœ¨å‡½æ•°ä¸­çš„é»˜è®¤å€¼ å‡½æ•°ä¸­å£°æ˜çš„é»˜è®¤å€¼æ˜¯å‡½æ•°å€¼çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯æ¯æ¬¡è°ƒç”¨æ—¶æ‰ç”Ÿæˆ è¿™å¯¼è‡´äº†è‹¥è¯¥å¯¹è±¡æ˜¯å¯å˜çš„ï¼Œè€Œä¸”åœ¨å‡½æ•°ä¸­é—´è¿›è¡Œäº†ä¿®æ”¹ï¼Œåˆ™è¯¥ä¿®æ”¹ä¼šåœ¨ä¸‹æ¬¡è°ƒç”¨å‡½æ•°æ—¶ä¿ç•™ å¦‚ä¸‹é¢çš„ä»£ç ï¼Œæ¯æ¬¡è°ƒç”¨å¢åŠ çš„å€¼ä¼šä¿ç•™åœ¨é»˜è®¤å€¼ä¸­ 12345def f(s=[]): s.append(3) return len(s) for i in range(3): print(f()) 1 2 3 Mutable Fuctions åœ¨å‡½æ•°ä¸­ä½¿ç”¨å¯å˜å¯¹è±¡å¯ä»¥åœ¨å¤šæ¬¡è°ƒç”¨æ—¶ä¿ç•™ä¸Šæ¬¡æ“ä½œçš„å€¼ 12345678910111213def make_withdraw_list(balance): b = [balance] def withdraw(amount): if amount &gt; b[0]: return 'Insufficient funds' b[0] = b[0] - amount return b[0] return withdraw withdraw = make_withdraw_list(100) print(withdraw(25)) print(withdraw(25)) withdraw(100) 75 50 'Insufficient funds' è¯¥å‡½æ•°å°†å­˜æ¬¾å­˜åœ¨ä½œä¸ºå¯å˜å¯¹è±¡çš„åˆ—è¡¨ä¸­ å‡½æ•°ä¸­çš„withdrawå‡½æ•°å§‹ç»ˆæŒ‡å‘åˆ—è¡¨bå¹¶ä¿®æ”¹å…¶å€¼ï¼Œè¯¥åˆ—è¡¨æ€»æ˜¯è¿™ä¸ªåˆ—è¡¨ï¼Œéšç€æ—¶é—´å…¶ä¸­çš„å†…å®¹è¢«æ›´æ”¹ ä¸ºäº†å®ç°æ¯æ¬¡æ›´æ”¹åˆ—è¡¨ä¸­çš„å€¼ï¼Œè¯¥å‡½æ•°ä½¿ç”¨äº†å¯å˜å¯¹è±¡æ¥åˆ›å»ºäº†ä¸€ä¸ªå¯å˜å‡½æ•°","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Trees","slug":"CS61Aâ€”â€”Trees","date":"2025-03-09T05:38:32.956Z","updated":"2025-03-09T05:39:18.214Z","comments":true,"path":"2025/03/09/CS61Aâ€”â€”Trees/","permalink":"https://izayoisakuye.github.io/2025/03/09/CS61A%E2%80%94%E2%80%94Trees/","excerpt":"","text":"Trees æè¿°æ ‘å½¢ç»“æ„çš„æœ¯è¯­ é€’å½’æè¿° - ä¸€è¯¾æ ‘æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹å’Œä¸€ç³»åˆ—åˆ†æ”¯èŠ‚ç‚¹ - æ¯ä¸ªåˆ†æ”¯ä¹Ÿæ˜¯ä¸€æ£µæ ‘ï¼Œä¹Ÿæœ‰æ ¹èŠ‚ç‚¹ä¸åˆ†æ”¯èŠ‚ç‚¹ - æ²¡æœ‰åˆ†æ”¯èŠ‚ç‚¹çš„æ ‘è¢«ç§°ä¸ºå¶å­èŠ‚ç‚¹ äº²æˆšæè¿° æ ‘çš„æ¯ä¸ªä½ç½®è¢«ç§°ä¸ºèŠ‚ç‚¹ æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥è¡¨ç¤ºä»»ä½•å€¼ ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥ç§°ä¸ºå¦ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹/å­èŠ‚ç‚¹ å®ç°æ ‘å½¢ç»“æ„çš„æŠ½è±¡ 12345678910111213141516171819202122232425262728293031def tree(label, branches=[]): for branch in branches: assert is_tree(branch), \"branches must be trees\" # ç¡®ä¿æ„é€ çš„æ˜¯ä¸€æ£µæ ‘ return [label] +list(branches) # å°†åŒä¸€å±‚çš„åˆ†æ”¯èŠ‚ç‚¹æ”¾åœ¨ä¸€ä¸ªåˆ—è¡¨ä¸­ def label(tree): return tree[0] def branches(tree): return tree[1:] def is_tree(tree): \"\"\"åˆ¤æ–­æ˜¯ä¸æ˜¯ä¸€æ£µæ ‘\"\"\" if type(tree) != list or len(tree) &lt;1: # ç¡®ä¿æ ‘çš„åˆ†æ”¯æ˜¯æ ‘ï¼Œä»¥åŠå­˜åœ¨ä¸€ä¸ªå€¼ return False for branch in branches(tree): # ç¡®ä¿æ ‘çš„åˆ†æ”¯çš„åˆ†æ”¯éƒ½æ˜¯æ ‘ if not is_tree(branch): return False return True def is_leaf(tree): \"\"\"åˆ¤æ–­æ ‘æœ¬èº«æ˜¯ä¸æ˜¯å¶å­èŠ‚ç‚¹\"\"\" return not branches(tree) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(t) print(label(t)) print(branches(t)) print(label(branches(t)[0])) [1, [5, [7]], [6]] 1 [[5, [7]], [6]] 5 Tree Processing å¤„ç†å¶å­èŠ‚ç‚¹ ä½¿ç”¨é€’å½’ï¼Œå°†ä¼šåœ¨æ¯ä¸ªåˆ†æ”¯èŠ‚ç‚¹è¿›è¡Œé€’å½’è°ƒç”¨ï¼Œæœ€ååˆå¹¶ 12345678910def count_leaves(t): \"\"\"Count the leaves of tree T\"\"\" if is_leaf(t): return 1 else: return sum([count_leaves(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(count_leaves(t)) 2 è¿”å›å¶å­èŠ‚ç‚¹çš„å€¼ å®ç°leaveså‡½æ•°ï¼Œè¿”å›æ ‘çš„å¶å­èŠ‚ç‚¹çš„å€¼çš„åˆ—è¡¨ 12345678910def leaves(tree): \"\"\"return a list containing the leaf labels of tree\"\"\" if is_leaf(tree): return [label(tree)] else: return sum([leaves(b) for b in branches(tree)], []) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) [7, 6] æ ¹æ®æ ‘åˆ›å»ºæ ‘ ä½¿ç”¨é€’å½’æ ¹æ®å¦ä¸€æ£µæ ‘åˆ›å»ºä¸€é¢—æ–°æ ‘ å¦‚è®©å¶å­èŠ‚ç‚¹å€¼+1çš„æ ‘ æˆ–è®©æ‰€æœ‰èŠ‚ç‚¹éƒ½+1çš„æ ‘ 1234567891011121314151617def increment_leaves(t): \"\"\"return a tree like t but with leaf labels incremented\"\"\" if is_leaf(t): return tree(label(t)+1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t), bs) def increment(t): \"\"\"return a tree like t but with all labels incremented\"\"\" return tree(label(t)+1, [increment(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) print(increment_leaves(t)) print(increment(t)) [7, 6] [1, [5, [8]], [7]] [2, [6, [8]], [7]] ä¾‹ï¼šprint_tree æŒ‰èŠ‚ç‚¹åœ¨æ ‘ä¸­çš„æ·±åº¦ç¼©è¿›æ‰“å°ä¸€é¢—æ ‘ 12345678def print_tree(t, indent = 0): print(' '*indent + str(label(t))) for b in branches(t): print_tree(b, indent+1) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_tree(t)) 1 5 7 6 None ä¾‹ï¼š æ±‚ä»æ ¹èŠ‚ç‚¹æ²¿è·¯å¾„åˆ°å¶å­èŠ‚ç‚¹æ±‚å’Œå¹¶æ‰“å° 1234567891011def print_sums(t, so_far): so_far = so_far +label(t) if is_leaf(t): print(so_far) else: for b in branches(t): print_sums(b,so_far) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_sums(t, 0)) 13 7 None 1","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Lab4","slug":"CS61Aâ€”â€”Lab4","date":"2025-03-06T09:57:15.925Z","updated":"2025-03-06T09:57:37.807Z","comments":true,"path":"2025/03/06/CS61Aâ€”â€”Lab4/","permalink":"https://izayoisakuye.github.io/2025/03/06/CS61A%E2%80%94%E2%80%94Lab4/","excerpt":"","text":"Dictionaries éƒ¨åˆ†è·³è¿‡ Divide ä¼ å…¥ä¸€ç»„å•†æ•°ä¸ä¸€ç»„é™¤æ•°ï¼Œè¿”å›å­—å…¸ï¼Œé”®ä¸ºæ¯ä¸ªå•†æ•°ï¼Œå€¼ä¸ºè¡¨ç¤ºæ¯ä¸ªå•†æ•°èƒ½æ•´é™¤çš„é™¤æ•°çš„åˆ—è¡¨ 12345678910def divide(quotients, divisors): \"\"\"Return a dictonary in which each quotient q is a key for the list of divisors that it divides evenly. &gt;&gt;&gt; divide([3, 4, 5], [8, 9, 10, 11, 12]) {3: [9, 12], 4: [8, 12], 5: [10]} &gt;&gt;&gt; divide(range(1, 5), range(20, 25)) {1: [20, 21, 22, 23, 24], 2: [20, 22, 24], 3: [21, 24], 4: [20, 24]} \"\"\" return {i: [x for x in divisors if x%i==0] for i in quotients} æ³¨æ„ç”¨è¡¨è¾¾å¼å»ºç«‹åˆ—è¡¨ä¸å­—å…¸çš„æ–¹æ³• Buying Fruit å®ç°buyå‡½æ•°ï¼Œé€šè¿‡ç»™å®šçš„æ°´æœä¸ä»·æ ¼ï¼Œç”¨æ°å¥½ä¸ºä¼ å…¥çš„total_amountçš„ä»·æ ¼è´­ä¹°æŒ‡å®šçš„æ°´æœï¼ˆæ¯ç§æŒ‡å®šæ°´æœè‡³å°‘ä¹°ä¸€æ¬¡ï¼‰ ç”¨displayå‡½æ•°è¾“å‡ºæ‰€æœ‰ç»“æœ 123456789101112131415161718192021222324252627282930313233343536def buy(required_fruits, prices, total_amount): \"\"\"Print ways to buy some of each fruit so that the sum of prices is amount. &gt;&gt;&gt; prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9} &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 12) [2 apples][1 orange][1 banana] &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 16) [2 apples][1 orange][3 bananas] [2 apples][2 oranges][1 banana] &gt;&gt;&gt; buy(['apples', 'kiwis'], prices, 36) [3 apples][3 kiwis] [6 apples][2 kiwis] [9 apples][1 kiwi] \"\"\" def add(fruits, amount, cart): if fruits == [] and amount == 0: print(cart) elif fruits and amount &gt; 0: fruit = fruits[0] price = prices[fruit] for k in range(1,amount//price+1): add(fruits[1:], amount-k*price, cart+display(fruit,k)) add(required_fruits, total_amount, '') def display(fruit, count): \"\"\"Display a count of a fruit in square brackets. &gt;&gt;&gt; display('apples', 3) '[3 apples]' &gt;&gt;&gt; display('apples', 1) '[1 apple]' \"\"\" assert count &gt;= 1 and fruit[-1] == 's' if count == 1: fruit = fruit[:-1] # get rid of the plural s return '[' + str(count) + ' ' + fruit + ']' è¿”å›æ¡ä»¶æ˜¯fruitsä¸ºç©ºæˆ–é’±è¢«èŠ±å…‰ï¼Œä¸”é€’å½’æ—¶æ¯æ¬¡éƒ½å–fruitsçš„é¦–ä¸ªå…ƒç´  å¯ä»¥æ¨æ–­é€’å½’æ—¶å¯¹fruitsæ•°ç»„è¿›è¡Œäº†åˆ‡ç‰‡ï¼Œæ¯æ¬¡å¾€ååˆ‡ä¸€ä¸ªå…ƒç´  forå¾ªç¯éå†é€‰æ‹©æ¯ä¸ªæ°´æœçš„ä¸ªæ•°ï¼Œä»è‡³å°‘é€‰ä¸€ä¸ªåˆ°æœ€å¤šèƒ½é€‰çš„ä¸ªæ•° é€’å½’æ—¶ä¼ å…¥æ€»ä»·æ ¼å‡å»å·²ç»ä½¿ç”¨çš„ä»·æ ¼æ•°çš„ä¸åŒæƒ…å†µï¼Œå¹¶ä½¿ç”¨displayå‡½æ•°è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥æ¥æ˜¾ç¤º Cities ADT ä»¥ä¸‹é—®é¢˜åŸºäºå»ºç«‹çš„è¯¥ADT ä¸€ä¸ªåŸå¸‚ç”±ä»¥ä¸‹å‚æ•°æè¿°ï¼šåç§°ã€ç»åº¦ã€ç»´åº¦ åŒ…æ‹¬ä¸€ä¸ªæ„é€ å‡½æ•° - make_city(name, lat, lon)ï¼šå»ºç«‹ä¸€ä¸ªåŸå¸‚å¯¹è±¡ï¼Œå­˜å‚¨å…¶åç§°ã€ç»åº¦ã€ç»´åº¦ ä»¥ä¸‹é€‰æ‹©å™¨ - get_name(city)ï¼šè·å–åŸå¸‚åç§° - get_lat(city)ï¼šè·å–åŸå¸‚ç»åº¦ - get_lon(city)ï¼šè·å–åŸå¸‚ç»´åº¦ è¯¥æŠ½è±¡æ•°æ®ç±»å‹å·²ç»åœ¨æ–‡ä»¶ä¸­å®ç°ï¼Œä½ ä¸éœ€è¦çŸ¥é“æ˜¯æ€ä¹ˆå®ç°çš„ Distance è®¡ç®—å¹¶è¿”å›ä¸¤åŸå¸‚çš„è·ç¦» 12345678910111213from math import sqrt def distance(city_a, city_b): \"\"\" &gt;&gt;&gt; city_a = make_city('city_a', 0, 1) &gt;&gt;&gt; city_b = make_city('city_b', 0, 2) &gt;&gt;&gt; distance(city_a, city_b) 1.0 &gt;&gt;&gt; city_c = make_city('city_c', 6.5, 12) &gt;&gt;&gt; city_d = make_city('city_d', 2.5, 15) &gt;&gt;&gt; distance(city_c, city_d) 5.0 \"\"\" return sqrt(abs(get_lat(city_a)-get_lat(city_b))**2+abs(get_lon(city_a)-get_lon(city_b))**2) Closer City æ¯”è¾ƒä¸¤ä¸ªåŸå¸‚ç¦»ç»™å®šç»çº¬åº¦çš„è¿œè¿‘ï¼Œè¿”å›æ›´è¿‘çš„é‚£ä¸ªåŸå¸‚ 1234567891011121314151617181920def closer_city(lat, lon, city_a, city_b): \"\"\" Returns the name of either city_a or city_b, whichever is closest to coordinate (lat, lon). If the two cities are the same distance away from the coordinate, consider city_b to be the closer city. &gt;&gt;&gt; berkeley = make_city('Berkeley', 37.87, 112.26) &gt;&gt;&gt; stanford = make_city('Stanford', 34.05, 118.25) &gt;&gt;&gt; closer_city(38.33, 121.44, berkeley, stanford) 'Stanford' &gt;&gt;&gt; bucharest = make_city('Bucharest', 44.43, 26.10) &gt;&gt;&gt; vienna = make_city('Vienna', 48.20, 16.37) &gt;&gt;&gt; closer_city(41.29, 174.78, bucharest, vienna) 'Bucharest' \"\"\" fake_city = make_city('fake', lat, lon) if distance(fake_city,city_a)&lt;distance(fake_city,city_b): return get_name(city_a) else: return get_name(city_b) å¯ä»¥å°†æŒ‡å®šçš„ç»çº¬åº¦çœ‹ä½œç¬¬ä¸‰ä¸ªåŸå¸‚å¹¶æ„é€ è¿™ä¹ˆä¸€ä¸ªå¯¹è±¡ é€šè¿‡ä¸Šé¢å·²ç»å†™å®Œçš„distanceå‡½æ•°è®¡ç®—ä¸¤åŸå¸‚ä¸ç¬¬ä¸‰ä¸ªåŸå¸‚çš„è·ç¦»å¹¶æ¯”è¾ƒï¼Œè¾“å‡ºæ›´è¿‘çš„ è‹¥ç›¸åŒè¾“å‡ºcity_b","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Data Abstraction","slug":"CS61Aâ€”â€”Data Abstraction","date":"2025-03-03T12:52:03.826Z","updated":"2025-03-03T13:06:05.083Z","comments":true,"path":"2025/03/03/CS61Aâ€”â€”Data Abstraction/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Data%20Abstraction/","excerpt":"","text":"Data Abstraction Data Abstraction å¤§å¤šæ•°å€¼éƒ½æ˜¯å¤åˆå€¼ï¼Œç”±å¤šç§å¯¹è±¡ç»„æˆ æŠ½è±¡æ•°æ®ç±»å‹å¯ä»¥è®©æˆ‘ä»¬å°†ç¬¦åˆå¯¹è±¡ä½œä¸ºä¸€ä¸ªå•å…ƒæ“ä½œï¼Œå…è®¸æˆ‘ä»¬éš”ç¦»ä½¿ç”¨æ•°æ®çš„ç¨‹åºçš„ä¸¤ä¸ªéƒ¨åˆ†ï¼š æ•°æ®çš„è¡¨ç¤º æ•°æ®çš„æ“ä½œ å³åœ¨æ•°æ®çš„è¡¨ç¤ºä¸æ“ä½œä¹‹é—´å»ºç«‹ä¸€ä¸ªæŠ½è±¡å±éšœ Exampleâ€”â€”Rational Numbers è¡¨ç¤º ä»»ä½•æœ‰ç†æ•°å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªæœ€ç®€åˆ†æ•° è¿™ä¸ºå°æ•°æä¾›äº†æ›´ç²¾ç¡®çš„è¡¨ç¤ºæ–¹æ³• æ•…æˆ‘ä»¬éœ€è¦åˆ†å¼€åˆ†å­åˆ†æ¯ï¼Œä½œä¸ºä¸€ä¸ªå¤åˆæ•°æ®ç±»å‹ï¼š rational(n,d)è¿”å›ä¸€ä¸ªæœ‰ç†æ•°x numer(x)è¿”å›æœ‰ç†æ•°xçš„åˆ†å­ denom(x)è¿”å›æœ‰ç†æ•°çš„åˆ†æ¯ ç¬¬ä¸€ä¸ªå‡½æ•°ç§°ä¸ºæ„é€ å‡½æ•°ï¼ˆconstructorï¼‰ï¼Œå®ƒç”¨äºæ„é€ ä¸€ä¸ªæ–°å€¼ä½œä¸ºæŠ½è±¡æ•°æ®ç±»å‹çš„å®ä¾‹ï¼ˆinstanceï¼‰ ç¬¬äºŒã€ä¸‰ä¸ªå‡½æ•°ç§°ä¸ºé€‰æ‹©å™¨ï¼ˆselectorsï¼‰ï¼Œå®ƒä»¬è¿”å›å¾—åˆ°çš„æœ‰ç†æ•°çš„æ•´æ•°éƒ¨åˆ† è¿™ä¸‰ä¸ªå‡½æ•°ä½œä¸ºæœ‰ç†æ•°çš„æŠ½è±¡æ•°æ®ç±»å‹ä½¿ç”¨ï¼Œç”¨å®ƒä»¬è¿›è¡Œæ•°å­—æ“ä½œ ç®—æœ¯ æ ¹æ®å°å­¦äºŒå¹´çº§çŸ¥è¯†ï¼Œæˆ‘ä»¬æ ¹æ®åˆ†æ•°æ¥æ‰§è¡Œæœ‰ç†æ•°åŠ ä¹˜ï¼Œå…¬å¼å¦‚ä¸‹ æœ‰ç†æ•°ç®—æœ¯ 12345678910def mul_rational(x,y): return rational(numer(x)*numer(y),denom(x)*denom(y)) def add_rational(x,y): nx, dx = numer(x), denom(y) ny, dy = numer(y), denom(y) return rational(nx*dy+ny*dx, dx*dy) def equal_rational(x,y): return numer(x)*denom(y)==numer(y)*denom(x) Abstraction Barriers æ‹¿ä¸Šæ–¹çš„æœ‰ç†æ•°å‡½æ•°ä½œä¸ºä¾‹å­ æŠ½è±¡å±éšœ æŠ½è±¡å±éšœè¡¨ç¤ºä½¿ç”¨ç”±æœ‰ç†æ•°è®¡ç®—æ—¶ä½¿ç”¨çš„å‡½æ•°åªèƒ½æ˜¯å¯¹åº”ç›¸å…³çš„ï¼Œè€Œä¸èƒ½è¶Šç•Œè¡¨ç¤º ç”¨æœ‰ç†æ•°è®¡ç®—æ—¶åªéœ€è¦ä½¿ç”¨è®¡ç®—ç›¸å…³å‡½æ•° ç”¨æ¥è¡¨ç¤ºæœ‰ç†æ•°å’Œè¿›è¡Œæ“ä½œæ—¶åªéœ€è¦ä½¿ç”¨å¯¹åº”æ„é€ å‡½æ•°ä¸é€‰æ‹©å™¨ ç”¨æ¥æ„å»ºæ„é€ å‡½æ•°ä¸é€‰æ‹©å™¨æ—¶éœ€è¦ç”¨åˆ°åˆ—è¡¨ä¸å…ƒç´ é€‰æ‹© ä¸€ç§è·¨è¶Šäº†æŠ½è±¡å±éšœçš„åä¾‹ï¼š 1234add_rational([1,2],[1,4]) def divide_rational(x,y): return [x[0]*y[1], x[1]*y[0]] Pair åˆ›å»ºä¸è®¿é—® é€šå¸¸ä½¿ç”¨åˆ—è¡¨è¡¨ç¤ºä¸€ä¸ªpair 123&gt;&gt;&gt; pair = [1,2] &gt;&gt;&gt; pair [1,2] é€šè¿‡åºåˆ—è§£åŒ…æˆ–åˆ—è¡¨ä¸‹æ ‡è·å¾—pairä¸­çš„ä¸¤ä¸ªå€¼ 1234567&gt;&gt;&gt; x,y=pair &gt;&gt;&gt; x 1 &gt;&gt;&gt; y 2 &gt;&gt;&gt; pair[0] 1 è¿˜å¯ä»¥ç”¨getitemå‡½æ•°è·å¾—å€¼ï¼Œåœ¨operatoråº“ä¸­ ç”¨æ³•ï¼šgetitem(&lt;list&gt;, &lt;index&gt;) 1234&gt;&gt;&gt; getitem(pair, 0) 1 &gt;&gt;&gt; getitem(pair, 1) 2 ç”¨pairè¡¨ç¤ºæœ‰ç†æ•° 123def rational(n,d): \"\"\"Construct a rational number that represents N/D\"\"\" return [n, d] è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œè®°å½•åˆ†å­åˆ†æ¯ç”¨æ¥è¡¨ç¤ºæœ‰ç†æ•° 1234567def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x[0] def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x[1] é€šè¿‡è®¿é—®åˆ—è¡¨ä¸­çš„å…ƒç´ è¿”å›åˆ†å­åˆ†æ¯ åº”ç”¨ åˆ†æ•°é€šåˆ† æœ‰ç†æ•°çš„åˆ†å­åˆ†æ¯åº”äº’è´¨ï¼Œæ•…æˆ‘ä»¬å¯ä»¥ç”¨gcdè·å–å®ƒä»¬çš„æœ€å¤§å…¬å› æ•°æ¥åŒæ—¶é™¤ä»¥åˆ†å­åˆ†æ¯ä»¥ç¡®ä¿è·å¾—äº’è´¨çš„åˆ†å­åˆ†æ¯ 1234from fractions import gcd def rational(n,d): g = gcd(n,d) return [n//g, d//g] Data Representation æ•°æ®æŠ½è±¡çš„åŸºæœ¬æ€æƒ³ï¼šé€šè¿‡å®ƒçš„è¡Œä¸ºæ¥è¯†åˆ«è¯¥æŠ½è±¡æ•°æ®ç±»å‹ æ”¹å˜æœ‰ç†æ•°çš„è¡¨ç°å½¢å¼ 1234567891011121314def rational(n,d): def select(name): if name == 'n': return n elif name == 'd': return d return select def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x('n') def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x('d') è¿™é‡Œä½¿xæˆä¸ºä¸€ä¸ªå‡½æ•°ï¼Œè¿™æ ·å°±å¯ä»¥ä¸éœ€è¦å†…ç½®çš„åˆ—è¡¨æ•°æ®ç±»å‹äº† æ­¤æ—¶rationalæ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªè¡¨ç¤ºæœ‰ç†æ•°çš„å‡½æ•°","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Lab3","slug":"CS61Aâ€”â€”Lab3","date":"2025-03-03T12:51:43.540Z","updated":"2025-03-03T13:04:15.175Z","comments":true,"path":"2025/03/03/CS61Aâ€”â€”Lab3/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Lab3/","excerpt":"","text":"WWPDéƒ¨åˆ†çœç•¥ Print If è¿”å›åˆ—è¡¨ä¸­æ»¡è¶³å‡½æ•°fçš„å…ƒç´  12345678910111213141516def print_if(s, f): \"\"\"Print each element of s for which f returns a true value. &gt;&gt;&gt; print_if([3, 4, 5, 6], lambda x: x &gt; 4) 5 6 &gt;&gt;&gt; result = print_if([3, 4, 5, 6], lambda x: x % 2 == 0) 4 6 &gt;&gt;&gt; print(result) # print_if should return None None \"\"\" for x in s: if f(x): print(x) return None Close è¿”å›åˆ—è¡¨ä¸­å…ƒç´ å¤§å°ä¸ä¸‹æ ‡å·®çš„ç»å¯¹å€¼å°äºè§„å®šå€¼çš„å…ƒç´ ä¸ªæ•° 123456789101112131415161718def close(s, k): \"\"\"Return how many elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close(t, 0) # Only 3 is equal to its index 1 &gt;&gt;&gt; close(t, 1) # 2, 3, and 5 are within 1 of their index 3 &gt;&gt;&gt; close(t, 2) # 2, 3, 4, and 5 are all within 2 of their index 4 &gt;&gt;&gt; close(list(range(10)), 0) 10 \"\"\" count = 0 for i in range(len(s)): # Use a range to loop over indices if abs(s[i]-i)&lt;=k : count+=1 return count Close List è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œå…ƒç´ ä¸ºç»™å®šåˆ—è¡¨ä¸­å…ƒç´ å¤§å°ä¸ä¸‹æ ‡å·®çš„ç»å¯¹å€¼å°äºè§„å®šå€¼çš„å…ƒç´  123456789101112def close_list(s, k): \"\"\"Return a list of the elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close_list(t, 0) # Only 3 is equal to its index [3] &gt;&gt;&gt; close_list(t, 1) # 2, 3, and 5 are within 1 of their index [2, 3, 5] &gt;&gt;&gt; close_list(t, 2) # 2, 3, 4, and 5 are all within 2 of their index [2, 4, 3, 5] \"\"\" return [s[i] for i in range(len(s)) if s[i]-i&lt;=k] Squares Only è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œå…ƒç´ ä¸ºç»™å®šåˆ—è¡¨ä¸­ä¸ºå®Œå…¨å¹³æ–¹æ•°çš„å…ƒç´  1234567891011121314from math import sqrt def squares(s): \"\"\"Returns a new list containing square roots of the elements of the original list that are perfect squares. &gt;&gt;&gt; seq = [8, 49, 8, 9, 2, 1, 100, 102] &gt;&gt;&gt; squares(seq) [7, 3, 1, 10] &gt;&gt;&gt; seq = [500, 30] &gt;&gt;&gt; squares(seq) [] \"\"\" return [int(sqrt(n)) for n in s if sqrt(n)==round(sqrt(n))] æ³¨æ„è¿”å›çš„æ˜¯å¼€æ–¹åçš„æ•°ï¼Œæ˜¯æ•´æ•° Double Eights ä½¿ç”¨é€’å½’åˆ¤æ–­ç»™å®šçš„æ•°ä¸­æ˜¯å¦å­˜åœ¨ç›¸é‚»çš„ä¸¤ä¸ª8 123456789101112131415161718192021222324252627def double_eights(n): \"\"\" Returns whether or not n has two digits in row that are the number 8. Assume n has at least two digits in it. &gt;&gt;&gt; double_eights(1288) True &gt;&gt;&gt; double_eights(880) True &gt;&gt;&gt; double_eights(538835) True &gt;&gt;&gt; double_eights(284682) False &gt;&gt;&gt; double_eights(588138) True &gt;&gt;&gt; double_eights(78) False &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(LAB_SOURCE_FILE, 'double_eights', ['While', 'For']) True \"\"\" if n==0: return False if n%100==88: return True else: return double_eights(n//10) Making Onions åˆ¤æ–­æ˜¯å¦èƒ½é€šè¿‡få‡½æ•°ä¸gå‡½æ•°è¿›è¡Œè‡³å¤šlimitæ¬¡æ“ä½œå®ç°å°†xè½¬åŒ–ä¸ºy 1234567891011121314151617181920212223242526272829303132def make_onion(f, g): \"\"\"Return a function can_reach(x, y, limit) that returns whether some call expression containing only f, g, and x with up to limit calls will give the result y. &gt;&gt;&gt; up = lambda x: x + 1 &gt;&gt;&gt; double = lambda y: y * 2 &gt;&gt;&gt; can_reach = make_onion(up, double) &gt;&gt;&gt; can_reach(5, 25, 4) # 25 = up(double(double(up(5)))) True &gt;&gt;&gt; can_reach(5, 25, 3) # Not possible False &gt;&gt;&gt; can_reach(1, 1, 0) # 1 = 1 True &gt;&gt;&gt; add_ing = lambda x: x + \"ing\" &gt;&gt;&gt; add_end = lambda y: y + \"end\" &gt;&gt;&gt; can_reach_string = make_onion(add_ing, add_end) &gt;&gt;&gt; can_reach_string(\"cry\", \"crying\", 1) # \"crying\" = add_ing(\"cry\") True &gt;&gt;&gt; can_reach_string(\"un\", \"unending\", 3) # \"unending\" = add_ing(add_end(\"un\")) True &gt;&gt;&gt; can_reach_string(\"peach\", \"folding\", 4) # Not possible False \"\"\" def can_reach(x, y, limit): if limit &lt; 0: return False elif x == y: return True else: return can_reach(f(x), y, limit - 1) or can_reach(g(x), y, limit - 1) return can_reach","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€ç®—æ³•ã€‘BFS","slug":"BFS","date":"2025-03-01T03:30:53.100Z","updated":"2025-03-01T03:31:12.066Z","comments":true,"path":"2025/03/01/BFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/BFS/","excerpt":"","text":"BFS å‚è€ƒè§†é¢‘1_ å‚è€ƒè§†é¢‘2 é¢„å¤‡çŸ¥è¯†ï¼šé˜Ÿåˆ— ç‰¹ç‚¹ï¼šå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ï¼Œé˜Ÿå¤´åˆ é™¤å…ƒç´ ï¼Œé˜Ÿå°¾æ’å…¥å…ƒç´  åŸºæœ¬ç”¨æ³•ï¼šè§æ–‡ä»¶ å¯¹äºbfsï¼Œæˆ‘ä»¬éœ€è¦ä¸€å±‚ä¸€å±‚éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œé‚£ä¹ˆç›¸é‚»èŠ‚ç‚¹çš„è®¿é—®é¡ºåºè¯¥å¦‚ä½•ç¡®å®šï¼Ÿå› æ­¤æˆ‘ä»¬éœ€è¦é˜Ÿåˆ—å»å­˜å‚¨å’Œæ“ä½œï¼Œéœ€è¦ä½¿å…ˆéå†åˆ°çš„ç»“ç‚¹å…ˆè¢«å­˜å‚¨ï¼Œç›´åˆ°å½“å‰å±‚éƒ½è¢«å­˜å‚¨ä¹‹åï¼ŒæŒ‰å­˜å‚¨çš„å…ˆåé¡ºåºï¼Œå…ˆè¢«å­˜å‚¨çš„èŠ‚ç‚¹ä¹Ÿä¼šå…ˆè¢«å–å‡ºï¼Œç»§ç»­éå†å­èŠ‚ç‚¹ã€‚ç¬¦åˆé˜Ÿåˆ—çš„FIFOç‰¹ç‚¹ åŸºæœ¬æ€æƒ³ è§£å†³é—®é¢˜ ä»Aå‡ºå‘æ˜¯å¦å­˜åœ¨åˆ°è¾¾Bçš„è·¯å¾„ï¼ˆDFSä¹Ÿè¡Œï¼‰ ä»Aå‡ºå‘åˆ°è¾¾Bçš„æœ€çŸ­è·¯å¾„ï¼ˆDFS+å‰ªæä¹Ÿè¡Œï¼Œå®¹æ˜“TLEï¼‰ åŸºæœ¬æ€æƒ³ ä»åˆå§‹çŠ¶æ€sï¼ˆå›¾ä¸ŠæŸä¸ªèŠ‚ç‚¹å‡ºå‘ï¼‰å¼€å§‹åˆ©ç”¨è§„å¾‹ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çŠ¶æ€ï¼Œæ„æˆæ ‘çš„ä¸‹ä¸€å±‚èŠ‚ç‚¹ æ£€æŸ¥æ˜¯å¦å‡ºç°ç›®æ ‡çŠ¶æ€gï¼Œè‹¥æœªå‡ºç°åˆ™å¯¹è¯¥å±‚æ‰€æœ‰çŠ¶æ€èŠ‚ç‚¹åˆ†åˆ«åˆ©ç”¨è§„åˆ™ï¼Œç”Ÿæˆåœ¨ä¸‹ä¸€å±‚çš„æ‰€æœ‰çŠ¶æ€èŠ‚ç‚¹ å¯¹æ–°ä¸€å±‚ç»§ç»­æ£€æŸ¥é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°å‡ºç°ç›®æ ‡çŠ¶æ€ æ³¨æ„ï¼šBFSå®é™…ä¸Šæ˜¯ä¼ å›ç»è¿‡è¾¹æ•°æœ€å°‘çš„è§£ï¼Œå› æ­¤å¯¹äºæ‰€æœ‰è¾¹é•¿åº¦ï¼ˆè¾¹æƒï¼‰ç›¸åŒçš„æƒ…å†µï¼Œæ­¤æ—¶å°±ä¸€å®šæ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹æœ€çŸ­çš„è·¯å¾„ï¼ŒBFSå…ˆæ‰¾åˆ°çš„å°±ä¸€å®šæ˜¯æœ€çŸ­çš„ï¼Œä½†å¦‚æœæ˜¯åŠ æƒè¾¹ï¼ŒBFSä¼ å›çš„å°±ä¸ä¸€å®šæœ€çŸ­äº†ã€‚å¯¹äºåŠ æƒè·¯å¾„çš„æœ€çŸ­è·¯ï¼Œæˆ‘ä»¬ä½¿ç”¨Dijkstraç®—æ³•æ±‚è§£ã€‚ åŸºæœ¬æ­¥éª¤ èµ·å§‹ï¼šå°†èµ·ç‚¹ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰æ”¾å…¥é˜Ÿåˆ—ä¸­ æ‰©æ•£ï¼šä»é˜Ÿåˆ—ä¸­å–å‡ºé˜Ÿå¤´ç»“ç‚¹ï¼Œå°†å…¶ç›¸é‚»èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ï¼Œä¸æ–­é‡å¤ ç»ˆæ­¢ï¼šå½“é˜Ÿåˆ—ä¸ºç©ºæ˜¯ï¼Œè¯´æ˜éå†å®Œäº†æ‰€æœ‰èŠ‚ç‚¹ ç©ºé—´å¤æ‚åº¦ ï¼šbä¸ºæœ€å¤§åˆ†æ”¯ç³»æ•°ï¼Œnä¸ºæ ‘é«˜ æ¿å­ 1234567891011121314151617Node bfs(node source, node target){ memset(visit, 0 , sizeof(visit)); queue&lt;node&gt; q; q.push(source); visit[source] = 1; while(!q.empty()){ Node a = q.front(); q.pop(); if (a==target) return a; for (/*å¯¹äºaæ‰€æœ‰çš„åç»§èŠ‚ç‚¹b*/){ if (visit[b]) continue; q.push(b); visit[b]=1; // å‰ªæ,ä¿è¯èŠ‚ç‚¹åªè¿›é˜Ÿåˆ—ä¸€æ¬¡ } return NULL; } } ä¾‹ï¼šäºŒå‰æ ‘çš„å±‚æ¬¡éå†-queueçš„å®ç°è§£é‡Š å±‚æ¬¡éå†ï¼šä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³è¿›è¡Œéå† æ€æƒ³ ç»´æŠ¤é˜Ÿåˆ—ï¼Œç”¨äºå­˜æ”¾èŠ‚ç‚¹ä¿¡æ¯ï¼Œå½“è®¿é—®åˆ°ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå…ˆè®¿é—®è¯¥èŠ‚ç‚¹ï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹çš„å·¦å³å„¿å­åˆ†åˆ«å…¥é˜Ÿåˆ— ä¼ªä»£ç  12345678910bfs(int root){ queue&lt;int&gt; q; q.push(root); while qä¸ä¸ºç©ºï¼š è·å¾—é˜Ÿé¦–å…ƒç´  é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿ è¾“å‡ºå½“å‰èŠ‚ç‚¹å€¼ if è¯¥èŠ‚ç‚¹å·¦å„¿å­ä¸ä¸ºç©ºï¼šå°†å·¦å„¿å­åŠ å…¥é˜Ÿåˆ— else if è¯¥èŠ‚ç‚¹å³å„¿å­ä¸ä¸ºç©ºï¼šå°†å³å„¿å­åŠ å…¥é˜Ÿåˆ— } ä¾‹ï¼šå¯¹äºä¸€ä¸ªå±‚æ¬¡éå†ï¼š5172463çš„æ ‘ â€‹ é˜Ÿåˆ—qï¼š â€‹ æ”¾å…¥rootèŠ‚ç‚¹ï¼šqï¼š5 â€‹ é˜Ÿåˆ—ç©ºå¦ï¼Ÿ ä¸ç©ºï¼Œè¾“å‡º5å¹¶åˆ é™¤ï¼Œqï¼š â€‹ æœ‰å­©å­å¦ï¼Ÿæœ‰ï¼Œæ”¾å…¥5çš„å·¦å³å­©å­1 7ï¼Œqï¼š1 7 â€‹ é˜Ÿåˆ—ç©ºå¦ï¼Ÿ ä¸ç©ºï¼Œè¾“å‡º1å¹¶åˆ é™¤ï¼Œqï¼š7 â€‹ æœ‰å­©å­å¦ï¼Ÿæœ‰ï¼Œæ”¾å…¥1çš„å·¦å³å­©å­2 4ï¼Œqï¼š7 2 4 â€‹ é˜Ÿåˆ—ç©ºå¦ï¼Ÿ ä¸ç©ºï¼Œè¾“å‡º7å¹¶åˆ é™¤ï¼Œqï¼š2 4 â€‹ æœ‰å­©å­å¦ï¼Ÿæœ‰ï¼Œæ”¾å…¥7çš„å·¦å³å­©å­6 3ï¼Œqï¼š2 4 6 3 â€‹ é˜Ÿåˆ—ç©ºå¦ï¼Ÿ ä¸ç©ºï¼Œè¾“å‡º2å¹¶åˆ é™¤ï¼Œqï¼š4 6 3 â€‹ æœ‰å­©å­å¦ï¼Ÿæ— ï¼Œç»§ç»­ï¼Œqï¼š4 6 3 â€‹ å‰©ä¸‹ä¸‰ä¸ªç›¸åŒ qï¼š6 3 qï¼š6 qï¼š â€‹ ä¾‹ï¼šå›¾çš„bfs image-20241112203528097 å›¾ä¸æ ‘ç±»ä¼¼ï¼Œä½†å›¾ä»»ä½•ä¸¤ç‚¹é—´éƒ½å¯ä»¥æœ‰è¾¹ï¼Œæ•…æ–¹æ³•ç›¸ä¼¼ ä½†å›¾æ²¡æœ‰å±‚æ¬¡å…³ç³»ï¼Œè®¿é—®çš„æ˜¯æŸç‚¹çš„é‚»æ¥ç‚¹ï¼Œè‹¥ä¸€ä¸ªç‚¹å·²ç»è®¿é—®è¿‡å°±æ²¡å¿…è¦åœ¨è®¿é—®äº†ï¼šå¦‚Bçš„é‚»æ¥ç‚¹AECï¼Œè‹¥æƒ³è¦æ”¾è¿›å»å­èŠ‚ç‚¹ï¼Œåˆ™AEæ²¡æœ‰å¿…è¦å†å…¥é˜Ÿåˆ— æ­¥éª¤ï¼šæ”¾å…¥èµ·å§‹èŠ‚ç‚¹ï¼Œå¾ªç¯åˆ¤æ–­é˜Ÿåˆ—ç©ºä¸ç©ºï¼Œè‹¥ä¸ç©ºåˆ™æ”¾å…¥ç›¸é‚»èŠ‚ç‚¹ BFSæœ€é€‚åˆçš„ï¼šå¯»æ‰¾æœ€å°‘å‡ æ­¥èƒ½è¾¾åˆ°ç›®æ ‡ï¼ˆç‰¹æ®Šçš„æœ€çŸ­è·¯é—®é¢˜ï¼‰ ä¾‹ï¼šå¥‡æ€ªçš„ç”µæ¢¯ å¥‡æ€ªçš„ç”µæ¢¯ é¢˜ç›®æè¿° å‘µå‘µï¼Œæœ‰ä¸€å¤©æˆ‘åšäº†ä¸€ä¸ªæ¢¦ï¼Œæ¢¦è§äº†ä¸€ç§å¾ˆå¥‡æ€ªçš„ç”µæ¢¯ã€‚å¤§æ¥¼çš„æ¯ä¸€å±‚æ¥¼éƒ½å¯ä»¥åœç”µæ¢¯ï¼Œè€Œä¸”ç¬¬ å±‚æ¥¼ï¼ˆï¼‰ä¸Šæœ‰ä¸€ä¸ªæ•°å­— ï¼ˆï¼‰ã€‚ç”µæ¢¯åªæœ‰å››ä¸ªæŒ‰é’®ï¼šå¼€ï¼Œå…³ï¼Œä¸Šï¼Œä¸‹ã€‚ä¸Šä¸‹çš„å±‚æ•°ç­‰äºå½“å‰æ¥¼å±‚ä¸Šçš„é‚£ä¸ªæ•°å­—ã€‚å½“ç„¶ï¼Œå¦‚æœä¸èƒ½æ»¡è¶³è¦æ±‚ï¼Œç›¸åº”çš„æŒ‰é’®å°±ä¼šå¤±çµã€‚ä¾‹å¦‚ï¼š ä»£è¡¨äº† ï¼ˆï¼Œï¼Œâ€¦â€¦ï¼‰ï¼Œä» æ¥¼å¼€å§‹ã€‚åœ¨ æ¥¼ï¼ŒæŒ‰â€œä¸Šâ€å¯ä»¥åˆ° æ¥¼ï¼ŒæŒ‰â€œä¸‹â€æ˜¯ä¸èµ·ä½œç”¨çš„ï¼Œå› ä¸ºæ²¡æœ‰ æ¥¼ã€‚é‚£ä¹ˆï¼Œä» æ¥¼åˆ° æ¥¼è‡³å°‘è¦æŒ‰å‡ æ¬¡æŒ‰é’®å‘¢ï¼Ÿ è¾“å…¥æ ¼å¼ å…±äºŒè¡Œã€‚ ç¬¬ä¸€è¡Œä¸ºä¸‰ä¸ªç”¨ç©ºæ ¼éš”å¼€çš„æ­£æ•´æ•°ï¼Œè¡¨ç¤º ï¼ˆï¼Œï¼‰ã€‚ ç¬¬äºŒè¡Œä¸º ä¸ªç”¨ç©ºæ ¼éš”å¼€çš„éè´Ÿæ•´æ•°ï¼Œè¡¨ç¤º ã€‚ è¾“å‡ºæ ¼å¼ ä¸€è¡Œï¼Œå³æœ€å°‘æŒ‰é”®æ¬¡æ•°ï¼Œè‹¥æ— æ³•åˆ°è¾¾ï¼Œåˆ™è¾“å‡º -1ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 125 1 5 3 3 1 2 5 æ ·ä¾‹è¾“å‡º #1 13 æç¤º å¯¹äº çš„æ•°æ®ï¼Œï¼Œï¼Œã€‚ æœ¬é¢˜å…± ä¸ªæµ‹è¯•ç‚¹ï¼Œå‰ ä¸ªæ¯ä¸ªæµ‹è¯•ç‚¹ åˆ†ï¼Œæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹ åˆ†ã€‚ å¦‚æ ·ä¾‹ï¼šä»1æ¥¼åˆ°5æ¥¼ï¼Œå¯ä»¥ä»1-&gt;4-&gt;2-&gt;5 æŒ‰ä¸‰æ¬¡æŒ‰é’® æœç´¢çŠ¶æ€ï¼šä»ä¸€ä¸ªçŠ¶æ€å‡ºå‘ï¼Œæ ¹æ®é¢˜ç›®ä¸æ–­è½¬ç§»çŠ¶æ€ç›´åˆ°åˆ°è¾¾ç›®æ ‡çŠ¶æ€ï¼Œå¯¹å®ä¾‹å¦‚å›¾ï¼š å¦‚é¢˜ï¼šä»1æ¥¼å¼€å§‹ 1æ¥¼åªèƒ½å¾€ä¸Šåˆ°4æ¥¼ï¼Œå››æ¥¼åªèƒ½å¾€ä¸‹åˆ°2æ¥¼ï¼ŒäºŒæ¥¼åªèƒ½å¾€ä¸Šåˆ°äº”æ¥¼ â€‹ æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„äºŒå‰æ ‘ï¼Œèµ·å§‹çŠ¶æ€ä¸ºèµ·ç‚¹ï¼Œç›®æ ‡çŠ¶æ€ä¸ºæ ·ä¾‹è¾“å…¥çš„æ¥¼å±‚ è®°å½•æŒ‰æŒ‰é’®æ¬¡æ•°ï¼šä½¿ç”¨ç»“æ„ä½“å°†æ¥¼å±‚å’ŒæŒ‰é’®æ¬¡æ•°å°è£… ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 300; struct node{ // ä¿å­˜æŒ‰é’®æ¬¡æ•° int level; // å½“å‰æ¥¼å±‚ int steps; // èµ°åˆ°å½“å‰æ¥¼å±‚æ‰€éœ€è¦æ­¥æ•° }floors[N]; int n,st,ed; // æ€»æ¥¼å±‚æ•°,èµ·å§‹æ¥¼å±‚,ç›®æ ‡æ¥¼å±‚ int a[N], vis[N]; // åˆ†åˆ«ä¿å­˜æ¯ä¸ªæ¥¼å±‚å¯ä»¥ç§»åŠ¨å‡ å±‚, è¯¥æ¥¼å±‚æ˜¯å¦æ¥è¿‡ void bfs(){ queue&lt;node&gt; q; node cur, net; // è®°å½•å½“å‰çŠ¶æ€ä¸ä¸‹ä¸€çŠ¶æ€ cur.level = st; // å½“å‰ä½äºèµ·ç‚¹ï¼Œæ¥¼å±‚ä¸ºèµ·å§‹æ¥¼å±‚ cur.steps = 0; // æ‰€éœ€æ­¥æ•°ä¸º0 q.push(cur); // å­˜å…¥æ ¹èŠ‚ç‚¹ vis[st]=1; // èµ·å§‹å·²ç»èµ°è¿‡ï¼Œè®¾ä¸º1ï¼›å› ä¸ºè¿‡å»ä»¥åæ— éœ€è¿”å›ï¼Œè¿”å›å¾—åˆ°çš„å€¼ä¸€å®šæ›´å¤§ while(!q.empty()){ // é˜Ÿåˆ—éç©º cur = q.front(); // å–å‡ºé˜Ÿé¦– q.pop(); // åˆ æ‰ if (cur.level == ed){ // å¦‚æœå–å‡ºçš„å¯¹æ‰‹å³ä¸ºç›®æ ‡æ¥¼å±‚ï¼Œåˆ™å¯ä»¥ç»“æŸ cout &lt;&lt; cur.steps; return ; } // å‘ä¸Šæ‰©å±• net.level = cur.level + a[cur.level] ; // ä¸‹ä¸€æ­¥å¯ä»¥èµ°åˆ°å“ªä¸ªæ¥¼å±‚ net.steps = cur.steps+1; // æ­¥æ•°åŠ 1 if (net.level&lt;=n){ // ä¸è¶…æœ€é«˜æ¥¼å±‚ if (vis[net.level]==0){ // è‹¥æ²¡æœ‰æ¥è¿‡ vis[net.level] = 1; // å¯ä»¥å» å»å®Œæ ‡è®°å·²æ¥è¿‡ q.push(net); // å°†å­èŠ‚ç‚¹æ”¾åˆ°é˜Ÿåˆ—é‡Œ } } // å‘ä¸‹æ‰©å±• net.level = cur.level - a[cur.level]; net.steps = cur.steps+1; if (net.level&gt;=1){ if (vis[net.level]==0){ vis[net.level] = 1; q.push(net); } } } cout &lt;&lt; -1; // æ‰¾ä¸åˆ°å’¯ return ; } int main(){ ios; cin &gt;&gt; n &gt;&gt; st &gt;&gt; ed; for (int i = 1; i&lt;= n;i++){ cin &gt;&gt; a[i]; vis[i]=0; // åˆå§‹åŒ– } bfs(); return 0; } ä¾‹ï¼šéå¸¸å¯ä¹ å¤§å®¶ä¸€å®šè§‰çš„è¿åŠ¨ä»¥åå–å¯ä¹æ˜¯ä¸€ä»¶å¾ˆæƒ¬æ„çš„äº‹æƒ…ï¼Œä½†æ˜¯seeyouå´ä¸è¿™ä¹ˆè®¤ä¸ºã€‚å› ä¸ºæ¯æ¬¡å½“seeyouä¹°äº†å¯ä¹ä»¥åï¼Œé˜¿ç‰›å°±è¦æ±‚å’Œseeyouä¸€èµ·åˆ†äº«è¿™ä¸€ç“¶å¯ä¹ï¼Œè€Œä¸”ä¸€å®šè¦å–çš„å’Œseeyouä¸€æ ·å¤šã€‚ä½†seeyouçš„æ‰‹ä¸­åªæœ‰ä¸¤ä¸ªæ¯å­ï¼Œå®ƒä»¬çš„å®¹é‡åˆ†åˆ«æ˜¯N æ¯«å‡å’ŒM æ¯«å‡ å¯ä¹çš„ä½“ç§¯ä¸ºS ï¼ˆS&lt;101ï¼‰æ¯«å‡ (æ­£å¥½è£…æ»¡ä¸€ç“¶) ï¼Œå®ƒä»¬ä¸‰ä¸ªä¹‹é—´å¯ä»¥ç›¸äº’å€’å¯ä¹ (éƒ½æ˜¯æ²¡æœ‰åˆ»åº¦çš„ï¼Œä¸” S==N+Mï¼Œ101ï¼Sï¼0ï¼ŒNï¼0ï¼ŒMï¼0) ã€‚èªæ˜çš„ACMERä½ ä»¬è¯´ä»–ä»¬èƒ½å¹³åˆ†å—ï¼Ÿå¦‚æœèƒ½è¯·è¾“å‡ºå€’å¯ä¹çš„æœ€å°‘çš„æ¬¡æ•°ï¼Œå¦‚æœä¸èƒ½è¾“å‡ºâ€NOâ€ã€‚ Input ä¸‰ä¸ªæ•´æ•° : S å¯ä¹çš„ä½“ç§¯ , N å’Œ Mæ˜¯ä¸¤ä¸ªæ¯å­çš„å®¹é‡ï¼Œä»¥â€0 0 0â€ç»“æŸã€‚ Output å¦‚æœèƒ½å¹³åˆ†çš„è¯è¯·è¾“å‡ºæœ€å°‘è¦å€’çš„æ¬¡æ•°ï¼Œå¦åˆ™è¾“å‡ºâ€NOâ€ã€‚ Sample è¾“å…¥ 1237 4 3 4 1 3 0 0 0 è¾“å‡º 12No 3 çœ‹ä¼¼æ‰¾ä¸å‡ºå›¾çš„ä¸€ä¸ªæœç´¢ï¼šåªè¦æ ¹æ®ä¿¡æ¯èƒ½è¡¨ç¤ºå‡ºçŠ¶æ€ï¼Œä¸”çŠ¶æ€èƒ½æ ¹æ®è§„åˆ™è¿›è¡Œè½¬ç§»å°±å¯ä»¥ç”¨æœç´¢ å®šä¹‰èŠ‚ç‚¹çŠ¶æ€ï¼šä¸‰æ¯æ°´é‡+å½“å‰çŠ¶æ€æœ€å°‘å€’æ°´æ¬¡æ•° çŠ¶æ€è½¬ç§»å¦‚å›¾ï¼ˆä»¥4 1 3ä¸ºä¾‹ï¼Œæœ€åä¸€ä½æ˜¯æ¬¡æ•°ï¼‰ï¼š image-20241112220340957 ç›®æ ‡çŠ¶æ€ï¼šè¾¾åˆ°ä¸¤ä¸ªé‡ç›¸ç­‰ä¸€ä¸ªé‡ä¸º0 å€’æ°´è¦æ±‚ï¼šåªèƒ½å€’æ»¡æˆ–è€…å€’ç©º è¿™ç§é¢˜ç›®ç§°ä¸ºéšå¼å›¾ å¦‚ä½•å‰ªæï¼šè®¿é—®è¿‡çš„èŠ‚ç‚¹ä¸åœ¨è®¿é—® ä¾‹ï¼šç¦»å¼€ä¸­å±±è·¯ ç¦»å¼€ä¸­å±±è·¯ é¢˜ç›®èƒŒæ™¯ ã€Šçˆ±ä¸æ„çš„æ•…äº‹ç¬¬ä¸‰å¼¹Â·shoppingã€‹æœ€ç»ˆç« ã€‚ é¢˜ç›®æè¿° çˆ±ä¸æ„å¤§ç¥ä¹°å®Œä¸œè¥¿åï¼Œæ‰“ç®—åè½¦ç¦»å¼€ä¸­å±±è·¯ã€‚ç°åœ¨çˆ±ä¸æ„å¤§ç¥åœ¨ å¤„ï¼Œè½¦ç«™åœ¨ å¤„ã€‚ç°åœ¨ç»™å‡ºä¸€ä¸ª çš„åœ°å›¾ï¼Œ è¡¨ç¤ºé©¬è·¯ï¼Œ è¡¨ç¤ºåº—é“ºï¼ˆä¸èƒ½ä»åº—é“ºç©¿è¿‡ï¼‰ï¼Œçˆ±ä¸æ„å¤§ç¥åªèƒ½å‚ç›´æˆ–æ°´å¹³ç€åœ¨é©¬è·¯ä¸Šè¡Œè¿›ã€‚çˆ±ä¸æ„å¤§ç¥ä¸ºäº†èŠ‚çœæ—¶é—´ï¼Œä»–è¦æ±‚æœ€çŸ­åˆ°è¾¾ç›®çš„åœ°è·ç¦»ï¼ˆæ¯ä¸¤ä¸ªç›¸é‚»åæ ‡é—´è·ç¦»ä¸º ï¼‰ã€‚ä½ èƒ½å¸®ä»–è§£å†³å—ï¼Ÿ è¾“å…¥æ ¼å¼ ç¬¬ è¡ŒåŒ…å«ä¸€ä¸ªæ•° ã€‚ ç¬¬ è¡Œåˆ°ç¬¬ è¡Œï¼šæ•´ä¸ªåœ°å›¾æè¿°ï¼ˆ è¡¨ç¤ºé©¬è·¯ï¼Œ è¡¨ç¤ºåº—é“ºï¼Œæ³¨æ„ä¸¤ä¸ªæ•°ä¹‹é—´æ²¡æœ‰ç©ºæ ¼ï¼‰ã€‚ ç¬¬ è¡Œï¼šå››ä¸ªæ•° ã€‚ è¾“å‡ºæ ¼å¼ åªæœ‰ è¡Œï¼Œå³æœ€çŸ­åˆ°è¾¾ç›®çš„åœ°è·ç¦»ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 123453 001 101 100 1 1 3 3 æ ·ä¾‹è¾“å‡º #1 14 æç¤º å¯¹äº æ•°æ®ï¼Œæ»¡è¶³ ã€‚ å¯¹äº æ•°æ®ï¼Œæ»¡è¶³ ã€‚ å¯ä»¥ä½¿ç”¨æ–¹å‘æ•°ç»„æ¥è½¬ç§»çŠ¶æ€: å¯¹äºç½‘æ ¼åœ°å›¾,å¯ä»¥å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}}; åˆ™éå†å››ä¸ªæ–¹å‘å¯ä»¥ 1234for (int i = 0; i &lt;4; i++){ x2 = x1+dir[i][0]; y2 = y1+dir[i][1]; } å‘ç‚¹ï¼šè¾“å…¥ä¸­é—´æ— ç©ºæ ¼ï¼Œæ˜¯ä¸€èµ·è¾“å…¥çš„ï¼Œéœ€è¦ç”¨å­—ç¬¦ä¸²è½¬æ¢ä¸ºæŸè¡ŒæŸåˆ—ï¼ˆasciiè½¬åŒ–ï¼Œchar - 'a'ï¼‰å­˜å…¥æ•°ç»„ ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*è¿·å®«é—®é¢˜å¦‚æœè¦æ±‚æœ€çŸ­è·¯å¾„ï¼ˆæƒå€¼ä¸º1ï¼‰ç›¸å…³ï¼Œåˆ™å¯ä»¥é€‰ç”¨bfs è¿™é‡Œå¯ä»¥å°†è¿·å®«çœ‹ä½œå›¾ï¼Œè¯¦è§markdownä¸­å›¾çš„éå† */ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 1010; typedef pair&lt;int,int&gt; PII; int n,sx,sy,ex,ey; // è®°å½•åœ°å›¾å¤§å°ï¼Œèµ·ç‚¹ç»ˆç‚¹ int mmap[N][N], vis[N][N]; // è®°å½•åœ°å›¾å’Œæ˜¯å¦èµ°è¿‡ï¼ˆèµ°è¿‡ä¸ç”¨å†å¾€å›èµ°ï¼Œä¸ç„¶æ­¥æ•°ä¸€å®šæ›´é•¿ï¼‰ int dx[]={-1,0,1,0}; // æ–¹å‘æ•°ç»„x int dy[]={0,1,0,-1}; // æ–¹å‘æ•°ç»„y // ç»“æ„ä½“è®°å½•åæ ‡ä¸æ­¥æ•° struct node{ int first; // å½“å‰xåæ ‡ int second; // å½“å‰yåæ ‡ int steps; // å½“å‰æ­¥æ•° }; void bfs(){ queue&lt;node&gt; q; // é˜Ÿåˆ— node cur, net; // è®°å½•å½“å‰çŠ¶æ€ä¸ä¸‹ä¸€çŠ¶æ€ cur.first = sx, cur.second = sy, cur.steps = 0; // åˆå§‹åŒ–ä¸ºèµ·å§‹åæ ‡ï¼Œæ­¥æ•°ä¸º0 vis[sx][sy] = 1; // ä¸è¦å¿˜äº†èµ·å§‹åæ ‡è®¾ä¸º1 q.push(cur); // æ ¹èŠ‚ç‚¹å…¥é˜Ÿ while(!q.empty()){ // é˜Ÿåˆ—å˜ç©ºæ—¶æœç´¢å®Œæ¯• cur = q.front(); // å–å‡ºé˜Ÿé¦– q.pop(); // åˆ é™¤é˜Ÿé¦– if (cur.first == ex &amp;&amp; cur.second == ey){ // åˆ°è¾¾ç»ˆç‚¹ cout &lt;&lt; cur.steps; //è¾“å‡ºæ­¥æ•° return ; // è·³å‡º } for (int i = 0;i &lt;4; i++){ net.first = cur.first+dx[i]; // ä¸‹ä¸€æ­¥çš„xåæ ‡ net.second = cur.second+dy[i]; // ä¸‹ä¸€æ­¥çš„yåæ ‡ if (net.first&lt;1||net.second&lt;1||net.first&gt;n||net.second&gt;n) continue; // è¶…å‡ºè¾¹ç•Œ if (mmap[net.first][net.second]) continue; // ç¢°åˆ°éšœç¢ if (vis[net.first][net.second]) continue; // å·²ç»è®¿é—® net.steps = cur.steps +1; // è‹¥æ»¡è¶³å‰è¿›çš„æ¡ä»¶å°±å‰è¿›ä¸€æ­¥ vis[net.first][net.second] = 1; // æŠŠè®¿é—®è¿‡çš„åœ°æ–¹æ ‡è®° q.push(net); // å°†å­èŠ‚ç‚¹å…¥é˜Ÿåˆ— } } return ; } int main(){ ios; cin &gt;&gt; n; string s; // æ³¨æ„ï¼šè¿™é‡Œé¢˜ç›®è¾“å…¥é—´æ²¡æœ‰ç©ºæ ¼ï¼Œç›¸å½“äºæ˜¯è¾“å…¥ä¸€æ•´ä¸ªæ•°å­—ï¼Œéœ€è¦æ‰‹åŠ¨æ‹†å¼€ // è¿™é‡Œç”¨è½¬æˆå­—ç¬¦ä¸²ç”¨asciiè½¬åŒ–çš„æ–¹æ³• for (int i = 1;i &lt;=n;i++){ cin &gt;&gt; s ; for (int j = 1;j &lt;=n;j++){ mmap[i][j] = s[j-1]-'0'; vis[i][j]=0; } } cin &gt;&gt; sx &gt;&gt;sy &gt;&gt; ex &gt;&gt; ey; bfs(); return 0; }","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"ã€ç®—æ³•ã€‘DFS","slug":"DFS","date":"2025-03-01T03:29:57.440Z","updated":"2025-03-01T03:30:36.654Z","comments":true,"path":"2025/03/01/DFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/DFS/","excerpt":"","text":"DFS å‚è€ƒè§†é¢‘ å‰ç½®çŸ¥è¯†ï¼šäºŒå‰æ ‘çš„éå† ä¸‰ç§éå† å…ˆæ ¹éå†ï¼ˆæ ¹å·¦å³ï¼‰ ä¸­æ ¹éå†ï¼ˆå·¦æ ¹å³ï¼‰ åæ ¹éå†ï¼ˆå·¦å³æ ¹ï¼‰ æ³¨æ„ï¼šè¿™é‡Œçš„å·¦å³ä¸ºå·¦å³å­æ ‘ e.g. 1. å…ˆæ ¹éå†ï¼š271653894 1. ä¸­æ ¹éå†ï¼š175632849 1. åæ ¹éå†ï¼š153674982 äºŒå‰æ ‘çš„ç¡®å®š ç»™å®šå…ˆæ ¹å’Œä¸­æ ¹ã€ä¸­æ ¹å’Œåæ ¹éå†ç»“æœï¼Œå¯ä»¥å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ e.g. ä¸Šé¢ï¼Œåœ¨å…ˆæ ¹ä¸­ç¡®å®š2ä¸ºæ ¹ï¼Œåœ¨ä¸­æ ¹ä¸­æ‰¾åˆ°2ï¼Œåˆ™2å‰ååˆ†åˆ«ä¸ºå…¶å·¦å³å­æ ‘ï¼›å†åœ¨å…ˆæ ¹ä¸­æ‰¾åˆ°7ï¼Œåœ¨ä¸­æ ¹ä¸­æ‰¾åˆ°7ï¼Œåˆ™7å‰åä¸ºå…¶å·¦å³å­æ ‘ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä¸­æ ¹åæ ¹ä¸å‰æ ¹åæ ¹æ˜¯å¯¹ç§°çš„ã€‚ ç»™å®šå…ˆæ ¹å’Œåæ ¹éå†ç»“æœï¼Œä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ åªçŸ¥é“æ ¹æ•°é‡è€Œä¸çŸ¥é“å·¦å³å­æ ‘æ•°é‡ é€’å½’ é€’å½’ç‰¹å¾ï¼šå¤§é—®é¢˜ä¸å­é—®é¢˜é™¤äº†è§„æ¨¡å…¶ä»–éƒ½ä¸€æ · æ–æ³¢é‚£å¥‘æ•°åˆ—çš„é€’å½’å®ç° 1234int fi(int a){ if (a==0||a==1) return 1; else return fi(a-1)+fi(a-2); } å³æœ‰ä¸€ä¸ªç‰¹å®šæ¨¡æ¿ï¼š å³å…ˆå†™ç¨‹åºå‡ºå£ï¼ˆä¸éœ€è¦é€’å½’çš„ç‰¹æ®Šæƒ…å†µï¼‰ï¼Œå†å†™æ™®é€šæƒ…å†µï¼ˆé€’å½’ï¼‰ å…¨æ’åˆ—é—®é¢˜ è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°nï¼ŒæŒ‰å­—å…¸åºè¾“å‡ºn-1çš„å…¨æ’åˆ— é€’å½’ç‰¹å¾ è‹¥ç¬¬ä¸€ä¸ªæ•°ç¡®å®šï¼Œå‰©ä½™çš„é—®é¢˜å°±æ˜¯å…¶ä½™n-1ä¸ªæ•°çš„å…¨æ’åˆ— è‹¥å‰kä¸ªæ•°å·²ç»æ’å¥½ï¼Œå‰©ä½™é—®é¢˜å°±æ˜¯å…¶ä½™n-kä¸ªæ•°çš„å…¨æ’åˆ— ä»£ç å®ç° 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; using namespace std; int n; int num[10], vis[10]; void dfs(int step); int main(){ while (scanf(\"%d\",&amp;n)==1){ memset(vis,0,sizeof vis); dfs(1); // ä»ç¬¬ä¸€ä½å¼€å§‹å¤„ç† } return 0; } void dfs(int step){ // æ¥ä¸‹æ¥å‡†å¤‡å¤„ç†ç¬¬stepä½ if (step==n+1){ // å‰nä½éƒ½æ”¾å¥½äº†ï¼Œè¿›è¡Œè¾“å‡º for (int i = 1; i &lt;=n; i++) printf(\"%d\", num[i]); printf(\"\\n\"); return ; } for (int i = 1;i &lt;= n;i++){ if (vis[i]==0){ // ç¬¬iä½æ•°æ²¡ç”¨è¿‡ num[step]=i; // nunä¸­å½“å‰è¿™ä¸€ä½ä¿å­˜ä¸€ä¸ªi vis[i]=1; // iè¢«ç”¨è¿‡äº†ï¼Œåšæ ‡è®°1 dfs(step+1); vis[i]=0; } } } è‹¥n==3ï¼š visï¼š0 0 0 0 step==1 â€‹ è¿›å…¥forå¾ªç¯: vis[1]==0 â€‹ ä½¿num[1]=1 vis[1] = 1 â€‹ numï¼š 0 1 0 0 0 â€‹ visï¼š0 1 0 0 è¡¨ç¤º1ç”¨è¿‡äº† visï¼š 0 1 0 0 step==2 â€‹ è¿›å…¥forå¾ªç¯: vis[2]==0 â€‹ num[2]=2 vis[2] = 1 â€‹ numï¼š 0 1 2 0 0 â€‹ visï¼š0 1 1 0 è¡¨ç¤º1,2ç”¨è¿‡äº† visï¼š0 1 1 0 step==3 â€‹ è¿›å…¥forå¾ªç¯: vis[3]==0 â€‹ num[3]=3 vis[3] = 1 â€‹ numï¼š 0 1 2 3 0 â€‹ visï¼š0 1 1 1 è¡¨ç¤º1,2,3ç”¨è¿‡äº† visï¼š0 1 1 1 step==4 â€‹ step == 3+1æˆç«‹ï¼Œåˆ°è¾¾è¾¹ç•Œï¼Œåˆ™è¾“å‡ºnum[1]åˆ°num[n] 123 â€‹ return åˆ°dfs(3)ä¸­ï¼ˆè°è°ƒç”¨çš„è¿”å›è°ï¼‰ dfs(3)ï¼švis[3]=0 visï¼š0 1 1 0 ç¨‹åºç»“æŸè¿”å›dfs(2) dfs(2)ï¼švis[2]=0 visï¼š0 1 0 0 â€‹ æ­¤æ—¶è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ i==3ï¼Œvis[3]==0 â€‹ num[2]=3,vis[3]=1 â€‹ numï¼š 0 1 3 0 â€‹ visï¼š0 1 0 1 è¡¨ç¤º1,3ç”¨è¿‡äº† â€‹ å†è¿›å…¥dfs(3)ï¼Œé‡å¤ä¸Šè¿°æ“ä½œå â€‹ numï¼š0 1 3 2 â€‹ visï¼š0 1 1 1 â€‹ è¿›å…¥dfs(4)åˆ°è¾¾è¾¹ç•Œè¾“å‡º 132 â€‹ return åˆ°dfs(3)ä¸­é‡å¤ä¸Šè¿°è¿‡ç¨‹ è‹¥æ²¡æœ‰vis[i]=0çš„å›æº¯ï¼Œåˆ™ç¬¬ä¸€éreturnåvisä»ä¿æŒå…¨æ ‡è®°1çŠ¶æ€ï¼Œåˆ™æ— æ³•å†è¾“å‡ºå…¶ä»–æ’åˆ—ç›´æ¥ç»“æŸ åŸºæœ¬æ¨¡å‹ å…³é”®åœ¨äºç€çœ¼äºå½“ä¸‹å¦‚ä½•åšï¼Œä¸‹ä¸€æ­¥çš„åšæ³•ä¸å½“å‰ä¸€æ ·ï¼Œåªæ˜¯å‚æ•°ä¸åŒ 123456void dfs(int step){ ç‰¹æ®Šæƒ…å†µå¤„ç†(ç»“æŸé€’å½’æƒ…å†µ) æšä¸¾å½“å‰æ¯ä¸€ç§å¯èƒ½for(int i=1;i&lt;=;i++) åœ¨æšä¸¾çš„æ¯ä¸€ç§å¯èƒ½ä¸­ï¼Œé€’å½’dfs(step+1); å›æº¯ } ä¾‹ï¼šè¿·å®«æœç´¢ Tempter of the Bone Problem Description The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze. The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. Input The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following: â€˜Xâ€™: a block of wall, which the doggie cannot enter; â€˜Sâ€™: the start point of the doggie; â€˜Dâ€™: the Door; or â€˜.â€™: an empty block. The input is terminated with three 0â€™s. This test case is not to be processed. Output For each test case, print in one line â€œYESâ€ if the doggie can survive, or â€œNOâ€ otherwise. Sample Input 123456789104 4 5 S.X. ..X. ..XD .... 3 4 5 S.X. ..X. ...D 0 0 0 Sample Output 12NO YES åˆ†æï¼š æ¯ä¸ªblockåªèƒ½èµ°ä¸€æ¬¡ æ°å¥½ç»™å®šæ—¶é—´åˆ°è¾¾å‡ºå£ å‰ªææ¡ä»¶ï¼š è‹¥å¯èµ°çš„blockæ€»æ•°å°äºæ—¶é—´ï¼šå…¨èµ°å®Œéƒ½å¼€ä¸äº†é—¨ï¼Œè‚¯å®šNO è‹¥èµ·ç‚¹åœ¨å·¦ä¸Šè§’ï¼Œé—¨åœ¨å³ä¸‹è§’ï¼Œæ²¡æœ‰éšœç¢ç‰©ä¸”æœ€çŸ­è·¯å¾„ï¼ˆæ›¼å“ˆé¡¿è·ç¦»ï¼šè¡Œåæ ‡å·®å‡åˆ—åæ ‡å·®ï¼‰éƒ½æ¯”æ—¶é—´é•¿ï¼Œè‚¯å®šNO å¥‡å¶æ€§å‰ªæï¼ˆåº”ç”¨æ¡ä»¶ï¼šæ¯ä¸ªæ ¼å­åªèƒ½ç­‰ä¸€ç§’ï¼‰ï¼š ä½¿è¡Œåˆ—åæ ‡ç›¸åŠ ä¸ºå¶æ•°çš„æ ‡ä¸º0ï¼Œä¸ºå¥‡æ•°çš„æ ‡ä¸º1ï¼Œå‘ç°1çš„ä¸‹ä¸€æ­¥ä¸€å®šä¸º0ï¼Œ0çš„ä¸‹ä¸€æ­¥ä¸€å®šä¸º1 é‚£ä¹ˆå¦‚æœä»0èµ°åˆ°1æˆ–ä»1èµ°åˆ°0ï¼Œæ‰€éœ€æ—¶é—´ä¸ºå¥‡æ•°ï¼›å¦‚æœä»1èµ°åˆ°1æˆ–ä»0èµ°åˆ°0ï¼Œæ‰€éœ€æ—¶é—´ä¸ºå¶æ•° é‚£ä¹ˆå¦‚æœè§„å®šæ—¶é—´ä¸ºå¶æ•°ï¼Œåˆ™ä»0åˆ°1æˆ–ä»1åˆ°0è‚¯å®šNOï¼Œåä¹‹äº¦ç„¶ã€‚ ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; char mmap[9][9]; // å­˜å‚¨åœ°å›¾ æ³¨æ„åœ°å›¾è¦æ¯”æ•°æ®èŒƒå›´å¤§ä¸€ç‚¹ int n,m,t,escape; int si,sj,di,dj; // è®°å½•èµ·å§‹ä¸ç»“æŸç‚¹åæ ‡ int dir[4][2]={{0,-1},{0,1},{-1,0},{1,0}}; // è¿›è¡Œä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘çš„è¡Œèµ° void dfs(int x, int y, int cnt){ // è¡Œåˆ—åæ ‡ï¼Œå·²ç»èŠ±çš„æ—¶é—´ if (x&gt;n||y&gt;m||x&lt;=0||y&lt;=0) return ; // è¶Šè¿‡è¾¹ç•Œï¼Œè·³è¿‡ if (cnt==t&amp;&amp;x==di&amp;&amp;y==dj) { // åœ¨å¼€é—¨æ—¶é—´åˆ°è¾¾å‡ºå£ escape=1; // æ ‡è®°é€ƒç¦»æˆåŠŸ } if (escape) return ; // t-cnt:å‰©ä½™æ—¶é—´ ä¸¤abs:å‰©ä½™è·ç¦» int tmp=((t-cnt)-abs(di-x)-abs(dj-y)); // å°äºé›¶ï¼šå‰©ä½™æ—¶é—´å†…èµ°ä¸åˆ°ç»ˆç‚¹ /* æ˜¯å¥‡æ•°ï¼šä¸ºäº†åˆ°è¾¾é—¨å£ï¼Œå‰©ä½™æ—¶é—´ä¸å‰©ä½™è·ç¦»çš„å¥‡å¶æ€§ä¸€å®šè¦ç›¸åŒ å¥‡æ•°-å¥‡æ•°=å¶æ•° å¶æ•°-å¶æ•°=å¶æ•° æ•…tmpä¸€å®šè¦æ˜¯å¶æ•°æ‰èƒ½ä¿è¯èµ°åˆ°é—¨å£ï¼Œå¦åˆ™åŒ…èµ°ä¸åˆ° å³å¥‡å¶æ€§å‰ªæ */ // è¯¥å¥‡å¶æ€§å‰ªæå¯ä»¥åœ¨ä¸»å‡½æ•°é‡Œå†™ï¼Œå› ä¸ºæ—¶é—´å’Œè·ç¦»æ˜¯åŒæ­¥è¿›è¡Œçš„ if (tmp&lt;0) return ; // å››ä¸ªæ–¹å‘éå† for (int i = 0 ;i &lt; 4;i++){ if (mmap[x+dir[i][0]][y+dir[i][1]]!='X'){ // ä¸æ˜¯éšœç¢ç‰© mmap[x+dir[i][0]][y+dir[i][1]]='X'; //ä¿®æ”¹ dfs(x+dir[i][0],y+dir[i][1],cnt+1); //é€’å½’ mmap[x+dir[i][0]][y+dir[i][1]]='.'; //å›æº¯ï¼Œè¿™æ ·å¯ä»¥å›åˆ°ä¸Šä¸€æ­¥æ¢ä¸€æ¡è·¯èµ° } } return ; } int main(){ while(cin &gt;&gt; n &gt;&gt; m &gt;&gt;t){ if (n==0&amp;&amp;m==0&amp;&amp;t==0) break; // ç»“æŸæ¡ä»¶ int block = 0; // éšœç¢ç‰©æ•°é‡ï¼šç”¨æ¥å‰ªæ for(int i = 1;i &lt;=n;i++){ for(int j = 1; j&lt;=m;j++){ cin &gt;&gt; mmap[i][j]; if (mmap[i][j]=='S') { si=i; sj=j; } else if (mmap[i][j]=='D') { di=i; dj=j; } else if (mmap[i][j]=='X') block++; } } // å‰ªæ1ï¼šè¿·å®«æ ¼å­æ•°é‡å‡å»éšœç¢ç‰©æ•°é‡å°äºç­‰äºå¼€é—¨æ—¶é—´ï¼Œä¸€å®šå‡ºä¸å» if (n*m-block&lt;=t) { cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // å‰ªæ2ï¼šè§dfsé‡Œçš„è§£é‡Š if ((t-(abs(di-si)+abs(dj-sj)))%2==1){ cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // escapeæ ‡è®°æ˜¯å¦æˆåŠŸï¼ŒæŠŠèµ·ç‚¹æ ‡ä¸ºéšœç¢ç‰©ï¼Œç¡®ä¿ä¸ä¼šå†å›æ¥ escape = 0, mmap[si][sj]='X'; dfs(si,sj,0); // åˆ¤æ–­æ˜¯å¦èƒ½é€ƒç¦» if (escape) cout &lt;&lt;\"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0; }","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"ã€ç®—æ³•ã€‘å‰ç¼€å’Œä¸å·®åˆ†","slug":"å‰ç¼€å’Œä¸å·®åˆ†","date":"2025-03-01T02:53:46.740Z","updated":"2025-03-01T03:30:26.716Z","comments":true,"path":"2025/03/01/å‰ç¼€å’Œä¸å·®åˆ†/","permalink":"https://izayoisakuye.github.io/2025/03/01/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"å‰ç¼€å’Œä¸å·®åˆ† ä¸€ç»´å‰ç¼€å’Œ e.g. ç»™å®šé•¿åº¦ä¸ºnçš„æ•°ç»„arr, æ±‚qæ¬¡è¯¢é—®ä¸­æ¯æ¬¡arråœ¨[l,r]çš„åŒºé—´å’Œ æš´åŠ›æšä¸¾çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(qn) å®¹æ˜“TLE ä½¿ç”¨å‰ç¼€å’Œå¯ä»¥æå¤§å‡å°‘è¿è¡Œæ—¶é—´ å‰ç¼€å’Œæ•°ç»„ å®šä¹‰ä¸€ä¸ªå‰ç¼€å’Œæ•°ç»„prefix[i]=prefix[i-1]+arr[i]ï¼Œå…¶ä¸­i&gt;0 i=0æ—¶sum[0]=arr[0] åˆ™å¯¹äºæ•°a1,a2,a3,a4,a5â€¦. prefix[1]=a1 prefix[2]=a1+a2 prefix[3]=a1+a2+a3 â€¦ å¯ä»¥çœ‹å‡ºï¼Œprefix[i]ä¸ºåŒºé—´[0,i]çš„å’Œ åœ¨æ±‚åŒºé—´çš„å’Œæ—¶ï¼Œå¦‚2-4ï¼Œå°±å¯ä»¥ä½¿ç”¨prefix[4]-prefix[1],é€šå¼ä¸ºprefix[r]-prefix[l-1], l=0æ—¶ä¸ºprefix[r] å…¶ä¸­ï¼Œæ±‚å‰ç¼€å’Œçš„è¿‡ç¨‹æˆä¸ºé¢„å¤„ç† æ¿å­ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; //#define get_sum(l, r) ((l)?(sum[r]-sum[l]):(sum[r])) using namespace std; const int N = 10000; int a[N], prefix[10000]; int get_sum(int l , int r){ if (l) return prefix[r]-prefix[l-1]; else return prefix[r]; } int main(){ ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // é¢„å¤„ç†ï¼Œä¸€èˆ¬ä»¥1å¼€å§‹ä¸ºä¸‹æ ‡ for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // è®¿é—® int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; //cout &lt;&lt; prefix[r]-prefix[l-1]; cout &lt;&lt; get_sum(l,r); } return 0; } äºŒç»´å‰ç¼€å’Œ ç»™å®šä¸€ä¸ªé•¿n,å®½mçš„çŸ©é˜µ: æ±‚çŸ©é˜µä»»æ„ä¸¤ç‚¹é—´çŸ©å½¢çš„æ•°å­—ä¹‹å’Œ äºŒç»´å‰ç¼€å’Œæ•°ç»„ å®šä¹‰ä¸€ä¸ªäºŒç»´å‰ç¼€å’Œæ•°ç»„prefix[i][j] =prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]ï¼Œå…¶ä¸­i&gt;0 å…¶ä¸­ï¼Œprefix[i][j]ä¸ºä»(0,0)åˆ°(i,j)çš„å’Œ å½“i=0ä¸”j=0æ—¶ï¼Œprefix[0][0]=a[0][0] å½“i=0ä¸”j!=0æ—¶ï¼Œprefix[0][j]=prefix[0][j-i]+a[0][j] å½“i!=0ä¸”j=0æ—¶ï¼Œprefix[i][0]=prefix[i-1][0]+a[i][0] å¦‚ä¸‹å›¾ï¼š å³prefix[i][j]æ˜¯ç”±a[i][j],prefix[i-1][j],prefix[i][j-1]ç»„æˆçš„ï¼Œä½†ä¸¤å—åŠ å¤šäº†ä¸€å—prefix[i-1][j-1]ï¼Œæ•…å‡å» è‹¥è¦æ±‚è§£æŸéƒ¨åˆ†çŸ©å½¢ï¼Œå°±å¯ä»¥è¿›è¡Œä»¥ä¸Šçš„é€†è¿‡ç¨‹ a[i][j]=prefix[i][j]-prefix[i-1][j]-prefix[i][j-1]+prefix[i-1][j-1] ä»prefix[i][j]å¼€å§‹ï¼Œæ±‚a[i][j]ï¼Œåˆ™å¯ä»¥ä¾æ¬¡å‡å»prefix[i-1][j],prefix[i][j-1]ï¼Œä½†ä¼šå¤šå‡ä¸€å—prefix[i-1][j-1]ï¼Œæ•…åŠ ä¸Š æ¿å­ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m; int a[N][N]; int prefix[N][N]; void pre_sum(){ /*ä»¥ä¸‹ä»£ç æ˜¯å½“forå¾ªç¯ä»0å¼€å§‹æ—¶çš„åˆå§‹åŒ– prefix[0][0]=a[0][0]; for (int i = 1;i &lt;n;i++) prefix[i][0] = prefix[i-1][0]+a[i][0]; for (int j = 1;j &lt;m;j++) prefix[0][j] = prefix[0][j-1]+a[0][j]; */ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]; } } } int get_sum(int x1, int y1, int x2, int y2){ /*ä»¥ä¸‹ä¸ºä»0å¼€å§‹æ—¶çš„ç‰¹æ®Šæƒ…å†µ // ä»0,0å¼€å§‹åŠ  if (!x1 &amp;&amp; !y1) return prefix[x2][y2]; // æˆè¡Œç›¸åŠ  if (!x1) return prefix[x2][y2]-prefix[x2][y1-1]; // æˆåˆ—ç›¸åŠ  if (!y1) return prefix[x2][y2]-prefix[x1-1][y2]; */ return prefix[x2][y2]-prefix[x1-1][y2]-prefix[x2][y1-1]+prefix[x1-1][y1-1]; } int main(){ int x1,y1,x2,y2; cin &gt;&gt; n &gt;&gt;m; for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; } } cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; pre_sum(); cout &lt;&lt; get_sum(x1,y1,x2,y2); return 0; } ä¸€ç»´å·®åˆ† ç»™å®šé•¿åº¦ä¸ºnçš„æ•°ç»„arrï¼Œè¿›è¡Œmä¸ªæ“ä½œï¼Œä½¿[l,r]åŒºé—´å†…çš„å€¼éƒ½åŠ ä¸€ä¸ªvalueï¼Œæ“ä½œç»“æŸåï¼Œè¯¢é—®arr æš´åŠ›è§£æ³•ï¼šæ¯æ¬¡éå†æ•°ç»„[l,r]æ‰§è¡ŒåŠ valueæ“ä½œï¼Œéå†mæ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦O(n*m) ä¾‹å¦‚ arrä¸­æœ‰äº”ä¸ªæ•° 1 3 7 5 2 å¯¹[2,4] +5 [1,3] +2 [0,2] -3 å¯¹äºä¸‹æ ‡ä¸º2çš„æ•°åˆ†æï¼Œ7+5+2-3=11. è‹¥ä¸ç®¡ä¸­é—´ï¼Œåˆ™ç›¸å½“äº7+4=11. åˆ™æˆ‘ä»¬çš„ç›®çš„å³ä¸ºè®©ä¸­é—´çš„æ­¥éª¤çœç•¥ï¼Œæœ€ååª+4. å·®åˆ†æ•°ç»„ å®šä¹‰ä¸€ä¸ªå·®åˆ†æ•°ç»„d[i]=arr[i]-arr[i-1] åˆ™å¯¹dè¿›è¡Œå‰ç¼€å’Œï¼Œå¾—åˆ°å‰ç¼€å’Œæ•°ç»„sumï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼š â€‹ å·®åˆ†æ•°ç»„å¯ä»¥é€šè¿‡å‰ç¼€å’Œå¾—åˆ°åŸæ•°ç»„ â€‹ å³d[i]+=d[i-1] å·®åˆ†æ ‡è®° å¯¹äºä¸€ä½å·®åˆ†åŒºé—´ä¿®æ”¹ï¼š[l,r]+valued[l]+value, d[r+1]-value å¯¹äºä»¥ä¸Šarr å¯¹åº”å·®åˆ†æ•°ç»„dä¸º1 2 4 -2 -3 ç¬¬ä¸€æ¬¡æ“ä½œç­‰ä»·äºd[2]+5 ç»“æœä¸º1 2 9 -2 -3 ç¬¬äºŒæ¬¡ç­‰ä»·äºd[1]+2,d[4]-2 ç»“æœä¸º1 4 9 -2 -5 ç¬¬ä¸‰æ¬¡ï¼š-2 4 9 1 -5 è¿›è¡Œå‰ç¼€å’Œå¾—åˆ°sum -2 2 11 12 7 æ³¨æ„ï¼š æŠŠæ ‡è®°åçš„å·®åˆ†æ•°ç»„è¿›è¡Œä¸€æ¬¡å‰ç¼€å’Œæ“ä½œ æ¯è¿›è¡Œmæ¬¡æ“ä½œåéƒ½è¦è¿›è¡Œä¸€æ¬¡å‰ç¼€å’Œ å³é€‚ç”¨äºå¤šæ¬¡æ“ä½œå•æ¬¡è¯¢é—®ï¼ˆå•æ¬¡æ“ä½œå•æ¬¡è¯¢é—®ä¸é€‚ç”¨ï¼‰ åŸç†ï¼š å·®åˆ†æ•°ç»„ä¸­ï¼Œæ ‡è®°ä½åŠ äº†ä¸€ä¸ªæ•°ï¼Œè¿˜åŸæˆåŸæ•°ç»„çš„æ—¶å€™ï¼Œåé¢çš„æ•°éƒ½ä¼šç´¯åŠ ï¼Œç„¶åå†r+1ä½åœ¨å‡å»è¿™ä¸ªæ•°åœæ­¢ç´¯åŠ  æœ€ç»ˆå®ç°çš„æ•ˆæœä¸ºï¼šsum[l,r]+value, sum[r+1,n-1] +value - value å¦‚ï¼šå¯¹äºå·®åˆ†æ•°ç»„d 0 1 0 0 0ï¼Œè¿›è¡Œä¸€æ¬¡å‰ç¼€å’Œåå…¶sumä¸º 0 1 1 1 1ï¼Œå³æ ‡è®°ä½åŠ çš„æ•°ä¼šä½œç”¨ä¸è¯¥æ ‡è®°ä¹‹åæ¯ä¸€ä½ï¼Œå³d[i]+value sum[i,n-1]+value è‹¥æƒ³åœ¨æŸä½ç½®åœæ­¢ç´¯åŠ ï¼Œåœ¨è¯¥ä½ç½®+1å¤„å‡æ‰valueå³å¯ï¼Œå¦‚ d 0 1 0 0 -1ï¼Œå‰ç¼€å’Œåsumä¸º 0 1 1 1 0ï¼ŒåŠ ä¸€å‡ä¸€æŠµæ¶ˆä¸º0ï¼Œå³d[r+1]-value sum[r+1,n-1]-value æ¿å­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt; using namespace std; int main(){ int a[10000]={0}, diff[10000]={0}, prefix[10000]={0}; int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // é¢„å¤„ç†ï¼Œå¾—åˆ°å·®åˆ†æ•°ç»„ï¼Œä¸€èˆ¬ä»¥1å¼€å§‹ä¸ºä¸‹æ ‡ for (int i = 1; i &lt;= n; i++) { diff[i] = a[i]-a[i-1]; } // å¯¹åŒºé—´å…ƒç´ å¤„ç† // æƒ³è®©åŒºé—´å…ƒç´ éƒ½+xï¼Œåˆ™å¯ä»¥è®©lå³è¾¹éƒ½åŠ xï¼Œå†rå³è¾¹éƒ½-x int m; cin &gt;&gt; m; while(m--){ int l, r, x; cin &gt;&gt; l&gt;&gt; r&gt;&gt; x; // è¿›è¡Œå·®åˆ†æ ‡è®° diff[l]+=x, diff[r+1]-=x; } // å¯¹å·®åˆ†æ•°ç»„è¿›è¡Œå‰ç¼€å’Œå¾—å‡ºç»“æœ for (int i = 1; i &lt;=n; i++) { a[i] = a[i-1] +diff[i]; } // å†è¿›è¡Œå‰ç¼€å’Œä»¥åº”å¯¹æ¥ä¸‹æ¥çš„è®¿é—® for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // è®¿é—® int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; prefix[r]-prefix[l-1]; } return 0; } äºŒç»´å·®åˆ† ç»™å®šé•¿n,å®½mçš„çŸ©é˜µï¼Œä»(xi,yi)åˆ°(xj,yj)æ‰§è¡Œmæ¬¡æ“ä½œï¼Œä½¿ä¸¤ç‚¹é—´çŸ©å½¢ä¸­çš„å€¼éƒ½åŠ ä¸€ä¸ªvalueï¼Œæ“ä½œç»“æŸåï¼Œè¯¢é—®çŸ©é˜µ å¤§ä½“æ€è·¯ä¸ä¸€ç»´å·®åˆ†å·®ä¸å¤š å·®åˆ†çŸ©é˜µ å®šä¹‰ä¸€ä¸ªå·®åˆ†çŸ©é˜µï¼šd[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1] æˆ–è€…å¯ä»¥å°†å·®åˆ†çŸ©é˜µä¸­çš„å…ƒç´ ä¸€ä¸ªä¸ªæ’å…¥ï¼š å³è‹¥åŸçŸ©é˜µ(x,y)å¤„å€¼ä¸ºvalueï¼Œåˆ™ç›¸å½“äºä»å·¦ä¸Šè§’(x,y) åˆ°å³ä¸‹è§’(x,y)éƒ½åŠ value,ä¹Ÿå¯ä»¥ä½¿ç”¨å·®åˆ†æ ‡è®°å®ç° å·®åˆ†æ ‡è®° å¯¹äºäºŒä½å·®åˆ†åŒºé—´ä¿®æ”¹ï¼š[(xi,yi),(xj,yj)]+valued[xi][yi]+value, d[xj+1][yi]-value, d[xi][yj+1]-value, d[xj+1][yj+1]+value åŸç†å¦‚å›¾ï¼š æ¿å­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m,cnt=0; int a[N][N]; int prefix[N][N]; int d[N][N]; // å·®åˆ†æ ‡è®° &amp;&amp;åˆå§‹åŒ–å·®åˆ†çŸ©é˜µ void add(int x1, int y1, int x2, int y2,int value){ d[x1][y1]+=value; d[x2+1][y1]-=value; d[x1][y2+1]-=value; d[x2+1][y2+1]+=value; } int main(){ cin &gt;&gt; n &gt;&gt;m &gt;&gt; cnt; // è¾“å…¥æ¯ä¸ªæ•°å¹¶è®¡ç®—å·®åˆ†çŸ©é˜µ for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; add(i,j,i,j,a[i][j]); } } // è¿›è¡Œå·®åˆ†æ ‡è®° for (int i = 1; i &lt;=cnt;i++){ int x1,y1,x2,y2,value; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2&gt;&gt;value; add(x1,y1,x2,y2,value); } // å¯¹å·®åˆ†æ•°ç»„è¿›è¡Œä¸€æ¬¡å‰ç¼€å’Œå¾—åˆ°ç»“æœ for (int i = 1 ;i &lt;=n;i++){ for (int j = 1;j &lt;=m;j++){ a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + d[i][j]; } } for (int i = 1;i &lt;= n; i++){ for (int j = 1; j &lt;= m; j++){ cout &lt;&lt; a[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Containers","slug":"CS61Aâ€”â€”Containers","date":"2025-02-25T08:44:27.451Z","updated":"2025-02-25T08:45:19.402Z","comments":true,"path":"2025/02/25/CS61Aâ€”â€”Containers/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Containers/","excerpt":"","text":"Containers Slicing åˆ‡ç‰‡å¯ä»¥ç®€æ´çš„è·å–åˆ—è¡¨ä¸­çš„å­åˆ—è¡¨ï¼Œå®è´¨æ˜¯åˆ›å»ºäº†æ–°çš„åˆ—è¡¨è€Œä¸å½±å“åŸå§‹åˆ—è¡¨ å¦‚åˆ—è¡¨odds = [3,5,7,9,11] odds[1:3] -&gt; [5,7] é»˜è®¤ä¹Ÿæ˜¯åŒ…æ‹¬èµ·å§‹å€¼ä¸åŒ…æ‹¬ç»“æŸå€¼ odds[:3] -&gt; [3,5,7] çœç•¥å¼€å¤´å°†ä»åˆ—è¡¨å¤´å¼€å§‹ç®—èµ· odds[1:] -&gt; [5,7,9,11] çœç•¥ç»“å°¾å°†è¦†ç›–è‡³åˆ—è¡¨å°¾ å†…ç½®å‡½æ•° sum sum(&lt;å¯è¿­ä»£å¯¹è±¡&gt;, [èµ·å§‹å€¼]) è¿”å›æ‰€æœ‰å¯è¿­ä»£å…ƒç´ å’Œå¹¶åŠ ä¸Šèµ·å§‹å€¼ï¼Œèµ·å§‹å€¼é»˜è®¤ä¸º0 sumè¿˜å¯ä»¥å®ç°åˆ—è¡¨ç›¸åŠ ï¼šsum([[2,3],[4]],[]) æ³¨æ„èµ·å§‹å€¼ç±»å‹è¦å’Œå‰é¢ç›¸åŒ max max(&lt;å¯è¿­ä»£å¯¹è±¡&gt;, [é”®å‡½æ•°]) max(a,b,c,..., [é”®å‡½æ•°]) è¿”å›å¯¹è±¡ä¸­çš„æœ€å¤§å€¼æˆ–è¿”å›è‹¥å¹²å€¼ä¸­çš„æœ€å¤§å€¼ é”®å‡½æ•°ï¼šè€ƒè™‘å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œé”®å‡½æ•°å¹¶æ ¹æ®è¿”å›å€¼æ¯”è¾ƒå¤§å°ï¼ˆè¿”å›åŸå§‹å€¼ï¼‰ e.g. max(range(10), key=lambda x: 7-(x-4)*(x-2)) all all(&lt;å¯è¿­ä»£å¯¹è±¡&gt;) å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œbool(x)æ“ä½œï¼Œè‹¥æ‰€æœ‰å…ƒç´ éƒ½è¿”å›Trueåˆ™è¿”å›Trueï¼Œå¦åˆ™è¿”å›Falseï¼Œç©ºåˆ—è¡¨è¿”å›True e.g. all([x&lt;5 for x in range(5)]) è¿”å›True len len(&lt;å¯è¿­ä»£å¯¹è±¡&gt;) è·å–æŸä¸ªåºåˆ—é•¿åº¦ æœ‰å…³string stringå¯ä»¥ç”¨äºè¡¨ç¤ºï¼šæ•°æ®ã€è¯­è¨€ã€ç¨‹åº è¡¨ç¤ºå­—ç¬¦ä¸² ä½¿ç”¨å•å¼•å· ä½¿ç”¨åŒå¼•å· ä½¿ç”¨ä¸€å¯¹è¿ç»­çš„ä¸‰ä¸ªåŒå¼•å·ï¼šå¯ä»¥è·¨è¡Œ stringä¹Ÿæ˜¯ä¸€ç§sequence æ±‚è§£é•¿åº¦ä¸é€‰æ‹©å…ƒç´ ä¸åˆ—è¡¨ç›¸åŒ è·å–åˆ°çš„stringä¸­çš„å…ƒç´ æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½†åªæœ‰å®ƒæœ¬èº«ä¸€ä¸ªå…ƒç´  inä¸not inå¯ä»¥åœ¨å­—ç¬¦ä¸²ä¸­å¯»æ‰¾è¿ç»­å­—ç¬¦ e.g. 'here' in 'where's waldo? è¿”å›True Dictionary dictionaryç”¨äºå­˜å‚¨é”®å€¼å¯¹ï¼Œä½¿ç”¨èŠ±æ‹¬å·å’Œå†’å·åˆ†éš”é”®å€¼ åˆ›å»ºï¼š numerals = {'I':1, 'V':5, 'X':10} å¯ä»¥ç”¨æ•°å­—ï¼Œå­—ç¬¦ä¸²å½“é”®å€¼ï¼Œåˆ—è¡¨æˆ–å­—å…¸ å½“å€¼ æ³¨æ„ï¼šé”®æœ¬èº«ä¸èƒ½æ˜¯åˆ—è¡¨æˆ–å­—å…¸ï¼Œé”®ä¸èƒ½é‡å¤ æŸ¥æ‰¾ï¼š è¾“å…¥å¯¹åº”çš„é”®æ¥æŸ¥æ‰¾å¯¹åº”çš„å€¼ï¼Œä½†ä¸èƒ½é€šè¿‡å€¼æŸ¥æ‰¾é”® numerals['V'] &gt;&gt;&gt; 5 éå†ï¼š dictionaryæ˜¯é”®çš„åºåˆ—ï¼Œé€šè¿‡list()åˆ›å»ºåˆ—è¡¨å¯ä»¥è·å¾—æ‰€æœ‰çš„é”®ï¼Œå› æ­¤å¯ä»¥ç”¨forå¾ªç¯éå†æ‰€æœ‰çš„é”® ä½¿ç”¨numerals.value()è·å¾—å­—å…¸ä¸­æ‰€æœ‰çš„å€¼ï¼Œå­˜å‚¨åœ¨ä¸€ä¸ªåºåˆ—ä¸­ï¼ˆéåˆ—è¡¨ï¼‰ Dictionary Comprehensions å¯ä»¥ä½¿ç”¨è¡¨è¾¾å¼æ¥åˆ›å»ºåˆ—è¡¨ æ ¼å¼ï¼š{&lt;key exp&gt;: &lt;val exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;} è¿‡ç¨‹ï¼š æ·»åŠ ä»¥å½“å‰ä½œç”¨åŸŸä¸ºçˆ¶ä½œç”¨åŸŸçš„æ–°ä½œç”¨åŸŸ å»ºç«‹ä¸€ä¸ªç©ºçš„resultå­—å…¸å­˜å‚¨è¡¨è¾¾å¼çš„å€¼ å¯¹æ¯ä¸ªä¸­çš„å…ƒç´ ï¼š åœ¨æ–°ä½œç”¨åŸŸä¸­å°†ç»‘å®šåˆ°æ¯ä¸€ä¸ªå…ƒç´  è‹¥ä¸ºçœŸï¼Œåˆ™å°†ä¸é…å¯¹å¹¶æ·»åŠ åˆ°resultå­—å…¸ä¸­ e.g. {x*x: x for x in [1,2,3,4,5] if x&gt;2} ç»“æœä¸º{9:3, 16:4, 25:3}","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Sequence","slug":"CS61Aâ€”â€”Sequence","date":"2025-02-25T08:44:27.448Z","updated":"2025-02-25T07:38:25.423Z","comments":true,"path":"2025/02/25/CS61Aâ€”â€”Sequence/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence Lists åˆ—è¡¨æ˜¯pythonä¸­çš„å†…ç½®æ•°æ®ç±»å‹ ä½¿ç”¨[]åˆ›å»ºåˆ—è¡¨ ä½¿ç”¨èµ‹å€¼è¯­å¥å‘½ååˆ—è¡¨ ä½¿ç”¨name[ä¸‹æ ‡]è®¿é—®åˆ—è¡¨å…ƒç´ (0-index)ï¼Œæˆ–ä½¿ç”¨getitem( ,)(operatoræ¨¡å—)æ¥è®¿é—®å…ƒç´  ä½¿ç”¨len()å‡½æ•°è·å–å…ƒç´ ä¸ªæ•° name[ä¸‹æ ‡]æ˜¯ä¸€ç§å…ƒç´ è¯„ä¼°è¡¨è¾¾å¼ï¼Œå¯ä»¥ä¾æ¬¡è¯„ä¼°ä¸‹æ ‡å¯¹åº”å…ƒç´  åˆ—è¡¨ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯è¡¨è¾¾å¼ï¼Œæ­¤æ—¶åˆ—è¡¨ä¸­çš„å€¼å°†ç»‘å®šä¸ºè¡¨è¾¾å¼çš„ç»“æœ digits = [2//2,2+2,2,2*2] åˆ—è¡¨é—´å¯ä»¥ç›¸åŠ ä¸ç›¸ä¹˜ï¼ˆè¿ç®—ç¬¦æˆ–å‡½æ•°ï¼‰ [2,7]+[1,8,2,8]*2 == [2,7,1,8,2,8,1,8,2,8] åˆ—è¡¨ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼ŒåŒ…æ‹¬åˆ—è¡¨ 12pairs = [[10,20],[30,40]] pairs[1][0] # ç»“æœæ˜¯30 inè¿ç®—ç¬¦ inè¿ç®—ç¬¦å¯ä»¥åˆ¤æ–­æŸå…ƒç´ æ˜¯å¦å­˜åœ¨äºåˆ—è¡¨ä¸­ not in è¿ç®—ç¬¦å¯ä»¥åˆ¤æ–­æŸå…ƒç´ æ˜¯å¦ä¸å­˜åœ¨äºåˆ—è¡¨ä¸­ è¿”å›å€¼ä¸ºTrue æˆ– False è¿™ä¸¤ä¸ªè¿ç®—ç¬¦å¯»æ‰¾çš„æ˜¯å•ç‹¬å…ƒç´ ï¼Œè€Œéå­åºåˆ— e.g. 123456789digits = [1,8,2,8] &gt;&gt;&gt; 1 in digits True &gt;&gt;&gt; '1' in digits False &gt;&gt;&gt; [1,2] in [[1,2],3,4] True &gt;&gt;&gt; [1,2] in [[[1,2],3],4] False For Statement æ‰§è¡Œè¿‡ç¨‹ 12for &lt;name&gt; in &lt;expression&gt;: &lt;suite&gt; æ‰§è¡Œï¼Œè¯¥è¡¨è¾¾å¼å¿…é¡»æ˜¯ä¸€ä¸ªå¯è¿­ä»£çš„é‡ï¼ˆå¦‚ä¸€ä¸ªåºåˆ—ï¼‰ å¯¹åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼ŒæŒ‰åºè¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š åœ¨å½“å‰ä½œç”¨åŸŸä¸­å°†æ¯ä¸ªå…ƒç´ èµ‹ç»™ æ‰§è¡Œè¯­å¥å—ä¸­çš„è¯­å¥ ### åºåˆ—è§£åŒ… e.g.å¯»æ‰¾åºåˆ—ä¸­ç›¸åŒå…ƒç´ çš„æ•°å¯¹ pairs = [[1,2],[2,2],[3,2],[4,4]] 123for x, y in paris: if x==y: same_count+=1 è¯¥å¾ªç¯ä¸­ï¼Œforå¾ªç¯ä¼šè‡ªåŠ¨å°†parisä¸­çš„å†…å±‚åˆ—è¡¨ä¸­çš„ä¸¤ä¸ªå…ƒç´ èµ‹ç»™x,yä¸¤ä¸ªå˜é‡ Ranges rangeæ˜¯è¡¨ç¤ºè¿ç»­æ•´æ•°çš„åºåˆ—ï¼Œé€šè¿‡ç»™å‡ºèµ·å§‹ä¸ç»“æŸå€¼è·å¾—èŒƒå›´å†…çš„æ•´æ•° rangeåŒ…æ‹¬èµ·å§‹å€¼è€Œä¸åŒ…æ‹¬ç»“æŸå€¼ ç”¨æ³•ï¼šrange(&lt;èµ·å§‹å€¼(é»˜è®¤ä¸º0)&gt;, &lt;ç»“æŸå€¼&gt;, [æ­¥é•¿]) ä½œç”¨ï¼š è®¡ç®—é•¿åº¦ï¼šç»“æŸå€¼-èµ·å§‹å€¼ é€‰æ‹©å…ƒç´ ï¼šèµ·å§‹å€¼+index ä½œä¸ºè®¡æ•°å™¨ï¼šç”¨_ç­‰å½“ä½œnameè€Œä¸å®é™…ä½¿ç”¨å®ƒ è½¬æ¢åˆ—è¡¨ï¼šä½¿ç”¨list() - åˆ—è¡¨æ„é€ å‡½æ•° List Comprehension åˆ—è¡¨ä¸­å¯ä»¥å†™ä¸€äº›è¯­å¥æ¥æ„é€ åˆ—è¡¨ e.g.1 12345&gt;&gt;&gt; odds = [1,3,5,7,9] &gt;&gt;&gt; [x+1 for x in odds] [2,4,6,8,10] &gt;&gt;&gt; [x for x in odds if 25%x == 0] [1,5] e.g.2 æŸ¥æ‰¾æŸä¸ªæ•°çš„å› æ•° 12def divisors(n): return [1]+[x for x in range(2,n) if n%x==0]","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Homework3","slug":"CS61Aâ€”â€”Homework3","date":"2025-02-05T08:58:25.385Z","updated":"2025-02-05T09:00:31.656Z","comments":true,"path":"2025/02/05/CS61Aâ€”â€”Homework3/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Homework3/","excerpt":"","text":"Homework 3 Q1: Num Eights ç”¨é€’å½’å‡½æ•°æ±‚ä¸€ä¸ªæ•°ä¸­æœ‰å‡ ä½8 12345678910111213141516171819202122232425262728def num_eights(n): \"\"\"Returns the number of times 8 appears as a digit of n. &gt;&gt;&gt; num_eights(3) 0 &gt;&gt;&gt; num_eights(8) 1 &gt;&gt;&gt; num_eights(88888888) 8 &gt;&gt;&gt; num_eights(2638) 1 &gt;&gt;&gt; num_eights(86380) 2 &gt;&gt;&gt; num_eights(12345) 0 &gt;&gt;&gt; num_eights(8782089) 3 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all assignment statements &gt;&gt;&gt; check(HW_SOURCE_FILE, 'num_eights', ... ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'For', 'While']) True \"\"\" if n==0: return 0 else: if n%10 ==8: return num_eights(n//10)+1 else: return num_eights(n//10) é€’å½’å‡ºå£ï¼šæ¯ä¸€ä½éƒ½å‡å®Œån==0æ—¶ æ¯æ¬¡è¿”å›æ—¶é€’å½’è°ƒç”¨è‡ªèº«ï¼Œä¼ å…¥æœªåˆ¤æ–­çš„éƒ¨åˆ† è‹¥å‘ç°è¯¥ä½æ˜¯8ï¼Œåˆ™è¿”å›å€¼åŠ ä¸€ï¼Œå¦åˆ™ä¸å˜ Q2: Digit Distance ç”¨é€’å½’å‡½æ•°æ±‚æ¯ä¸¤ä½çš„å·®çš„ç»å¯¹å€¼ä¹‹å’Œ 12345678910111213141516171819202122232425def digit_distance(n): \"\"\"Determines the digit distance of n. &gt;&gt;&gt; digit_distance(3) 0 &gt;&gt;&gt; digit_distance(777) 0 &gt;&gt;&gt; digit_distance(314) 5 &gt;&gt;&gt; digit_distance(31415926535) 32 &gt;&gt;&gt; digit_distance(3464660003) 16 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all loops &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance', ... ['For', 'While']) True \"\"\" if n&lt;10: return 0 else: res,last = n//10,n%10 sec_last = res%10 return digit_distance(res)+abs(sec_last-last) é€’å½’å‡ºå£ï¼šå½“æŸ¥åˆ°æœ€åä¸€ä½æ—¶ç»å¯¹å€¼ä¸º0ï¼Œè¿”å›0 å¦åˆ™å°†æœ€åä¸€ä½ä¸å€’æ•°ç¬¬äºŒä½å–å‡ºï¼Œå°†å–å®Œæœ€åä¸€ä½çš„å‰©ä½™éƒ¨åˆ†ä¼ å…¥é€’å½’å‡½æ•°ç»§ç»­åˆ¤æ–­ï¼Œè¿”å›å€¼åŠ ä¸Šä¸¤ä½æ•°ç»å¯¹å€¼ä¹‹å·® Q3: Interleaved Sum å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¦æ±‚å¯¹1-nä¸­çš„æ‰€æœ‰å¥‡æ•°ä¼ å…¥odd_funcï¼Œæ‰€æœ‰å¶æ•°ä¼ å…¥even_funcï¼Œè¿”å›æ‰€æœ‰æ•°è®¡ç®—åå’Œ 123456789101112131415161718192021222324252627def interleaved_sum(n, odd_func, even_func): \"\"\"Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up to n. &gt;&gt;&gt; identity = lambda x: x &gt;&gt;&gt; square = lambda x: x * x &gt;&gt;&gt; triple = lambda x: x * 3 &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1 + 2*2 + 3 + 4*4 + 5 29 &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2 + 3*3 + 4 + 5*5 41 &gt;&gt;&gt; interleaved_sum(4, triple, square) # 1*3 + 2*2 + 3*3 + 4*4 32 &gt;&gt;&gt; interleaved_sum(4, square, triple) # 1*1 + 2*3 + 3*3 + 4*3 28 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and % True \"\"\" def check_num(k): if k&gt;n: return 0 elif k==n: return odd_func(k) else: return check_num(k+2)+odd_func(k)+even_func(k+1) return check_num(1) ç”±äºé¢˜ç›®ä¸è®©ä½¿ç”¨å¾ªç¯ä¸å–æ¨¡è¿ç®—åˆ¤æ–­å¥‡å¶ï¼Œæˆ‘ä»¬åªèƒ½ä½¿ç”¨é€’å½’å‡½æ•° ç”±äºå¥‡æ•°ä¸å¶æ•°æ˜¯åˆ†å¼€çš„ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå¥‡æ•°+2=å¥‡æ•°ï¼Œå¥‡æ•°+1=å¶æ•° å› æ­¤æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå†…åµŒå‡½æ•°ï¼Œè®©ä¸€ä¸ªè®¡æ•°å˜é‡kä»1å¼€å§‹ï¼Œå°†kä¼ å…¥odd_funcï¼Œk+1ä¼ å…¥even_func ç„¶åé€’å½’è°ƒç”¨è¯¥å‡½æ•°ä»k+2å¼€å§‹ é€’å½’å‡ºå£å³k&gt;næˆ–k=nï¼ˆæ­¤æ—¶kä¸€å®šä¸ºå¥‡æ•°ï¼Œç›´æ¥ä¼ å…¥odd_funcå¹¶è¿”å›ï¼‰ Q4: Count Coins ç»™äºˆnåˆ€ä¹ï¼ŒæŠŠä»–åˆ†ä¸ºé¢å€¼åˆ†åˆ«ä¸º1åˆ€ä¹ï¼Œ5åˆ€ä¹ï¼Œ10åˆ€ä¹ï¼Œ25åˆ€ä¹çš„å››ç§è´§å¸ï¼Œè¾“å‡ºåˆ†æ³•æ•° 1234567891011121314151617181920212223242526272829def count_coins(total): \"\"\"Return the number of ways to make change using coins of value of 1, 5, 10, 25. &gt;&gt;&gt; count_coins(15) 6 &gt;&gt;&gt; count_coins(10) 4 &gt;&gt;&gt; count_coins(20) 9 &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar? 242 &gt;&gt;&gt; count_coins(200) 1463 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For']) True \"\"\" def cal(total,spl_coin): if total==0: return 1 elif total&lt;0: return 0 elif spl_coin==None: return 0 else: with_coin = cal(total-spl_coin,spl_coin) without_coin = cal(total,next_smaller_coin(spl_coin)) return with_coin+without_coin return cal(total,25) Q5: Towers of Hanoi å®ç°æ±‰è¯ºå¡”æ¸¸æˆå¹¶æè¿°æ¯æ¬¡ç§»åŠ¨è¿‡ç¨‹ 12345678910111213141516171819202122232425262728293031323334353637def move_stack(n, start, end): \"\"\"Print the moves required to move n disks on the start pole to the end pole without violating the rules of Towers of Hanoi. n -- number of disks start -- a pole position, either 1, 2, or 3 end -- a pole position, either 1, 2, or 3 There are exactly three poles, and start and end must be different. Assume that the start pole has at least n disks of increasing size, and the end pole is either empty or has a top disk larger than the top n start disks. &gt;&gt;&gt; move_stack(1, 1, 3) Move the top disk from rod 1 to rod 3 &gt;&gt;&gt; move_stack(2, 1, 3) Move the top disk from rod 1 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 3 &gt;&gt;&gt; move_stack(3, 1, 3) Move the top disk from rod 1 to rod 3 Move the top disk from rod 1 to rod 2 Move the top disk from rod 3 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 1 Move the top disk from rod 2 to rod 3 Move the top disk from rod 1 to rod 3 \"\"\" assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, \"Bad start/end\" def hanoi(n,start,mid,end): if n == 1: print_move(start, end) return else: hanoi(n - 1, start,end, mid) hanoi(1,start,mid,end) hanoi(n - 1, mid, start,end) return hanoi(n,start,6-start-end,end) è¯¦è§äº”ç‚¹ä¸ƒè¾¹è®²è§£è§†é¢‘","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Tree Recursion","slug":"CS61Aâ€”â€”Tree Recursion","date":"2025-02-05T08:57:40.975Z","updated":"2025-02-05T08:57:00.742Z","comments":true,"path":"2025/02/05/CS61Aâ€”â€”Tree Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Tree%20Recursion/","excerpt":"","text":"Tree Recursion Order of Recursive Calls e.g.1:Cascade 1234567def cascade(n): if n&lt;10: print(n) else: print(n) cascade(n//10) print(n) ç»“æœä¸º 12345678910&gt;&gt;&gt; cascade(12345) 12345 1234 123 12 1 12 123 1234 12345 é¦–å…ˆä¸€ç›´è°ƒç”¨cascadeåˆ°åº•ï¼Œè¿”å›Noneï¼Œä»è°ƒç”¨å…¥å£å‡ºæ¥åç»§ç»­æ‰§è¡Œcascadeä¸‹é¢çš„è¯­å¥ cascade è¿˜å¯ä»¥ç¼©çŸ­ä¸ºä»¥ä¸‹ 12345def cascade_short(n): print(n) if n&gt;10: cascade(n//10) print(n) e.g.2:Inverse Cascade 123456789101112def inverse_cascade(n): grow(n) print(n) shrink(n) def f_then_g(f,g,n): if n: f(n) g(n) grow = lambda n: f_then_g(grow,print,n//10) shrink = lambda n: f_then_g(print,shrink,n//10) growå…ˆè¿›è¡Œå¤„ç†ï¼Œæ¯æ¬¡å°†æ•°å­—ç¼©çŸ­ä¸€èŠ‚ï¼Œåˆ°è¾¾é€’å½’åº•éƒ¨åé€€å‡ºæ—¶ä¾¿æ˜¯ä»å°åˆ°å¤§ä¾æ¬¡è¾“å‡º shrinkå…ˆæ‰“å°å‡ºæ¥å½“å‰nï¼Œç„¶åå°†æ•°å­—ç¼©çŸ­ä¸€èŠ‚ï¼Œè¿™æ ·é€’å½’è¿‡ç¨‹ä¾¿å®ç°äº†ä»å¤§åˆ°å°ä¾æ¬¡è¾“å‡º Tree Recursion å½“é€’å½’å‡½æ•°å¯¹è‡ªèº«è°ƒç”¨è¶…è¿‡ä¸€æ¬¡æ—¶ï¼Œå‘ç”Ÿæ ‘å½¢é€’å½’ï¼Œäº§ç”Ÿæ ‘çŠ¶è¿‡ç¨‹ e.g.1 æ–æ³¢é‚£å¥‘æ•°åˆ— æ ‘å½¢æ–æ³¢é‚£å¥‘ 1234567def fib(n): if n==0: return 0 elif n==1: return 1 else: return fib(n-1)+fib(n-2) e.g.2 è®¡ç®—åˆ†åŒº å°†æ­£æ•´æ•°nåˆ†ä¸ºå¤§å°ä¸è¶…è¿‡mçš„åˆ†åŒºçš„æ–¹å¼æœ‰å¤šå°‘ç§ï¼Œå³nèƒ½ä»¥å¤šå°‘ç§æ–¹å¼è¡¨ç¤ºä¸ºé€’å¢çš„ä¸è¶…è¿‡méƒ¨åˆ†ä¹‹å’Œ e.g. count_partitions(6,4) æœ‰ä»¥ä¸‹å¯èƒ½ï¼š â€¦â€¦ åˆ†ä¸ºä¸¤ç§æƒ…å†µè€ƒè™‘ï¼š è‡³å°‘åˆ†ä¸€ä¸ª4 ä¸åˆ†4 è¿™æ ·æˆ‘ä»¬å¯ä»¥æŠŠé€’å½’é—®é¢˜æ‹†åˆ†ä¸ºä¸¤ä¸ªå°é—®é¢˜ï¼Œå°†ä¸¤ç§æƒ…å†µç›¸åŠ  count_partitions(2,4) count_partitions(6,3) ä»¥æ­¤ç±»æ¨ï¼Œcount_partitions(6,3)æŒ‰åŒæ ·æ–¹å¼è€ƒè™‘ï¼Œåˆ†3ä¸ä¸åˆ†3ï¼Œç›´åˆ°é€’å½’åº•éƒ¨ 1234567891011def count_partitions(n,m): if n==0: return 1 elif n&lt;0: return 0 elif m==0: return 0 else: with_m = count_partitions(n-m,m) without_m = count_partitions(n,m-1) return with_m+without_m","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Recursion","slug":"CS61Aâ€”â€”Recursion","date":"2025-02-05T08:57:40.973Z","updated":"2025-02-05T08:56:45.164Z","comments":true,"path":"2025/02/05/CS61Aâ€”â€”Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Recursion/","excerpt":"","text":"Recursion Recursive Functions å®šä¹‰ï¼šåœ¨å‡½æ•°ä½“ä¸­ç›´æ¥æˆ–é—´æ¥è°ƒç”¨è‡ªèº«çš„å‡½æ•°å«é€’å½’å‡½æ•° å³åœ¨æ‰§è¡Œå‡½æ•°ä½“æ—¶è¿˜ä¼šè°ƒç”¨è‹¥å¹²æ¬¡å‡½æ•°è‡ªèº« é€’å½’å‡½æ•°çš„ç»“æ„ï¼š defå¤´å®šä¹‰ æ¡ä»¶è¯­å¥ç”¨æ¥åˆ¤æ–­åŸºæœ¬æ¡ä»¶ï¼Œæ— é€’å½’è°ƒç”¨ï¼ˆé€’å½’å‡ºå£ï¼‰ é€’å½’æ¡ä»¶ç”¨æ¥é€’å½’è°ƒç”¨ åˆ¤æ–­é€’å½’æ˜¯å¦æ­£ç¡®ï¼š éªŒè¯åŸºæœ¬æ¡ä»¶ å°†é€’å½’å‡½æ•°çœ‹ä½œå‡½æ•°æŠ½è±¡ å‡è®¾f(n-1)æ­£ç¡®ï¼ŒéªŒè¯f(n)çš„æ­£ç¡®æ€§ e.g.1:ç”¨é€’å½’æ±‚å„ä½æ•°å­—å’Œ 1234567891011def split(n): \"\"\"æŠŠnåˆ†æˆæœ€åä¸€ä½ä¸å…¶ä»–ä½ä¸¤éƒ¨åˆ†\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"æ±‚å’Œå„ä½æ•°å­—\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last e.g.2:é˜¶ä¹˜ï¼ˆä½¿ç”¨diagramï¼‰ é˜¶ä¹˜ é€’å½’ä¸è¿­ä»£ é€’å½’ä¸è¿­ä»£ é€’å½’è½¬æ¢åˆ°è¿­ä»£ï¼šå¼„æ¸…éœ€è¦é€šè¿‡è¿­ä»£ä¿æŒçš„çŠ¶æ€ è¿­ä»£è½¬æ¢åˆ°é€’å½’ï¼šè¿­ä»£ä¿æŒçš„çŠ¶æ€å¯ä»¥é€šè¿‡å‚æ•°ä¼ é€’ äº’é€’å½’ï¼ˆMutual Recursionï¼‰ e.g. Luhn Algorithm æ”¹ç®—æ³•å¸¸ç”¨äºä¿¡ç”¨å¡ç­‰çš„æ ¡éªŒç è®¡ç®—ï¼Œæ­¥éª¤å¦‚ä¸‹ï¼š æ­¥éª¤ 1ï¼šåè½¬æ•°å­— ç®—æ³•é¦–å…ˆé€šè¿‡åè½¬æ‚¨æ­£åœ¨æ£€æŸ¥çš„æ•°å­—çš„æ•°å­—ã€‚ æ­¥éª¤ 2ï¼šæ¯éš”ä¸€ä¸ªæ•°å­—ç¿»å€ ä»å·¦ä¾§çš„ç¬¬ä¸€ä¸ªæ•°å­—å¼€å§‹ï¼ˆç”±äºåè½¬ï¼Œç°åœ¨æ˜¯åŸå§‹æ•°å­—çš„æœ€åä¸€ä¸ªæ•°å­—ï¼‰ï¼Œå¯¹æ¯ä¸ªç¬¬äºŒä¸ªæ•°å­—è¿›è¡Œç¿»å€ã€‚ æ­¥éª¤ 3ï¼šæ±‚ä¹˜ç§¯çš„æ•°å­—ä¹‹å’Œ å¦‚æœç¿»å€åçš„æ•°å­—å¤§äº 9ï¼Œåˆ™å°†ä¹˜ç§¯çš„æ•°å­—ç›¸åŠ ï¼ˆä¾‹å¦‚ï¼Œç¿»å€ 8 å¾—åˆ° 16ï¼Œå› æ­¤ç›¸åŠ  1 + 6 = 7ï¼‰ã€‚ æ­¥éª¤ 4ï¼šå°†æ‰€æœ‰æ•°å­—ç›¸åŠ  åœ¨ä¸Šè¿°æ“ä½œåï¼Œå°†æ‰€æœ‰æ•°å­—ç›¸åŠ ã€‚ æ­¥éª¤ 5ï¼šæ£€æŸ¥æ˜¯å¦èƒ½è¢« 10 æ•´é™¤ å¦‚æœæ€»å’Œèƒ½è¢« 10 æ•´é™¤ï¼ˆå³ä»¥ 0 ç»“å°¾ï¼‰ï¼Œåˆ™è¯¥æ•°å­—æ ¹æ® Luhn ç®—æ³•æ˜¯æœ‰æ•ˆçš„ã€‚å¦åˆ™ï¼Œå®ƒæ˜¯æ— æ•ˆçš„ã€‚ 1234567891011121314151617181920212223242526def split(n): \"\"\"æŠŠnåˆ†æˆæœ€åä¸€ä½ä¸å…¶ä»–ä½ä¸¤éƒ¨åˆ†\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"æ±‚å’Œå„ä½æ•°å­—\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last def luhn_sum(n): if n&lt;10: return n else: all_but_last, last = split(n) return luhn_sum_double(all_but_last)+last def luhn_sum_double(n): all_but_last, last = split(n) luhn_digit = sum_digits(2*last) if n&lt;10: return luhn_digit else: return luhn_sum(all_but_last)+luhn_digit è¿™é‡Œä½¿ç”¨äº’é€’å½’è®©åˆ†ç¦»å‡ºæ¥çš„æ•°å­—å¥‡æ•°ä½ä¸æ‰§è¡Œä¹˜äºŒæ“ä½œï¼Œå¶æ•°ä½æ‰§è¡Œä¹˜äºŒæ“ä½œ","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Functional Abstraction","slug":"CS61Aâ€”â€”Design","date":"2025-02-05T08:57:40.971Z","updated":"2025-02-05T08:57:28.693Z","comments":true,"path":"2025/02/05/CS61Aâ€”â€”Design/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Design/","excerpt":"","text":"Functional Abstraction Lambdaè¡¨è¾¾å¼æ‰€åœ¨çš„environmentå…³ç³» å¦‚ä¸‹ä¾‹å­ 12345a = 1 def f(g): a = 2 return lambda y:a*g(y) f(lambda y: a+y)(a) æ³¨æ„è¡Œ4ä¸è¡Œ5çš„lambdaå‡½æ•°çš„åŒºåˆ«ï¼š è¡Œ4çš„lambdaå‡½æ•°æ˜¯få‡½æ•°å†…å®šä¹‰çš„å‡½æ•°ï¼Œä»–çš„çˆ¶çº§ä¸ºfï¼Œå› æ­¤æ­¤æ—¶ä¼ å…¥çš„a=2 è¡Œ5çš„lambdaå‡½æ•°æ˜¯få‡½æ•°å¤–å®šä¹‰çš„å‡½æ•°ï¼Œä»–çš„çˆ¶çº§ä¸ºglobalï¼Œå› æ­¤æ­¤æ—¶ä¼ å…¥çš„a=1 Choosing Names ç»™å‡½æ•°æˆ–å˜é‡å‘½åæ—¶ï¼Œè¦æ³¨é‡ä¼ è¾¾æ„æ€ å‘½åéœ€è¦ä¼ è¾¾ä¸ä¹‹ç›¸å…³å€¼çš„æ„ä¹‰æˆ–ç›®çš„ å€¼çš„ç±»å‹æœ€å¥½è®°å½•åœ¨å‡½æ•°çš„docstringä¸­ å‡½æ•°åä¸€èˆ¬åŒ…æ‹¬å®ƒä»¬çš„ä½œç”¨ï¼Œè¡¨ç°æˆ–è¿”å›å€¼ ä¸ºä¸€äº›é‡å¤ä½¿ç”¨çš„å¤åˆè¡¨è¾¾å¼å‘½å å¦‚æœéœ€è¦æ³¨é‡Šä»£ç ï¼Œå‘½åå¯ä»¥é•¿ä¸€äº› å¦‚æœç”¨äºæ•°å­—ï¼Œæ•°å­¦è¿ç®—ä¸å‡½æ•°æŠ½è±¡ï¼Œå‘½åå¯ä»¥çŸ­ä¸€äº› Error&amp;Traceback æŠ¥é”™æœ‰ä¸‰ç§å½¢å¼ï¼š Syntax errorsï¼šæ‰§è¡Œå‰å³å¯å‘ç°ï¼Œé€šå¸¸ç”±äºè¡¨è¾¾å¼ä¸æ­£ç¡®å¼•èµ· Runtime errorsï¼šæ‰§è¡Œæ—¶ç”±pythonè§£é‡Šå™¨å‘ç°çš„é”™è¯¯ã€‚å½“è¿™äº›é”™è¯¯å‘ç”Ÿæ—¶ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªTracebackï¼Œæ¥æç¤ºæ˜¯åœ¨å“ªé‡Œå‘ç”Ÿäº†ä½•ç§é”™è¯¯ï¼Œé”™è¯¯å‘ç”Ÿæ—¶ç¨‹åºåœ¨åšä»€ä¹ˆ Logical errorï¼šä¸ä¼šè¢«è§£é‡Šå™¨å‘ç°ï¼Œéœ€è¦è‡ªå·±è¿›è¡Œæµ‹è¯•å‘ç°é—®é¢˜ Decorator è£…é¥°å™¨ç”¨äºç»™ç°æœ‰æ¨¡å—ï¼ˆåŸå‡½æ•°ï¼‰è¿›è¡ŒåŠŸèƒ½æ‹“å±•ï¼Œé€šè¿‡æ¥å—ä¸€ä¸ªå‡½æ•°æ¥è¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°æˆ–ä¿®æ”¹åŸæ¥çš„å‡½æ•° ä¾‹å¦‚ï¼š 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced @trace1 def square(x): return x*x ç­‰åŒäº 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced def square(x): return x*x square = trace1(square) è¿”å›å€¼éƒ½ç›¸åŒ 123&gt;&gt;&gt; square(5) Calling &lt;function square at 0x000001C1247A9240&gt; on argument 5 25","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€ç®—æ³•ã€‘KMP","slug":"KMP","date":"2025-02-03T13:17:16.129Z","updated":"2025-02-03T13:18:42.295Z","comments":true,"path":"2025/02/03/KMP/","permalink":"https://izayoisakuye.github.io/2025/02/03/KMP/","excerpt":"","text":"KMP ç»™äºˆä¸»ä¸²Sä¸æ¨¡å¼ä¸²Pï¼Œå¯»æ‰¾æ¨¡å¼ä¸²åœ¨ä¸»ä¸²ä¸­æ˜¯å¦å‡ºç°è¿‡ä»¥åŠå‡ºç°ä½ç½® åŒ¹é…è¿‡ç¨‹ è®¾ä¸»ä¸²Sï¼šabcxabcdabxabcdabcdabcyï¼Œæ¨¡å¼ä¸²Pï¼šabcdabcy æ„å»ºNextæ•°ç»„ é’ˆå¯¹æ¨¡å¼ä¸²Pï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªNextæ•°ç»„ï¼ŒNext[i]æŒ‡P[0â€¦i]çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ å¦‚ä¾‹å­ä¸­Pçš„Nextæ•°ç»„ä¸º0 0 0 0 1 2 3 0 ï¼Œå¦‚ä¸‹è¡¨ ä¸‹æ ‡ 1 2 3 4 5 6 7 8 å­—ç¬¦ä¸² a b c d a b c y å‰åç¼€ a ab abc abcd abcda abcdab abcdabc abcdabcy æœ€é•¿å…¬å…±å‰åç¼€ / / / / a ab abc / Next[i] 0 0 0 0 1 2 3 0 è®©ä¸¤ä¸ªæŒ‡é’ˆjï¼ŒiæŒ‡å‘På¤´ï¼Œè®©ié€ä¸ªç§»åŠ¨ï¼Œä¸jæ‰€æŒ‡çš„æ¯”è¾ƒï¼Œè‹¥ä¸åŒï¼Œåˆ™jè·³è½¬åˆ°è¯¥ä½çš„å‰ä¸€ä½Nextæ•°ç»„å€¼å¯¹åº”çš„ä¸‹æ ‡ï¼Œè¯¥ä½Nextæ•°ç»„å€¼ä¸º0ï¼›è‹¥ç›¸åŒï¼Œåˆ™jå‘å³ç§»åŠ¨ä¸€ä½ï¼Œè¯¥ä½Nextæ•°ç»„å€¼ä¸ºç§»åŠ¨åçš„jå€¼ï¼ˆå³Next[i]=++jï¼‰ æ€§è´¨ï¼ši+1-Next[i]ä¸ºå‰ç¼€å¾ªç¯èŠ‚çš„å¤§å° æˆ–æŠŠPä¸Såˆå¹¶æˆä¸€ä¸ªä¸²ï¼Œç®—å‡ºNextæ•°ç»„å€¼ï¼Œè‹¥æŸä½å€¼nç­‰äºPçš„é•¿åº¦ï¼Œè¯´æ˜æ‰¾åˆ°äº†å’ŒPåŒ¹é…çš„å­—ä¸²ï¼Œå› ä¸ºè¯¥å¤„åˆå¹¶ä¸²çš„å‰åç¼€ç›¸åŒï¼Œè¯¥ä½ç½®å‘å‰né•¿åº¦çš„å­—ä¸²å³ä¸ºP åœ¨æ„é€ Nextæ•°ç»„æ—¶ï¼Œå‡å¦‚éœ€è¦è®¡ç®—Next[i]çš„å€¼ï¼Œæ­¤æ—¶å‰Next[i-1]ä½ç›¸ç­‰ï¼Œè®°ä¸ºlen-1ï¼Œè‹¥ä¸¤ä¾§å­—ä¸²åŠ ä¸Šç¬¬lenä¸ç¬¬iä½ï¼Œå­—ä¸²ä»ç›¸ç­‰ï¼Œåˆ™Next[i]=len+1ï¼Œè‹¥ä¸ç›¸ç­‰ï¼Œåˆ™å¯»æ‰¾ç¬¬äºŒé•¿çš„Nextï¼Œé‡å¤åˆ¤æ–­ç›´åˆ°æ‰¾åˆ°æœ€å°çš„Next(len=0) æœç´¢æ¨¡å¼ä¸² ç”¨ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸¤ä¸²å¤´ï¼Œé€ä¸ªåŒ¹é…ï¼Œå½“é‡åˆ°ä¸åŒå­—ç¬¦æ—¶ï¼ŒæŸ¥çœ‹è¯¥å­—ç¬¦å‰ä¸€ä¸ªå­—ç¬¦å¯¹åº”nextæ•°ç»„ä¸­çš„å€¼ï¼Œè®©æ¨¡å¼ä¸²æŒ‡é’ˆè·³åˆ°è¯¥å€¼å¯¹åº”çš„Pçš„ä¸‹æ ‡ä½ç½®ï¼Œç»§ç»­ä¸ä¸»ä¸²æŒ‡é’ˆé€ä¸ªåŒ¹é… å½“æ‰¾åˆ°å¯¹åº”æ¨¡å¼ä¸²åœ¨ä¸»ä¸²å‡ºç°æ—¶ï¼Œé€šè¿‡i-len(p)+1è®¡ç®—èµ·å§‹ä½ç½® æ³¨æ„ï¼šæ•´ä¸ªåŒ¹é…è¿‡ç¨‹ä¸­ä¸»ä¸²æŒ‡é’ˆä¸ä¼šåé€€ï¼Œåªä¼šåœç•™ï¼›è€Œæ¨¡å¼ä¸²æŒ‡é’ˆæ ¹æ®nextæ•°ç»„åå¤æ¨ªæ¡ æ¿å­-1 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt; using namespace std; void Next_pre(string p, vector&lt;int&gt; &amp;Next){ for(int i = 1,j=0;i&lt;p.size();i++){ // iæ˜¯å½“å‰éå†åˆ°çš„åç¼€ while(j&amp;&amp;p[i]!=p[j]) j=Next[j-1]; // ä¸¤æŒ‡é’ˆæŒ‡å‘ä¸åŒæ—¶æŒ‰Nextä¸­å€¼è·³è½¬ç›´åˆ°è·³åˆ°0 if(p[i]==p[j])j++; // å‰åç¼€ä¸€æ ·æ—¶ï¼Œå‰ç¼€å‘åç§»åŠ¨ Next[i]=j; } } int kmp(string s,string p,int begin){ // beginè¡¨ç¤ºä»å“ªé‡Œå¼€å§‹åŒ¹é… vector&lt;int&gt; Next(p.size()); Next_pre(p,Next); for(int i = begin,j=0;i&lt;s.size();i++){ while(j&amp;&amp;s[i]!=p[j]) j=Next[j-1]; // ä¸¤æŒ‡é’ˆæŒ‡å‘ä¸åŒæ—¶æŒ‰Nextä¸­å€¼è·³è½¬ç›´åˆ°è·³åˆ°0 if (s[i]==p[j])j++; // å‰åç¼€ä¸€æ ·æ—¶ï¼Œå‰ç¼€å‘åç§»åŠ¨ if (j==p.size()){ // åŒ¹é…æˆåŠŸåçš„æ“ä½œ // è¯¥éƒ¨åˆ†æ“ä½œæŒ‰é¢˜ç›®è¦æ±‚ return i-p.size()+1; } } return -1; } int main(){ string s,p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; kmp(s,p,0); return 0; } æ¿å­-2 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt; using namespace std; int kmp(string s,string p){ int n = s.size(); int m = p.size(); string mer = p+'#'+s; vector&lt;int&gt; Next(mer.size()); for (int i = 1;i&lt;mer.size();i++){ int len = Next[i-1]; while(len&amp;&amp;mer[i]!=mer[len]) len = Next[len-1]; if (mer[i]==mer[len]){ Next[i]=len+1; if (Next[i]==m){ return i-m*2; } } } return -1; } int main(){ string s,p; cin &gt;&gt; s&gt;&gt;p; cout &lt;&lt; kmp(s,p); return 0; }","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘å­—å…¸æ ‘","slug":"å­—å…¸æ ‘","date":"2025-02-01T09:02:16.436Z","updated":"2025-02-03T13:18:56.752Z","comments":true,"path":"2025/02/01/å­—å…¸æ ‘/","permalink":"https://izayoisakuye.github.io/2025/02/01/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"å­—å…¸æ ‘(trie) ç»™äºˆnä¸ªå•è¯ï¼Œåœ¨è¿™nä¸ªå•è¯ä¸­æŸ¥è¯¢ç»™å®šçš„å•è¯æ˜¯å¦å­˜åœ¨ éå† ä½¿ç”¨stringéå†æ¯ä¸€ä¸ªå•è¯æ¯”è¾ƒï¼Œs1==s2ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼Œmä¸ºå•è¯é•¿åº¦ è‹¥è¯¢é—®qæ¬¡ï¼Œåˆ™å¤æ‚åº¦é«˜è¾¾ å­—å…¸æ ‘ å­—å…¸æ ‘æ˜¯ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šå­˜å‚¨äº†ä¸€ä¸ªå­—ç¬¦ æ ‡çº¢çš„èŠ‚ç‚¹è¡¨ç¤ºå­˜åœ¨ä¸€ä¸ªä»¥è¯¥èŠ‚ç‚¹å­—ç¬¦ç»“å°¾çš„å­—ç¬¦ä¸² å¯ä»¥å‘ç°ï¼Œä»¥æŸä¸ªå­—ç¬¦ç»“å°¾çš„å­—ç¬¦ä¸²åœ¨trieæ ‘ä¸Šæ˜¯å”¯ä¸€çš„ï¼Œå› ä¸ºè¯¥èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œæ²¿ç€å¾€ä¸Šå³å¯è·å¾—å”¯ä¸€çš„å­—ç¬¦ä¸²ã€‚ è¿˜å¯ä»¥å‘ç°ï¼Œè‹¥æŒ‰ç…§å‰åºéå†ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å­—ç¬¦æ˜¯æŒ‰å­—å…¸åºæ’åˆ—çš„ï¼Œæ•…trieæ ‘è¿˜å¯ä»¥ç”¨äºæ’åº å»ºæ ‘ å»ºç«‹ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå°†å­—ç¬¦ä¸²æ¯ä¸€ä¸ªå­—ç¬¦ä¾æ¬¡ä»æ ¹èŠ‚ç‚¹æ’å…¥ï¼Œè‹¥å­˜åœ¨å¯¹åº”å­—ç¬¦èŠ‚ç‚¹ä¾¿æ²¿ç”¨ï¼Œå¦åˆ™åœ¨ä¸Šä¸ªçˆ¶èŠ‚ç‚¹åŸºç¡€ä¸Šæ–°å»ºèŠ‚ç‚¹ï¼Œä¼ å…¥ç»“å°¾ä½ç½®æ—¶æ ‡è®°ï¼ˆæ˜¯å¦ç»“å°¾æˆ–ç¬¬å‡ ä¸ªç›¸åŒå•è¯ï¼‰ æ—¶é—´å¤æ‚åº¦ è¯¢é—® å°†è¯»å…¥çš„å­—ç¬¦ä¸²ä»æ ¹èŠ‚ç‚¹å¼€å§‹ä¸€ä¸ªä¸ªå­—ç¬¦æ¯”å¯¹ï¼Œè‹¥æŸä¸ªå­—ç¬¦åœ¨åŒå±‚èŠ‚ç‚¹ä¸­éƒ½æ²¡æœ‰åˆ™ä¸å­˜åœ¨è¯¥å­—ç¬¦ä¸²ï¼Œè‹¥åˆ°è¾¾è¯¥å­—ç¬¦ä¸²æœ«å°¾ï¼Œä½†æ­¤æ—¶èŠ‚ç‚¹å¹¶æœªæ ‡è®°ç»“å°¾ä½ç½®ï¼Œä¹Ÿåˆ¤æ–­ä¸ºä¸å­˜åœ¨è¯¥å­—ç¬¦ä¸²ã€‚å¦åˆ™åˆ¤æ–­ä¸ºå­˜åœ¨ æ—¶é—´å¤æ‚åº¦ï¼šï¼Œxä¸ºæ¯æ¬¡è¯¢é—®å­—ç¬¦ä¸²é•¿åº¦ï¼Œå…±qæ¬¡è¯¢é—® åˆ é™¤ åˆ¤æ–­æ˜¯å¦æœ‰å­èŠ‚ç‚¹ è‹¥æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæ ‡è®°ä¸ä¸ºä¸€æ—¶-1ï¼Œä¸º1æ—¶é€’å½’åˆ é™¤åˆ°æ ¹èŠ‚ç‚¹ å­˜å‚¨ ç”¨æ•°ç»„è¡¨ç¤ºå±‚æ•°ï¼Œæ¯å±‚å†ç”¨æ•°ç»„è¡¨ç¤º26ä¸ªå­—ç¬¦åœ¨è¯¥å±‚å‡ºç°çš„æ¬¡æ•° ç¼ºç‚¹ï¼šè‹¥å­—ç¬¦å°‘å¯è¡Œï¼Œè‹¥å­—ç¬¦æ•°è¿‡å¤šï¼Œæˆ–æ¯å±‚åˆ†é…çš„èŠ‚ç‚¹è¿‡å¤šï¼Œå ç”¨ç©ºé—´ä¼šè¿‡å¤§ æ—¶é—´æ¢ç©ºé—´ï¼šä½¿ç”¨mapæˆ–unordered_mapï¼Œä½†æ—¶é—´å¤æ‚åº¦ä¼šå˜é«˜ æ¿å­ ç»“æ„ä½“å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; // å¼€è¾Ÿç©ºé—´ struct trieNode{ char val; trieNode** son; int cnt; trieNode(char c){ val = c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; // æ’å…¥æ“ä½œ void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c])p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; } p-&gt;cnt++; } // æŸ¥è¯¢æ“ä½œ int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main(){ root = new trieNode(' '); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } æ•°ç»„å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // å¼€è¾Ÿç©ºé—´ int trie[M][N]; int cnt[M]; int idx = 0; // æ’å…¥æ“ä½œ void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // æŸ¥è¯¢æ“ä½œ int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } mapå®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // å¼€è¾Ÿç©ºé—´ vector&lt;map&lt;char,int&gt;&gt; trie; // æˆ–ä½¿ç”¨unordered_map int cnt[M]; int idx = 0; // æ’å…¥æ“ä½œ void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // æŸ¥è¯¢æ“ä½œ int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ trie = vector&lt;map&lt;char,int&gt;&gt;(M); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } åº”ç”¨-æŸ¥è¯¢å‰ç¼€ é¢˜ç›®æè¿° ç»™å®š ä¸ªæ¨¡å¼ä¸² å’Œ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å®šä¸€ä¸ªæ–‡æœ¬ä¸² ï¼Œè¯·å›ç­” ä¸­æœ‰å¤šå°‘ä¸ªå­—ç¬¦ä¸² æ»¡è¶³ æ˜¯ çš„å‰ç¼€ã€‚ ä¸€ä¸ªå­—ç¬¦ä¸² æ˜¯ çš„å‰ç¼€å½“ä¸”ä»…å½“ä» çš„æœ«å°¾åˆ å»è‹¥å¹²ä¸ªï¼ˆå¯ä»¥ä¸º 0 ä¸ªï¼‰è¿ç»­çš„å­—ç¬¦åä¸ ç›¸åŒã€‚ è¾“å…¥çš„å­—ç¬¦ä¸²å¤§å°æ•æ„Ÿã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸² Fusu å’Œå­—ç¬¦ä¸² fusu ä¸åŒã€‚ è¾“å…¥æ ¼å¼ æœ¬é¢˜å•æµ‹è¯•ç‚¹å†…æœ‰å¤šç»„æµ‹è¯•æ•°æ®ã€‚ è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ•°æ®ç»„æ•° ã€‚ å¯¹äºæ¯ç»„æ•°æ®ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºæ¨¡å¼ä¸²çš„ä¸ªæ•° å’Œè¯¢é—®çš„ä¸ªæ•° ã€‚ æ¥ä¸‹æ¥ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ªæ¨¡å¼ä¸²ã€‚ æ¥ä¸‹æ¥ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€æ¬¡è¯¢é—®ã€‚ è¾“å‡ºæ ¼å¼ æŒ‰ç…§è¾“å…¥çš„é¡ºåºä¾æ¬¡è¾“å‡ºå„æµ‹è¯•æ•°æ®çš„ç­”æ¡ˆã€‚ å¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œè¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ æ•°ç»„å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 3e6 + 10; const int M = 70; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int trie[N][M]; int cnt[N]; int idx = 0; // charåˆ°intçš„è½¬æ¢ int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } // æ’å…¥æ“ä½œ void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!trie[p][c]) trie[p][c]=++idx; p=trie[p][c]; cnt[p]++; // è¿™é‡Œä¸æŸ¥è¯¢æ•´ä¸ªå•è¯ä¸åŒï¼Œéœ€è¦æ¯å±‚è®¡æ•° } } // è¯¢é—®æ“ä½œ int query(string s){ int p = 0; //int sum = 0; for (int i = 0;i&lt;s.size();i++){ int c =ascii(s[i]); if (!trie[p][c]) return 0; p=trie[p][c]; // sum+=cnt[p]; } return cnt[p]; } int main() { ios cin &gt;&gt; t; while(t--){ int n , q; cin &gt;&gt; n &gt;&gt; q; // æ¯æ¬¡æ¸…ç©ºä½¿ç”¨è¿‡çš„éƒ¨åˆ† for (int i = 0;i&lt;=idx;i++){ for (int j = 0;j&lt;=M;j++){ trie[i][j]=0; } } for(int i = 0;i&lt;=idx;i++){ cnt[i]=0; } idx = 0; for (int i = 0; i&lt;n;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;q;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s) &lt;&lt; endl; } } return 0; } ç¼ºç‚¹æ˜¯æ¯æ¬¡æŸ¥è¯¢åæ•°ç»„é‡ç½®æ—¶å®¹æ˜“TLEï¼Œè§£å†³æ–¹æ³•ä¸ºåªæ¸…ç©ºä½¿ç”¨çš„éƒ¨åˆ† ç»“æ„ä½“å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 63; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; struct trieNode{ char val; int cnt; trieNode** son; trieNode(char c){ val =c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; p-&gt;cnt++; } } int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main() { ios cin &gt;&gt; t; while(t--){ int n,q; cin &gt;&gt; n &gt;&gt; q; root = new trieNode(' '); while(n--){ string s; cin &gt;&gt; s; insert(s); } while(q--){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } } return 0; } ç¼ºç‚¹æ˜¯æ»¥ç”¨æŒ‡é’ˆå®¹æ˜“MLEï¼Œè§£å†³æ–¹æ³•ä¸ºNå¼€å°ä¸€ç‚¹ï¼ˆå·®ç‚¹ç‚¸çš„ç¨‹åº¦ï¼‰","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Lab2","slug":"CS61Aâ€”â€”Lab2","date":"2025-01-30T13:44:27.000Z","updated":"2025-01-30T14:56:07.204Z","comments":true,"path":"2025/01/30/CS61Aâ€”â€”Lab2/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Lab2/","excerpt":"","text":"WWPDéƒ¨åˆ†çœç•¥ Composite Identity Function é¢˜æ„ï¼šå†™ä¸€ä¸ªå‡½æ•°ï¼Œä¼ å…¥fä¸gä¸¤ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªå«æœ‰å‚æ•°xçš„å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦ç­‰äº 123456789101112131415def composite_identity(f, g): \"\"\" Return a function with one parameter x that returns True if f(g(x)) is equal to g(f(x)). You can assume the result of g(x) is a valid input for f and vice versa. &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 # squares x [returns x^2] &gt;&gt;&gt; b1 = composite_identity(square, add_one) &gt;&gt;&gt; b1(0) # (0 + 1) ** 2 == 0 ** 2 + 1 True &gt;&gt;&gt; b1(4) # (4 + 1) ** 2 != 4 ** 2 + 1 False \"\"\" return lambda x: f(g(x))==g(f(x)) æŒ‰ç…§é¢˜æ„è¿”å›ä¸€ä¸ªlambdaå‡½æ•°ï¼Œä¼ å…¥xå³å¯ Count Cond predicate function: è¿”å›Trueæˆ–Falseçš„å‡½æ•° é¢˜æ„ï¼šå†™ä¸€ä¸ªå‡½æ•°ï¼Œä¼ å…¥ä¸€ä¸ªä¸¤ä¸ªå‚æ•°çš„predicate function conditionï¼Œè¿”å›ä¸€ä¸ªå«æœ‰å‚æ•°nçš„å‡½æ•°ï¼Œåˆ¤æ–­1-nä¸­æœ‰å‡ ä¸ªæ•°æ»¡è¶³conditionå‡½æ•° 1234567891011121314151617181920212223242526272829303132def count_cond(condition): \"\"\"Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5) &gt;&gt;&gt; count_fives(10) # 50 (10 * 5) 1 &gt;&gt;&gt; count_fives(50) # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46) 4 &gt;&gt;&gt; is_i_prime = lambda n, i: is_prime(i) # need to pass 2-argument function into count_cond &gt;&gt;&gt; count_primes = count_cond(is_i_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 \"\"\" def judge(n): cnt = 0 for i in range(1,n+1): if condition(n,i): cnt+=1 return cnt return judge éå†1-nï¼Œä¼ å…¥conditionå‡½æ•°å¹¶è®¡æ•°å³å¯ æ³¨æ„è¿”å›çš„æ˜¯å‡½æ•°ï¼Œä¼ å…¥n Multiple é¢˜æ„ï¼šå†™ä¸€ä¸ªå‡½æ•°æ±‚å‚æ•°aï¼Œbçš„æœ€å°å…¬å€æ•° 12345678910111213def multiple(a, b): \"\"\"Return the smallest number n that is a multiple of both a and b. &gt;&gt;&gt; multiple(3, 4) 12 &gt;&gt;&gt; multiple(14, 21) 42 \"\"\" def gcd(a,b): if b==0: return a return gcd(b,a%b) return a*b//gcd(a,b) è¾—è½¬ç›¸é™¤æ³•æ±‚gcdï¼Œç”¨gcdæ±‚lcm I Heard You Liked Functionsâ€¦ é¢˜æ„ï¼šå®šä¹‰ä¸€ä¸ªå‡½æ•°ä¼ å…¥ä¸‰ä¸ªå‡½æ•°f1,f2,f3ï¼Œè¿”å›ä¸€ä¸ªå‚æ•°ä¸ºnçš„å‡½æ•°gï¼Œå‡½æ•°gè¿”å›ä¸€ä¸ªå‚æ•°ä¸ºxçš„å‡½æ•°h å‡½æ•°xå°†ä¼šå¾ªç¯ä¼ ç»™å‡½æ•°f1ï¼Œf2ï¼Œf3ï¼Œå…·ä½“å¦‚ä¸‹ï¼š n=0æ—¶è¿”å›xï¼Œn=1æ—¶è¿”å›f1(x)ï¼Œn=2æ—¶è¿”å›f2(f1(x))ï¼Œn=3æ—¶è¿”å›f3(f2(f1(x)))ï¼Œn=4æ—¶è¿”å›f1(f3(f2(f1(x))))ï¼Œä»¥æ­¤ç±»æ¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243def cycle(f1, f2, f3): \"\"\"Returns a function that is itself a higher-order function. &gt;&gt;&gt; def add1(x): ... return x + 1 &gt;&gt;&gt; def times2(x): ... return x * 2 &gt;&gt;&gt; def add3(x): ... return x + 3 &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3) &gt;&gt;&gt; identity = my_cycle(0) &gt;&gt;&gt; identity(5) 5 &gt;&gt;&gt; add_one_then_double = my_cycle(2) &gt;&gt;&gt; add_one_then_double(1) 4 &gt;&gt;&gt; do_all_functions = my_cycle(3) &gt;&gt;&gt; do_all_functions(2) 9 &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4) &gt;&gt;&gt; do_more_than_a_cycle(2) 10 &gt;&gt;&gt; do_two_cycles = my_cycle(6) &gt;&gt;&gt; do_two_cycles(1) 19 \"\"\" def g(n): def h(f,g): return lambda x: f(g(x)) if n==0: return lambda x : x elif n==1: return f1 else: temp = f1 i=2 while i&lt;=n: if i%3==1: temp= h(f1,temp) elif i%3==2: temp= h(f2,temp) else: temp= h(f3,temp) i+=1 return temp return g éå†1-nï¼Œæ¯æ¬¡å–æ¨¡3æ¥åˆ¤æ–­è¯¥å¥—å“ªä¸ªå‡½æ•°ï¼Œæ³¨æ„0å’Œ1æ—¶ç‰¹åˆ¤ï¼Œ2å¼€å§‹ä»f1å¾€å¤–å¥— å³æ‰§è¡Œé¡ºåºä¸º","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Hog","slug":"Project1-Hog","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:08.930Z","comments":true,"path":"2025/01/30/Project1-Hog/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project1-Hog/","excerpt":"","text":"Project1-Hog å®ç°ä¸€ä¸ªæ·éª°å­æ¸¸æˆ è§„åˆ™ ä¸¤ä½ç©å®¶ä¾æ¬¡æ·ä»»æ„æ•°é‡(ä¸å¤šäº10ä¸ª)éª°å­ï¼Œç‚¹æ•°ä¹‹å’Œå…ˆè¾¾åˆ°GOALçš„èƒœåˆ©ã€‚ Sow Sad: è‹¥å…¶ä¸­ä¸€ä¸ªéª°å­ç‚¹æ•°ä¸ºä¸€ï¼Œåˆ™è¯¥ç©å®¶æ­¤è½®å¾—åˆ†ä¸º1 Boar Brawl: ç©å®¶å¯ä»¥é€‰æ‹©ä¸æ·éª°å­ï¼Œå¾—åˆ†ä¸ºmax(1,3*abs(å¯¹æ‰‹å¾—åˆ†åä½æ•°-è‡ªå·±å¾—åˆ†ä¸ªä½æ•°))ï¼Œä½æ•°ä¸å¤Ÿè¡¥é›¶ã€‚ Sus Fuss: è‹¥ä¸€å±€ç»“æŸåï¼Œç©å®¶ç‚¹æ•°æ•°å€¼æœ‰ä¸‰æˆ–å››ä¸ªå› æ•°(åŒ…æ‹¬1å’Œç‚¹æ•°æœ¬èº«)ï¼Œè¯¥ç©å®¶ç‚¹æ•°ä¼šå˜ä¸ºæ¯”å½“å‰æ•°å€¼å¤§çš„æœ€è¿‘çš„ä¸€ä¸ªè´¨æ•° Phase 1: Rules of the Game æ¨¡æ‹Ÿæ¸¸æˆçš„è¿›è¡Œ Problem 0 ç†Ÿæ‚‰dice.pyï¼Œäº†è§£éª°å­çš„ç”Ÿæˆ make_fair_dice()ç”¨äºç”Ÿæˆæ¯é¢æ¦‚ç‡ç›¸ç­‰çš„SIDEé¢éª°å­ make_test_dice()ç”¨äºæµ‹è¯•å¾ªç¯æŠ•å‡ºä¸€ç³»åˆ—æŒ‡å®šå€¼ æ·å‡ºä¸€æ¬¡éª°å­çš„æ–¹æ³•ï¼šè°ƒç”¨ç”Ÿæˆéª°å­èµ‹å€¼ç»™çš„å˜é‡e.g. six_sided() Problem 1 å®ç°æ·éª°å­å‡½æ•°ï¼Œå¹¶å®ç°è§„åˆ™Sow Sad åœ¨å®šä¹‰å‡½æ•°æ—¶ï¼Œè‹¥å‡ºç°å½¢å‚åå·²ç»èµ‹å€¼çš„æƒ…å†µï¼Œè¯¥å€¼ä»£è¡¨è¯¥å‡½æ•°ä¸ä¼ å…¥å‚æ•°æ—¶å½¢å‚é»˜è®¤å€¼ å¦‚def roll_dice(num_rolls, dice=six_sided)ï¼Œè‹¥ä¸ä¼ å…¥diceå‚æ•°åˆ™é»˜è®¤ä¸ºsix_sided roll_dice()å‡½æ•°ï¼š å‚æ•°ï¼š num_rollsæŒ‡æ·éª°å­æ¬¡æ•° diceæŒ‡ä¼ å…¥çš„éª°å­ï¼ˆé»˜è®¤å€¼ä¸ºå…­é¢éª°å­ï¼‰ ç†è§£ï¼š è¯¥å‡½æ•°è¿”å›çš„æ˜¯num_rollæ¬¡ç»“æœä¹‹å’Œï¼Œè‹¥å…¶ä¸­æœ‰1åˆ™è¿”å›1 è‹¥ä¸Šæ¬¡è°ƒç”¨å‡½æ•°æ·éª°å­æ¬¡æ•°å°‘äºæ·éª°å­æ¬¡æ•°ï¼Œåˆ™ä¸‹æ¬¡æ·éª°å­æ—¶ä¼šæ¥ç€ä¸Šæ¬¡å¼€å§‹è€Œéä»å¤´å¼€å§‹ åœ¨å¾ªç¯ä¸­returnè¯­å¥ä¼šç»“æŸä¸€ä¸ªå¾ªç¯ My codeï¼š 1234567891011121314151617181920212223def roll_dice(num_rolls, dice=six_sided): \"\"\"Simulate rolling the DICE exactly NUM_ROLLS &gt; 0 times. Return the sum of the outcomes unless any of the outcomes is 1. In that case, return 1. num_rolls: The number of dice rolls that will be made. dice: A function that simulates a single dice roll outcome. Defaults to the six sided dice. \"\"\" # These assert statements ensure that num_rolls is a positive integer. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt; 0, 'Must roll at least once.' # BEGIN PROBLEM 1 total = 0 flag = 0 for i in range(num_rolls): temp = dice() if temp==1: flag = 1 total += temp if flag: return 1 else: return total # END PROBLEM 1 Problem 2 å®ç°è§„åˆ™Boar Brawl boar_brawl()å‡½æ•°ï¼š å‚æ•°ï¼š player_scoreï¼šè‡ªå·±çš„åˆ†æ•° opponent_scoreï¼šå¯¹æ‰‹çš„åˆ†æ•° ç†è§£ï¼š è·å–è‡ªå·±åˆ†æ•°çš„ä¸ªä½æ•°ä¸å¯¹æ‰‹åˆ†æ•°çš„åä½æ•° ç›¸å‡å¹¶å–ç»å¯¹å€¼åä¹˜ä¸‰ è‹¥å°äº1åˆ™è¾“å‡º1ï¼Œå¦åˆ™è¾“å‡ºè®¡ç®—ç»“æœ My codeï¼š 1234567891011121314151617def boar_brawl(player_score, opponent_score): \"\"\"Return the points scored by rolling 0 dice according to Boar Brawl. player_score: The total score of the current player. opponent_score: The total score of the other player. \"\"\" # BEGIN PROBLEM 2 player_one = player_score%10 opponent_ten = opponent_score%100//10 result = 3*abs(opponent_ten-player_one) if result&gt;=1: return result else: return 1 # END PROBLEM 2 æ³¨æ„ï¼šä¼ å…¥çš„å‚æ•°ä¸ä¸€å®šæ˜¯åä½æ•°ï¼Œéœ€è¦è¿›è¡Œä¸€äº›å¤„ç† Problem 3 å®ç°å‡½æ•°ï¼Œå°†å‰ä¸¤ä¸ªè§„åˆ™ç»“åˆï¼Œè¾“å‡ºæ­£ç¡®ç»“æœ take_turn()å‡½æ•°ï¼š å‚æ•°ï¼š num_rollsï¼šæ·éª°å­æ¬¡æ•° player_scoreï¼šè‡ªå·±çš„åˆ†æ•° opponent_scoreï¼šå¯¹æ‰‹çš„åˆ†æ•° diceï¼šä½¿ç”¨çš„éª°å­ ç†è§£ï¼š è‹¥num_rolls&gt;0ï¼Œåˆ™æŒ‰ç…§æ­£å¸¸è§„åˆ™è¿›è¡Œï¼Œè·å¾—æœ¬è½®æ·éª°ç‚¹æ•°ä¹‹å’Œ è‹¥num_rolls=0ï¼Œå³ä¸æ·éª°å­ï¼Œç­‰åŒäºé€‰æ‹©ä½¿ç”¨Boar Brawlè§„åˆ™ï¼Œæ‰§è¡Œè¯¥å‡½æ•° My codeï¼š 12345678910111213141516171819def take_turn(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the points scored on a turn rolling NUM_ROLLS dice when the player has PLAYER_SCORE points and the opponent has OPPONENT_SCORE points. num_rolls: The number of dice rolls that will be made. player_score: The total score of the current player. opponent_score: The total score of the other player. dice: A function that simulates a single dice roll outcome. \"\"\" # Leave these assert statements here; they help check for errors. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt;= 0, 'Cannot roll a negative number of dice in take_turn.' assert num_rolls &lt;= 10, 'Cannot roll more than 10 dice.' # BEGIN PROBLEM 3 if num_rolls==0: return boar_brawl(player_score,opponent_score) else: return roll_dice(num_rolls,dice) # END PROBLEM 3 Problem 4 å®ç°Sus Fussè§„åˆ™ num_factors()å‡½æ•°ï¼š å‚æ•°ï¼š nï¼šè¦è®¡ç®—çš„æ•°n ç†è§£ï¼š è¿”å›æ•°nçš„å› æ•°ä¸ªæ•° 1å’Œnæœ¬èº«ä¹Ÿç®—è¿›å» My codeï¼š 123456789def num_factors(n): \"\"\"Return the number of factors of N, including 1 and N itself.\"\"\" # BEGIN PROBLEM 4 total = 0 for i in range(1,n+1): if n%i==0: total+=1 return total # END PROBLEM 4 sus_points()å‡½æ•°ï¼š å‚æ•°ï¼š scoreï¼šæŸç©å®¶çš„åˆ†æ•° ç†è§£ï¼š è¯¥å‡½æ•°ç”¨äºæ›´æ–°ç©å®¶åœ¨Sus Fussè§„åˆ™ä¸‹æ–°çš„åˆ†æ•° å³ç”¨äºåˆ¤æ–­ç¬¦åˆæ¡ä»¶ä¸‹å¤§äºè¯¥åˆ†æ•°æ•°å€¼çš„ä¸‹ä¸€ä¸ªè´¨æ•° è‹¥è¯¥æ•°å€¼ä¸ç¬¦åˆæ¡ä»¶ï¼Œåˆ™è¿”å›æœ¬èº« My code: 1234567891011def sus_points(score): \"\"\"Return the new score of a player taking into account the Sus Fuss rule.\"\"\" # BEGIN PROBLEM 4 if num_factors(score)==3 or num_factors(score)==4: while True: score+=1 if is_prime(score): return score else: return score # END PROBLEM 4 sus_update()å‡½æ•°ï¼š å‚æ•°ï¼š num_rollsï¼šæ·éª°å­æ¬¡æ•° player_scoreï¼šè‡ªå·±çš„åˆ†æ•° opponent_scoreï¼šå¯¹æ‰‹çš„åˆ†æ•° diceï¼šä½¿ç”¨çš„éª°å­ ç†è§£ï¼š ç”¨äºè¾“å‡ºnum_rollsæ¬¡æ·éª°å­åï¼Œè€ƒè™‘ä»¥ä¸Šä¸‰ç§è§„åˆ™åçš„ç‚¹æ•°ä¹‹å’Œ ç°æ ¹æ®take_turn()å‡½æ•°æ±‚å‡ºæ»¡è¶³å‰ä¸¤ä¸ªè§„åˆ™çš„æœ¬è½®åˆ†æ•°ä¹‹å’Œï¼Œå¹¶ç´¯åŠ åˆ°å½“å‰åˆ†æ•°ä¸Š å†åˆ¤æ–­æ­¤æ—¶åˆ†æ•°æ˜¯å¦æ»¡è¶³ç¬¬ä¸‰ä¸ªè§„åˆ™ï¼Œè¿›è¡Œç›¸åº”åˆ†æ•°æ”¹åŠ¨ My code: 12345678def sus_update(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the total score of a player who starts their turn with PLAYER_SCORE and then rolls NUM_ROLLS DICE, *including* Sus Fuss. \"\"\" # BEGIN PROBLEM 4 score = player_score + take_turn(num_rolls, player_score, opponent_score, dice) return sus_points(score) # END PROBLEM 4 Problem 5 å®Œæ•´å®ç°æ¸¸æˆæ¨¡æ‹Ÿ play()å‡½æ•°ï¼š å‚æ•°ï¼š strategy0ï¼šplayer0ä½¿ç”¨çš„ç­–ç•¥ strategy1ï¼šplayer1ä½¿ç”¨çš„ç­–ç•¥ updateï¼šä½¿ç”¨çš„æ›´æ–°å‡½æ•°ï¼ˆæœ‰æ— susï¼‰ score0ï¼šplayer0çš„èµ·å§‹åˆ†æ•° score1ï¼šplayer1çš„èµ·å§‹åˆ†æ•° diceï¼šä½¿ç”¨çš„éª°å­ goalï¼šå®ç°æ¸¸æˆç»“æŸçš„æ•°å€¼ ç†è§£ï¼š strategyæŒ‡çš„æ˜¯ç©å®¶æ·éª°å­æ•°é‡ strategyå‡½æ•°ä¼ å…¥è‡ªå·±ä¸å¯¹æ‰‹çš„åˆ†æ•°ï¼Œæ ¹æ®ä¸¤è€…åˆ†æ•°å¾—å‡ºä¸‹æ¬¡æ·éª°å­æ•°é‡ ä½¿ç”¨ä¼ å…¥çš„updateå‡½æ•°æ¥å†³å®šåˆ†æ•°æ”¹å˜ç­–ç•¥ï¼ˆæ˜¯å¦é‡‡ç”¨sus fussè§„åˆ™ï¼‰ My codeï¼š 123456789101112131415161718192021222324252627282930313233343536def play(strategy0, strategy1, update, score0=0, score1=0, dice=six_sided, goal=GOAL): \"\"\"Simulate a game and return the final scores of both players, with Player 0's score first and Player 1's score second. E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in which both players always choose to roll 5 dice on every turn and the Sus Fuss rule is in effect. A strategy function, such as always_roll_5, takes the current player's score and their opponent's score and returns the number of dice the current player chooses to roll. An update function, such as sus_update or simple_update, takes the number of dice to roll, the current player's score, the opponent's score, and the dice function used to simulate rolling dice. It returns the updated score of the current player after they take their turn. strategy0: The strategy for player0. strategy1: The strategy for player1. update: The update function (used for both players). score0: Starting score for Player 0 score1: Starting score for Player 1 dice: A function of zero arguments that simulates a dice roll. goal: The game ends and someone wins when this score is reached. \"\"\" who = 0 # Who is about to take a turn, 0 (first) or 1 (second) # BEGIN PROBLEM 5 while score0&lt;goal and score1 &lt; goal: if who==0: score0 = update(strategy0(score0, score1), score0, score1, dice) else: score1 = update(strategy1(score1, score0), score1, score0, dice) who = 1 - who # END PROBLEM 5 return score0, score1 Phase 2: Strategies è¿™éƒ¨åˆ†å°†ä¼šæ ¹æ®è‡ªå·±ä¸å¯¹æ‰‹çš„åˆ†æ•°ç”Ÿæˆæ¯è½®ç©å®¶çš„æ·éª°æ•°ï¼ˆ0-10ï¼‰ Problem 6 è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè·å–è‡ªå·±ä¸å¯¹æ‰‹åˆ†æ•°å¹¶è¾“å‡ºæŒ‡å®šéª°å­ä¸ªæ•° ç†è§£ï¼š è¿”å›çš„æ˜¯å‡½æ•°ï¼Œæœ‰ä¸¤ä¸ªå‚æ•°ï¼šè‡ªå·±ä¸å¯¹æ‰‹åˆ†æ•° æ— è®ºä¸¤è€…åˆ†æ•°å¤šå°‘ï¼Œè¿”å›çš„æ€»æ˜¯ä¸€å¼€å§‹ä¼ å…¥çš„æŒ‡å®šéª°å­ä¸ªæ•° My codeï¼š 1234567891011121314151617def always_roll(n): \"\"\"Return a player strategy that always rolls N dice. A player strategy is a function that takes two total scores as arguments (the current player's score, and the opponent's score), and returns a number of dice that the current player will roll this turn. &gt;&gt;&gt; strategy = always_roll(3) &gt;&gt;&gt; strategy(0, 0) 3 &gt;&gt;&gt; strategy(99, 99) 3 \"\"\" assert n &gt;= 0 and n &lt;= 10 # BEGIN PROBLEM 6 return lambda x,y: n # END PROBLEM 6 Problem 7 åˆ¤æ–­æ¯ç§åˆ†æ•°ç»„åˆæ˜¯å¦éƒ½æœ‰ä¸€ç§å¯¹åº”çš„æ·éª°ä¸ªæ•°ï¼ˆåˆ†æ•°ç»„åˆæŒ‡ä¸€ç§è‡ªå·±ä¸å¯¹æ‰‹çš„åˆ†æ•°ï¼‰ is_always_roll()å‡½æ•°ï¼š å‚æ•°ï¼š strategyï¼šæ·éª°ç­–ç•¥ goalï¼šç©å®¶èƒœåˆ©è¦è¾¾åˆ°çš„ç›®æ ‡åˆ†æ•° ç†è§£ï¼š è‡ªå·±ä¸å¯¹æ‰‹çš„å¾—åˆ†åœ¨èƒœåˆ©ä¹‹å‰å¯èƒ½æ€§å‡æœ‰100ç§ï¼ˆ0-99ï¼‰ï¼Œæ•…å¯èƒ½æ€§ç»„åˆæœ‰10000ç§ è¯¥å‡½æ•°å®ç°äº†åˆ¤æ–­æ¯ç§å¯èƒ½æ€§ç»„åˆä¸‹è¿”å›çš„æ·éª°æ•°æ˜¯å¦ç›¸åŒ goalä¸ä¸€å®šæ˜¯100 My codeï¼š 12345678910111213141516171819def is_always_roll(strategy, goal=GOAL): \"\"\"Return whether STRATEGY always chooses the same number of dice to roll given a game that goes to GOAL points. &gt;&gt;&gt; is_always_roll(always_roll_5) True &gt;&gt;&gt; is_always_roll(always_roll(3)) True &gt;&gt;&gt; is_always_roll(catch_up) False \"\"\" # BEGIN PROBLEM 7 num = strategy(0,0) for i in range(0,goal): for j in range(0,goal): if strategy(i,j)!=num: return False return True # END PROBLEM 7 Problem 8 è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥è°ƒç”¨næ¬¡æ·éª°å‡½æ•°ï¼Œå¹¶è¿”å›è¿™næ¬¡æ·éª°å¾—åˆ°çš„å€¼ä¹‹å’Œçš„å¹³å‡å€¼ è¯­æ³•ç‰¹æ€§ï¼š*args *argså‚æ•°å…è®¸å‡½æ•°æ¥å—ä»»æ„æ•°é‡çš„ä½ç½®å‚æ•°ï¼Œä»¥å…ƒç»„å½¢å¼ä¼ å…¥ argså¯ä»¥æ”¹ä¸ºå…¶ä»–åç§°ï¼Œ*å¿…é¡»æœ‰ åº”ç”¨ï¼š å®šä¹‰çš„å‡½æ•°æ¥å—ä¸å®šæ•°é‡ä½ç½®å‚æ•°æ—¶ ç¼–å†™é«˜é˜¶å‡½æ•°ï¼ˆhigher-order functionï¼‰æ—¶ï¼Œä¼ é€’å‚æ•°ç»™å†…éƒ¨çš„å®šä¹‰çš„å‡½æ•° make_averaged()å‡½æ•° å‚æ•°ï¼š original_functionï¼šè°ƒç”¨çš„æ·éª°å‡½æ•° times_calledï¼šè°ƒç”¨æ¬¡æ•° ç†è§£ï¼š å‡½æ•°éœ€è¦åšåˆ°æ‰§è¡Œnæ¬¡æ·éª°å‡½æ•°ï¼Œå¹¶å°†è¿”å›å€¼ç´¯åŠ ï¼Œæœ€åæ±‚è¿™næ¬¡å’Œçš„å¹³å‡å€¼ åœ¨å†…è”å‡½æ•°ä¸­ä½¿ç”¨äº†*argsæ¥è¡¨ç¤ºè‹¥å¹²å‚æ•°ï¼Œä¸è°ƒå…¥çš„æ·éª°å‡½æ•°å‚æ•°æ•°é‡ä¸€è‡´ My codeï¼š 1234567891011121314151617181920def make_averaged(original_function, times_called=1000): \"\"\"Return a function that returns the average value of ORIGINAL_FUNCTION called TIMES_CALLED times. To implement this function, you will have to use *args syntax. &gt;&gt;&gt; dice = make_test_dice(4, 2, 5, 1) &gt;&gt;&gt; averaged_dice = make_averaged(roll_dice, 40) &gt;&gt;&gt; averaged_dice(1, dice) # The avg of 10 4's, 10 2's, 10 5's, and 10 1's 3.0 \"\"\" # BEGIN PROBLEM 8 def average_cal(*args): suma = 0 for i in range(times_called): suma+=original_function(*args) return suma/times_called return average_cal # END PROBLEM 8 Problem 9 å®ç°å‡½æ•°ï¼Œæšä¸¾æ·éª°æ¬¡æ•°ï¼ˆ1-10ï¼‰ï¼Œçœ‹å“ªæ¬¡çš„åˆ†æ•°å¹³å‡å€¼æœ€å¤§ max_scoring_num_rolls()å‡½æ•° å‚æ•°ï¼š diceï¼šä½¿ç”¨çš„éª°å­ times_calledï¼šè°ƒç”¨æ¬¡æ•° ç†è§£ éå†æ·éª°æ¬¡æ•°ï¼Œè°ƒç”¨make_averagedå‡½æ•°è®¡ç®—å¹³å‡å€¼ï¼Œå–1-10æ·éª°æ¬¡æ•°ä¸­å¹³å‡å€¼æœ€å¤§å€¼ å½“å¹³å‡å€¼ç›¸ç­‰æ—¶å–æ›´å°çš„ My codeï¼š 123456789101112131415161718def max_scoring_num_rolls(dice=six_sided, times_called=1000): \"\"\"Return the number of dice (1 to 10) that gives the maximum average score for a turn. Assume that the dice always return positive outcomes. &gt;&gt;&gt; dice = make_test_dice(1, 6) &gt;&gt;&gt; max_scoring_num_rolls(dice) 1 \"\"\" # BEGIN PROBLEM 9 maxi = 0 maxc = 0 for i in range(1,11): temp = make_averaged(roll_dice,times_called)(i,dice) if temp &gt; maxc: maxc = temp maxi = i return maxi # END PROBLEM 9 Problem 10 é‡‡ç”¨Boar Brawlè§„åˆ™ï¼Œè‹¥rollå‡º0æ—¶æ ¹æ®è¯¥è§„åˆ™å¾—åˆ°çš„åˆ†æ•°æ¯”thresholdå¤§ï¼Œè¿”å›0ï¼Œå¦åˆ™è¿”å›æ·éª°æ¬¡æ•° boar_strategy()å‡½æ•° å‚æ•°ï¼š scoreï¼šè‡ªå·±çš„åˆ†æ•° opponent_scoreï¼šå¯¹æ‰‹çš„åˆ†æ•° thresholdï¼šé˜ˆå€¼åˆ†æ•°ï¼Œè‹¥é‡‡ç”¨boar brawlå¾—åˆ°çš„åˆ†æ•°å¤§äºå®ƒåˆ™è¿”å›æ·éª°0æ¬¡ num_rollsï¼šæ·éª°æ¬¡æ•° ç†è§£ï¼š boar brawlè§„åˆ™æ˜¯åœ¨æ·éª°0æ¬¡ä¸‹çš„ç‰¹æ®Šè§„åˆ™ è‹¥é‡‡ç”¨è¯¥è§„åˆ™ç­–ç•¥è·å¾—çš„åˆ†æ•°è¦æ¯”æ­£å¸¸æ·éª°è·å¾—çš„åˆ†æ•°æ›´é«˜ï¼Œå°±é‡‡ç”¨è¯¥ç­–ç•¥ï¼ˆè¿”å›æ·éª°æ¬¡æ•°0æ¬¡ï¼‰ å¦åˆ™æŒ‰æ­£å¸¸æ·éª°æ¬¡æ•°æ·éª° My codeï¼š 12345678def boar_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice if Boar Brawl gives at least THRESHOLD points, and returns NUM_ROLLS otherwise. Ignore score and Sus Fuss. \"\"\" # BEGIN PROBLEM 10 if boar_brawl(score,opponent_score)&gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 10 Problem 11 é‡‡ç”¨Sus Fussè§„åˆ™ï¼Œè‹¥rollå‡º0æ—¶æ ¹æ®è¯¥è§„åˆ™ä¸Boar Brawlè§„åˆ™å¾—åˆ°çš„åˆ†æ•°ä¸èµ·å§‹åˆ†æ•°å·®å€¼æ¯”thresholdå¤§ï¼Œè¿”å›0ï¼Œå¦åˆ™è¿”å›æ·éª°æ¬¡æ•° sus_strategy()å‡½æ•° å‚æ•°ï¼š scoreï¼šè‡ªå·±çš„åˆ†æ•° opponent_scoreï¼šå¯¹æ‰‹çš„åˆ†æ•° thresholdï¼šé˜ˆå€¼åˆ†æ•°ï¼Œè‹¥é‡‡ç”¨boar brawlå¾—åˆ°çš„åˆ†æ•°å¤§äºå®ƒåˆ™è¿”å›æ·éª°0æ¬¡ num_rollsï¼šæ·éª°æ¬¡æ•° ç†è§£ï¼š å³åœ¨boar brawlè§„åˆ™ä¸‹é‡‡ç”¨sus fussè§„åˆ™å¾—åˆ°åˆ†æ•° è‹¥é‡‡ç”¨è¯¥è§„åˆ™ç­–ç•¥è·å¾—çš„åˆ†æ•°è¦æ¯”æ­£å¸¸æ·éª°è·å¾—çš„åˆ†æ•°æ›´é«˜ï¼Œå°±é‡‡ç”¨è¯¥ç­–ç•¥ï¼ˆè¿”å›æ·éª°æ¬¡æ•°0æ¬¡ï¼‰ å¦åˆ™æŒ‰æ­£å¸¸æ·éª°æ¬¡æ•°æ·éª° My codeï¼š 123456def sus_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice when your score would increase by at least threshold.\"\"\" # BEGIN PROBLEM 11 if sus_update(0,score,opponent_score) - score &gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 11 Problem 12 ç»“åˆä¸Šè¿°æ‰€æœ‰ç­–ç•¥ä¸è‡ªå·±çš„ç­–ç•¥ï¼Œå®ç°æœ€ç»ˆç­–ç•¥ My codeï¼š 12345678910def final_strategy(score, opponent_score): \"\"\"Write a brief description of your final strategy. *** YOUR DESCRIPTION HERE *** \"\"\" # BEGIN PROBLEM 12 threshold = GOAL-score if score&gt;80 and score-opponent_score&gt;20: return 0 return 6 # Remove this line once implemented. # END PROBLEM 12","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Cat","slug":"Project2-Cat","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:21.217Z","comments":true,"path":"2025/01/30/Project2-Cat/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project2-Cat/","excerpt":"","text":"Project2-Cat å®ç°ä¸€ä¸ªé‡‘å±±æ‰“å­—é€šï¼ˆï¼Ÿï¼‰ å…·ä½“å®ç°ï¼šè®°å½•æ‰“å­—é€Ÿåº¦ä»¥åŠè‡ªåŠ¨ä¿®æ­£æ‹¼å†™é”™è¯¯çš„å­—ç¬¦ Phase 1: Typing å®ç°æ‰“å­—ä»¥åŠæ£€æµ‹æ‰“å­—é€Ÿåº¦ç›¸å…³åŠŸèƒ½ Problem 1 æŒ‘é€‰ç”¨æˆ·æ‰“å­—çš„æ®µè½ pickå‡½æ•° å‚æ•°ï¼š paragraphsï¼šä¸€ä¸²å­—ç¬¦ä¸²è®°å½•äº†æ‰“å­—å†…å®¹ selectï¼šä¸€ä¸ªå‡½æ•°ï¼Œæ£€æµ‹æ®µè½æ˜¯å¦èƒ½è¢«é€‰æ‹© kï¼šéè´Ÿæ•°ï¼Œä½œä¸ºindex æ€è·¯ï¼š å‡½æ•°åŠŸèƒ½å®ç°äº†ç”¨æˆ·é€‰æ‹©ç¬¬kä¸ªæ®µè½ä½œä¸ºæ‰“å­—å†…å®¹ è‹¥é€‰æ‹©çš„kæ²¡æœ‰å¯¹åº”æ®µè½åˆ™è¿”å›ç©ºå­—ç¬¦ä¸² é€‰æ‹©çš„å­—ç¬¦ä¸²è¦ç¬¦åˆselectå‡½æ•°çš„æ¡ä»¶ ç¬¦åˆæ¡ä»¶çš„æ‰èƒ½ç¼–å·ç¬¬kä¸ªå­—ç¬¦ä¸² codeï¼š 1234567891011121314151617181920212223242526272829def pick(paragraphs, select, k): \"\"\"Return the Kth paragraph from PARAGRAPHS for which SELECT called on the paragraph returns True. If there are fewer than K such paragraphs, return the empty string. Arguments: paragraphs: a list of strings select: a function that returns True for paragraphs that can be selected k: an integer &gt;&gt;&gt; ps = ['hi', 'how are you', 'fine'] &gt;&gt;&gt; s = lambda p: len(p) &lt;= 4 &gt;&gt;&gt; pick(ps, s, 0) 'hi' &gt;&gt;&gt; pick(ps, s, 1) 'fine' &gt;&gt;&gt; pick(ps, s, 2) '' \"\"\" # BEGIN PROBLEM 1 valid_para = [] for s in paragraphs: if select(s): valid_para.append(s) if k&gt;=len(valid_para): return '' else: return valid_para[k] # END PROBLEM 1 Problem 2 é€šè¿‡ç»™å®šçš„å…³é”®è¯é€‰å–æ®µè½ aboutå‡½æ•° å‚æ•°ï¼šsubjectï¼šå…³é”®è¯åˆ—è¡¨ æ€è·¯ï¼š aboutå‡½æ•°ç”¨äºpickå‡½æ•°ä¸­çš„selecté€‰é¡¹ï¼Œç”¨äºç­›é€‰æŒ‡å®šå…³é”®å­—çš„æ®µè½ æ•…å®ƒè¿”å›çš„æ˜¯ä¸€ä¸ªselectå‡½æ•°ï¼Œè‹¥æ®µè½æ»¡è¶³æ¡ä»¶åˆ™è¿”å›Trueå¦åˆ™è¿”å›False å•è¯åŒ¹é…æ—¶ä¸åŒºåˆ†å¤§å°å†™ï¼Œä½†è¦æ˜¯ä¸€ä¸ªå®Œæ•´å•è¯ï¼Œä¸”ä¸èƒ½æ˜¯å•è¯çš„å­—ä¸² å¯ä»¥ä½¿ç”¨ç»™å®šçš„å‡½æ•°remove_punctuation-å»é™¤æ ‡ç‚¹ï¼Œlower-å˜å°å†™ï¼Œsplit-å°†ä¸€å¥è¯åˆ†å‰²ä¸ºè‹¥å¹²å•è¯å­˜å…¥åˆ—è¡¨ codeï¼š 1234567891011121314151617181920212223242526def about(subject): \"\"\"Return a select function that returns whether a paragraph contains one of the words in SUBJECT. Arguments: subject: a list of words related to a subject &gt;&gt;&gt; about_dogs = about(['dog', 'dogs', 'pup', 'puppy']) &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup!'], about_dogs, 0) 'Cute Dog!' &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup.'], about_dogs, 1) 'Nice pup.' \"\"\" assert all([lower(x) == x for x in subject]), 'subjects should be lowercase.' # BEGIN PROBLEM 2 def select(para): sp_para = split(remove_punctuation(para)) for i in range(0,len(sp_para)): sp_para[i]=lower(sp_para[i]) for s in subject: if s in sp_para: return True return False return select # END PROBLEM 2 Problem 3 è®¡ç®—å·²ç»è¾“å…¥ä¸”åŒ¹é…å•è¯å éœ€è¦è¾“å…¥å†…å®¹çš„ç™¾åˆ†æ¯” accuracyå‡½æ•° å‚æ•°ï¼š typedï¼šå·²ç»è¾“å…¥çš„å†…å®¹ sourceï¼šéœ€è¦è¾“å…¥çš„å†…å®¹ æ€è·¯ï¼š æŒ‰å•è¯é¡ºåºåŒ¹é…æŒ‡å®šè¾“å…¥å†…å®¹ï¼Œç¬¬ä¸€ä¸ªå¯¹ç¬¬ä¸€ä¸ªï¼Œç¬¬äºŒä¸ªå¯¹ç¬¬äºŒä¸ªâ€¦. åŒºåˆ†å¤§å°å†™ï¼Œä¸”åŒ…å«æ ‡ç‚¹ç¬¦å· è‹¥å·²ç»è¾“å…¥å†…å®¹æ¯”éœ€è¦è¾“å…¥å†…å®¹é•¿ï¼Œåˆ™é•¿çš„éƒ¨åˆ†è®¤å®šä¸ºä¸æ­£ç¡® è‹¥ä¸¤è€…å‡ä¸ºç©ºå­—ç¬¦ä¸²åˆ™å‡†ç¡®ç‡ä¸º100.0ï¼Œè‹¥å‰è€…ä¸ºç©ºåè€…éç©ºæˆ–å‰è€…éç©ºåè€…ä¸ºç©ºåˆ™å‡†ç¡®ç‡ä¸º0.0 codeï¼š 12345678910111213141516171819202122232425262728293031323334353637def accuracy(typed, source): \"\"\"Return the accuracy (percentage of words typed correctly) of TYPED when compared to the prefix of SOURCE that was typed. Arguments: typed: a string that may contain typos source: a string without errors &gt;&gt;&gt; accuracy('Cute Dog!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('A Cute Dog!', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('cute Dog.', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute Dog. I say!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute', 'Cute Dog.') 100.0 &gt;&gt;&gt; accuracy('', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('', '') 100.0 \"\"\" typed_words = split(typed) source_words = split(source) # BEGIN PROBLEM 3 cnt = 0 for t, s in zip(typed_words, source_words): if t==s: cnt+=1 if len(typed_words)==0 and len(source_words)==0: return 100.0 elif len(typed_words)==0 or len(source_words)==0: return 0.0 else: return (cnt/len(typed_words))*100 # END PROBLEM 3 æ³¨æ„ï¼š åŒæ—¶éå†ä¸¤ä¸ªåˆ—è¡¨æ—¶ï¼Œä½¿ç”¨zipå‡½æ•°è§£åŒ…ï¼Œå› ä¸ºåŸä»£ç å®ç°çš„æ˜¯éå†ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªåˆ—è¡¨çš„å…ƒç»„ ç©ºå­—ç¬¦éƒ¨åˆ†ç‰¹åˆ¤ï¼Œå› ä¸ºè®¡ç®—ç™¾åˆ†æ¯”æ—¶å¯èƒ½ä¼šå¯¼è‡´åˆ†æ¯ä¸º0 è®¡ç®—çš„æ˜¯å·²ç»è¾“å…¥å­—ç¬¦ä¸éœ€è¦è¾“å…¥å­—ç¬¦åŒ¹é…çš„å­—ç¬¦ä¸ªæ•°åœ¨å·²ç»è¾“å…¥å­—ç¬¦ä¸­çš„å æ¯”ï¼Œåˆ†æ¯æ˜¯typed_wordsçš„é•¿åº¦ Problem 4 æŒ‰ç…§words/minè®¡ç®—æ‰“å­—é€Ÿåº¦ wpmå‡½æ•° å‚æ•°ï¼š typedï¼šå·²ç»è¾“å…¥çš„å†…å®¹ elapsedï¼šæ€»å…±æ‰“å­—æ—¶é—´ï¼ˆæŒ‰ç§’è®¡ï¼‰ æ€è·¯ï¼š wpmçš„è®¡ç®—æ˜¯æŒ‰ç…§å­—ç¬¦æ•°æ¥çš„ï¼Œå•ä½æ˜¯æ¯äº”ä¸ªå­—ç¬¦æ•°ï¼Œè¿™æ ·å¯ä»¥å‡å°‘å•è¯é•¿åº¦å¯¹ç»“æœçš„å½±å“ å­—ç¬¦æ•°æ—¶é—´ code: 1234567891011121314151617def wpm(typed, elapsed): \"\"\"Return the words-per-minute (WPM) of the TYPED string. Arguments: typed: an entered string elapsed: an amount of time in seconds &gt;&gt;&gt; wpm('hello friend hello buddy hello', 15) 24.0 &gt;&gt;&gt; wpm('0123456789',60) 2.0 \"\"\" assert elapsed &gt; 0, 'Elapsed time must be positive' # BEGIN PROBLEM 4 length = len(typed) return (length/5)/(elapsed/60) # END PROBLEM 4 æ³¨æ„ï¼šelapsedå•ä½æ˜¯ç§’ï¼Œwpmä½¿ç”¨çš„æ—¶é—´æ˜¯åˆ†é’Ÿ Phase 2: Autocorrect æŒ‰ä¸‹ç©ºæ ¼è§¦å‘å•è¯è‡ªåŠ¨çº æ­£ï¼Œè‹¥æœ€è¿‘çš„ä¸€ä¸ªè¯æ¥è¿‘æ­£ç¡®è¯æ±‡ä½†ä¸æ­£ç¡®ï¼Œåˆ™ä¼šç”¨æ­£ç¡®è¯æ±‡æ›¿ä»£ Problem 5 è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œå†…éƒ¨æä¾›äº†å‡ ä¸ªæ¥è¿‘è¾“å…¥å•è¯çš„æ­£ç¡®å•è¯ å‚æ•°ï¼š typed_wordï¼šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºè¾“å…¥çš„å•è¯ word_listï¼šæºå•è¯åˆ—è¡¨ diff_functionï¼šè¯„ä¼°å•è¯ä¸åŒç¨‹åº¦çš„å‡½æ•° limitï¼šå•è¯èƒ½å¦è¢«æ›´æ”¹çš„é˜ˆå€¼ æ€è·¯ï¼š autocorrectå®ç°çš„ è‹¥è¾“å…¥å­—ç¬¦å·²ç»åœ¨word_listä¸­ï¼Œå°†ä¼šç›´æ¥è¿”å›è¯¥å­—ç¬¦ å¦åˆ™ä¼šè¿”å›åŸºäºdiffå‡½æ•°è®¡ç®—çš„ä¸åŒç¨‹åº¦æœ€å°çš„å•è¯ è‹¥è¾“å…¥å•è¯ä¸word_listä¸­æœ€å°çš„ä¸åŒç¨‹åº¦ä»å¤§äºlimitï¼Œåˆ™è¿”å›è¾“å…¥å•è¯ æ‰€æœ‰è¾“å…¥å•è¯å’Œword_listä¸­çš„å•è¯éƒ½æ˜¯å°å†™ä¸”æ²¡æœ‰æ ‡ç‚¹ è‹¥å¤šä¸ªå•è¯ä¸è¾“å…¥å­—ç¬¦ä¸åŒç¨‹åº¦æœ€å°ç›¸åŒï¼Œåˆ™è¿”å›æœ€é å‰çš„ ä¸åŒç¨‹åº¦å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªå•è¯ç›¸åŒéƒ¨åˆ†é•¿åº¦è¡¡é‡ codeï¼š 123456789101112131415161718192021222324252627282930def autocorrect(typed_word, word_list, diff_function, limit): \"\"\"Returns the element of WORD_LIST that has the smallest difference from TYPED_WORD. If multiple words are tied for the smallest difference, return the one that appears closest to the front of WORD_LIST. If the difference is greater than LIMIT, instead return TYPED_WORD. Arguments: typed_word: a string representing a word that may contain typos word_list: a list of strings representing source words diff_function: a function quantifying the difference between two words limit: a number &gt;&gt;&gt; ten_diff = lambda w1, w2, limit: 10 # Always returns 10 &gt;&gt;&gt; autocorrect(\"hwllo\", [\"butter\", \"hello\", \"potato\"], ten_diff, 20) 'butter' &gt;&gt;&gt; first_diff = lambda w1, w2, limit: (1 if w1[0] != w2[0] else 0) # Checks for matching first char &gt;&gt;&gt; autocorrect(\"tosting\", [\"testing\", \"asking\", \"fasting\"], first_diff, 10) 'testing' \"\"\" # BEGIN PROBLEM 5 if typed_word in word_list: return typed_word word_diff = [diff_function(typed_word, s, limit) for s in word_list] min_diff = min(word_diff) if min_diff &gt; limit: return typed_word else : return word_list[word_diff.index(min_diff)] # END PROBLEM 5 æ³¨æ„ï¼š å¯ä»¥ä½¿ç”¨list.index(&lt;val&gt;)è·å–åˆ—è¡¨ä¸­æŸå€¼çš„ä¸‹æ ‡ Problem 6 è¿”å›ä¸ºçº æ­£å•è¯éœ€è¦ä¿®æ”¹çš„å­—ç¬¦ä¸ªæ•° å‚æ•°ï¼š typedï¼šè¾“å…¥å•è¯ sourceï¼šç›®æ ‡å•è¯ limitï¼šæœ€å¤šä¿®æ”¹å­—ç¬¦æ•° æ€è·¯ï¼š æ¯”è¾ƒä¸ªä½å­—ç¬¦ï¼Œè‹¥ä¸åŒåˆ™æ‰§è¡Œæ›´æ”¹ï¼Œè®°å½•æ›´æ”¹æ•° è‹¥ä¸€è¾¹æ¯”å¦ä¸€è¾¹é•¿ï¼Œé•¿åº¦çš„ä¸åŒä¹Ÿç®—å…¥æ›´æ”¹æ•° è‹¥æ›´æ”¹æ•°æ¯”limitæ‰“ï¼Œåˆ™è¿”å›ä»»ä½•å¤§äºlimitçš„æ•°ï¼ˆä¸ºäº†é¿å…å¤šä½™çš„è®¡ç®—ï¼‰ è¦æ±‚ä½¿ç”¨é€’å½’ codeï¼š 123456789101112131415161718192021222324252627282930313233343536373839def feline_fixes(typed, source, limit): \"\"\"A diff function for autocorrect that determines how many letters in TYPED need to be substituted to create SOURCE, then adds the difference in their lengths and returns the result. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of chars that must change &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; feline_fixes(\"nice\", \"rice\", big_limit) # Substitute: n -&gt; r 1 &gt;&gt;&gt; feline_fixes(\"range\", \"rungs\", big_limit) # Substitute: a -&gt; u, e -&gt; s 2 &gt;&gt;&gt; feline_fixes(\"pill\", \"pillage\", big_limit) # Don't substitute anything, length difference of 3. 3 &gt;&gt;&gt; feline_fixes(\"roses\", \"arose\", big_limit) # Substitute: r -&gt; a, o -&gt; r, s -&gt; o, e -&gt; s, s -&gt; e 5 &gt;&gt;&gt; feline_fixes(\"rose\", \"hello\", big_limit) # Substitute: r-&gt;h, o-&gt;e, s-&gt;l, e-&gt;l, length difference of 1. 5 \"\"\" # BEGIN PROBLEM 6 # assert False, 'Remove this line' def compute(typed_w,source_w,count): if count &gt; limit: return limit+1 if typed_w == \"\" and source_w == \"\": return count elif typed_w == \"\": return compute(typed_w,source_w[1:],count+1) elif source_w == \"\": return compute(typed_w[1:],source_w,count+1) elif typed_w[0]==source_w[0]: return compute(typed_w[1:],source_w[1:],count) else: return compute(typed_w[1:],source_w[1:],count+1) return compute(typed,source,0) # END PROBLEM 6 æ³¨æ„ï¼š è¶…è¿‡limité™åˆ¶çš„ä¸€å¾‹è®¾ä¸ºlimit+1 é€šè¿‡sliceæ¥æ¯æ¬¡é€’å½’å¾€åæˆªå–ä¸€ä½å­—ç¬¦ï¼Œæ¯”è¾ƒæ¯æ¬¡æˆªå–åçš„é¦–å­—ç¬¦æ¥åˆ¤æ–­ç›¸åŒä¸å¦ï¼Œä¸ç›¸åŒè®©count+1 é€’å½’å‡ºå£ä¸ºä¸¤å­—ç¬¦ä¸²å‡è¢«æˆªå–æˆç©ºä¸²ï¼Œè¿”å›è®¡æ•° é•¿åº¦ä¸åŒçš„æƒ…å†µä¸‹ï¼Œå·²ç»è¢«æˆªæˆç©ºä¸²çš„ä¸å†æˆªå–ï¼Œé•¿ä¸²ç»§ç»­æˆªå–ï¼Œè¯¥æƒ…å†µä¸‹ç›´æ¥è®©count+1 Problem 7 è¿”å›å°†è¾“å…¥å­—ç¬¦æ”¹ä¸ºç›®æ ‡å­—ç¬¦æ‰€éœ€è¦æ‰§è¡Œçš„æ“ä½œæ¬¡æ•°ï¼Œæ“ä½œæœ‰ä»¥ä¸‹ï¼š æ·»åŠ å­—ç¬¦ åˆ é™¤å­—ç¬¦ æ›¿æ¢å­—ç¬¦ å‚æ•°ï¼š typedï¼šè¾“å…¥å•è¯ sourceï¼šç›®æ ‡å•è¯ limitï¼šæœ€å¤šä¿®æ”¹å­—ç¬¦æ•° æ€è·¯ï¼š æ¯”è¾ƒè¾“å…¥å•è¯ä¸æŒ‡å®šå•è¯ï¼Œå¯»æ‰¾ä¸åŒä½ç½® è‹¥éœ€è¦ä¿®æ”¹æ•°é‡å¤§äºlimitï¼Œåˆ™è¿”å›ä»»ä½•å¤§äºlimitçš„å€¼ ä»£ç éœ€è¦ä½¿ç”¨é€’å½’ï¼Œåº”éœ€è¦ä¸‰ä¸ªé€’å½’è°ƒç”¨ä»¥åŠä¸¤ä¸ªé€’å½’å‡ºå£ codeï¼š 123456789101112131415161718192021222324252627282930313233343536def minimum_mewtations(typed, source, limit): \"\"\"A diff function that computes the edit distance from TYPED to SOURCE. This function takes in a string TYPED, a string SOURCE, and a number LIMIT. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of edits &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; minimum_mewtations(\"cats\", \"scat\", big_limit) # cats -&gt; scats -&gt; scat 2 &gt;&gt;&gt; minimum_mewtations(\"purng\", \"purring\", big_limit) # purng -&gt; purrng -&gt; purring 2 &gt;&gt;&gt; minimum_mewtations(\"ckiteus\", \"kittens\", big_limit) # ckiteus -&gt; kiteus -&gt; kitteus -&gt; kittens 3 \"\"\" # assert False, 'Remove this line' if limit&lt;0: # Base cases should go here, you may add more base cases as needed. # BEGIN return 0 # END # Recursive cases should go below here if typed == \"\" and source == \"\": # Feel free to remove or add additional cases # BEGIN return 0 # END elif typed == \"\" or source == \"\": return abs(len(typed)-len(source)) elif typed[0] == source[0]: return minimum_mewtations(typed[1:],source[1:],limit) else: add = minimum_mewtations(typed,source[1:],limit-1) remove = minimum_mewtations(typed[1:],source,limit-1) substitute = minimum_mewtations(typed[1:],source[1:],limit-1) # BEGIN return min(add,remove,substitute)+1 # END æ³¨æ„ï¼š å’Œä¸Šä¸€ä¸ªproblemç±»ä¼¼ï¼Œä½¿ç”¨é€’å½’ä¸sliceä¸€ä½ä½åˆ¤æ–­ ä¸‰ç§æ“ä½œä¾æ¬¡é€’å½’ï¼Œå¹¶å–æœ€å°å€¼ Phase 3: Multiplayer å®ç°å¤šäººå¯¹æˆ˜æ¨¡å¼ Problem 8 å°†ç©å®¶è¾“å…¥è¿›åº¦ä¸ä¿¡æ¯ä¼ å…¥å¤šäººæœåŠ¡å™¨å¹¶è¿”å›å¯¹åº”ä¿¡æ¯ report_progresså‡½æ•° å‚æ•°ï¼š typedï¼šè¾“å…¥çš„å­—ç¬¦ï¼Œåˆ—è¡¨å­˜å‚¨ sourceï¼šéœ€è¦è¾“å…¥çš„å­—ç¬¦ï¼Œåˆ—è¡¨å­˜å‚¨ user_idï¼šå½“å‰ç©å®¶id uploadï¼šä¸Šä¼ è¿›åº¦çš„å‡½æ•° æ€è·¯ï¼š å°†è¾“å…¥å­—ç¬¦ä¸éœ€è¦è¾“å…¥å­—ç¬¦æ¯”è¾ƒï¼Œè®¡ç®—è¾“å…¥è¿›åº¦ è¾“å…¥è¿›åº¦æŒ‡å·²ç»è¾“å…¥æ­£ç¡®å•è¯ä¸éœ€è¦è¾“å…¥æ­£ç¡®å•è¯çš„æ¯”ä¾‹ï¼ˆå› æ­¤ï¼Œè‹¥ä¸­é—´æœ‰ä¸€ä¸ªå•è¯æ‰“é”™ï¼Œåé¢å†æ­£ç¡®ä¹Ÿä¸ä¼šè®°å½•ï¼‰ å‡½æ•°çš„è¿”å›å€¼æ˜¯è®¡ç®—çš„è¿›åº¦ codeï¼š 123456789101112131415161718192021222324252627282930313233def report_progress(typed, source, user_id, upload): \"\"\"Upload a report of your id and progress so far to the multiplayer server. Returns the progress so far. Arguments: typed: a list of the words typed so far source: a list of the words in the typing source user_id: a number representing the id of the current user upload: a function used to upload progress to the multiplayer server &gt;&gt;&gt; print_progress = lambda d: print('ID:', d['id'], 'Progress:', d['progress']) &gt;&gt;&gt; # The above function displays progress in the format ID: __, Progress: __ &gt;&gt;&gt; print_progress({'id': 1, 'progress': 0.6}) ID: 1 Progress: 0.6 &gt;&gt;&gt; typed = ['how', 'are', 'you'] &gt;&gt;&gt; source = ['how', 'are', 'you', 'doing', 'today'] &gt;&gt;&gt; report_progress(typed, source, 2, print_progress) ID: 2 Progress: 0.6 0.6 &gt;&gt;&gt; report_progress(['how', 'aree'], source, 3, print_progress) ID: 3 Progress: 0.2 0.2 \"\"\" # BEGIN PROBLEM 8 typed_count = 0 for t,s in zip(typed,source): if t != s: break typed_count+=1 ratio = typed_count/len(source) upload({'id': user_id, 'progress': ratio}) return ratio # END PROBLEM 8 æ³¨æ„ï¼š åˆ¤æ–­æ˜¯å¦ç›¸ç­‰æ—¶ï¼Œè‹¥å‘ç°ä¸ç­‰å°±éœ€è¦breakç»“æŸå¾ªç¯ Problem 9 è®¡ç®—ä¸¤ä¸ªç©å®¶è¾“å…¥æ¯ä¸ªå•è¯æ—¶çš„ç”¨æ—¶å·® time_per_wordå‡½æ•° å‚æ•°ï¼š wordsï¼šæŒ‰è¾“å…¥é¡ºåºæ’åˆ—çš„å•è¯åˆ—è¡¨ timestamps_per_playerï¼šä¸€ä¸ªäºŒç»´åˆ—è¡¨ï¼Œè®°å½•äº†æ¯ä½ç©å®¶å¼€å§‹ä¸ç»“æŸè¾“å…¥æ¯ä¸ªå•è¯çš„æ—¶é—´ data abstractionï¼šmatch å‚æ•°ï¼š wordsï¼šè¾“å…¥å•è¯ç»„æˆçš„å•è¯åˆ—è¡¨ timesï¼šäºŒç»´åˆ—è¡¨ï¼Œè®°å½•äº†æ¯ä¸ªç©å®¶è¾“å…¥æ¯ä¸ªå•è¯éœ€è¦å¤šé•¿æ—¶é—´ï¼Œå¦‚times[i][j]æŒ‡ç©å®¶iè¾“å…¥å•è¯words[j]æ‰€èŠ±è´¹çš„æ—¶é—´ æ€è·¯ï¼š timestamps_per_playerè®°å½•çš„æ˜¯æ¯ä¸ªç©å®¶æ•²æ¯ä¸ªå•è¯çš„å¼€å§‹ä¸ç»“æŸæ—¶é—´ ä¼ å…¥matchåï¼Œæ—¶é—´ä¼šè‡ªåŠ¨è®¡ç®—ä¸ºæ•²æ¯ä¸ªå•è¯ä½¿ç”¨çš„æ—¶é—´ï¼ˆç»“æŸ-å¼€å§‹ï¼‰ï¼Œå¹¶å­˜å…¥æ¯ä¸ªå•è¯keyå¯¹åº”çš„valueä¸­ é€šè¿‡get_all_wordä¸get_all_timeså‡½æ•°å¯ä»¥è¿”å›matchä¸­å¯¹åº”çš„é”®ä¸å€¼å½¢æˆçš„åˆ—è¡¨ é€šè¿‡get_wordä¸timeå‡½æ•°å¯ä»¥è¿”å›æŒ‡å®šçš„é”®ä¸å€¼ code: 123456789101112131415161718192021222324252627def time_per_word(words, timestamps_per_player): \"\"\"Given timing data, return a match data abstraction, which contains a list of words and the amount of time each player took to type each word. Arguments: words: a list of words, in the order they are typed. timestamps_per_player: A list of lists of timestamps including the time the player started typing, followed by the time the player finished typing each word. &gt;&gt;&gt; p = [[75, 81, 84, 90, 92], [19, 29, 35, 36, 38]] &gt;&gt;&gt; match = time_per_word(['collar', 'plush', 'blush', 'repute'], p) &gt;&gt;&gt; get_all_words(match) ['collar', 'plush', 'blush', 'repute'] &gt;&gt;&gt; get_all_times(match) [[6, 3, 6, 2], [10, 6, 1, 2]] \"\"\" # BEGIN PROBLEM 9 times = [] for l in timestamps_per_player: each_times = [] for i in range(1,len(l)): each_times.append(l[i]-l[i-1]) times.append(each_times) return match(words,times) # END PROBLEM 9 æ³¨æ„ï¼š è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯é€šè¿‡è°ƒç”¨matchå‡½æ•°æ„é€ è¯¥æŠ½è±¡ç±»å‹ ä½†matchå‡½æ•°éœ€è¦æ¯ä¸ªå•è¯çš„æ—¶é—´å·®ï¼Œæ•…éœ€è¦åœ¨è¯¥å‡½æ•°ä¸­å¤„ç†è¾“å…¥çš„æ—¶é—´åˆ—è¡¨ï¼ˆç»“æŸ-å¼€å§‹ï¼‰ å°†å¤„ç†åçš„åˆ—è¡¨ä¸ä¼ å…¥è¯¥å‡½æ•°çš„å•è¯åˆ—è¡¨ä¼ å…¥matchå‡½æ•°å¹¶è¿”å›è·å¾—çš„æŠ½è±¡ç±»å‹ Problem 10 è¿”å›æ¯ä¸ªå•è¯å“ªä½ç©å®¶æ•²å¾—å— fastest_wordså‡½æ•° å‚æ•°ï¼š matchï¼šmatchå‡½æ•°ä¸­è·å¾—çš„æŠ½è±¡æ•°æ®ç±»å‹ æ€è·¯ï¼š æ¯”è¾ƒå¤šä¸ªç©å®¶è¾“å…¥æ¯ä¸ªå­—ç¬¦æ—¶é—´ï¼Œé€‰æ‹©è¾“å…¥æ—¶é—´æœ€å°‘çš„ è¿”å›çš„åˆ—è¡¨ä¸­å­˜å‚¨äº†æ¯ä¸ªç©å®¶è¾“å…¥æœ€å¿«çš„å•è¯ç»„æˆçš„åˆ—è¡¨ è‹¥å¤šä¸ªç©å®¶è¾“å…¥æ—¶é—´ç›¸åŒï¼Œåˆ™å–ç¼–å·æ›´å°çš„ç©å®¶ code: 123456789101112131415161718192021222324252627def fastest_words(match): \"\"\"Return a list of lists of which words each player typed fastest. Arguments: match: a match data abstraction as returned by time_per_word. &gt;&gt;&gt; p0 = [5, 1, 3] &gt;&gt;&gt; p1 = [4, 1, 6] &gt;&gt;&gt; fastest_words(match(['Just', 'have', 'fun'], [p0, p1])) [['have', 'fun'], ['Just']] &gt;&gt;&gt; p0 # input lists should not be mutated [5, 1, 3] &gt;&gt;&gt; p1 [4, 1, 6] \"\"\" player_indices = range(len(get_all_times(match))) # contains an *index* for each player word_indices = range(len(get_all_words(match))) # contains an *index* for each word # BEGIN PROBLEM 10 result = [[] for i in player_indices] for i in word_indices: min_player = -1 for j in player_indices: if min_player == -1 or time(match, j, i) &lt; time(match, min_player, i): min_player = j result[min_player].append(get_word(match,i)) return result # END PROBLEM 10 æ³¨æ„ï¼š åˆ—è¡¨ä¸­åˆ›å»ºå¤šä¸ªåˆ—è¡¨è¦ç”¨forè¡¨è¾¾å¼[[] for _ in player_indices] resultåˆ—è¡¨ä¸­ä¸‹æ ‡è¡¨ç¤ºç©å®¶ï¼Œå¯¹åº”å…ƒç´ è¡¨ç¤ºè¯¥ç©å®¶æœ€å¿«çš„å•è¯ç»„æˆçš„åˆ—è¡¨ æˆ‘ä»¬é¦–å…ˆéå†å•è¯ï¼Œç„¶åéå†ç©å®¶æ‰¾å‡ºæ—¶é—´æœ€å°çš„ç©å®¶ï¼Œå¹¶å°†å¯¹åº”å•è¯å­˜å…¥è¯¥ç©å®¶å¯¹åº”åˆ—è¡¨","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Environments","slug":"CS61Aâ€”â€”Environments","date":"2025-01-30T08:23:18.274Z","updated":"2025-01-30T13:43:44.143Z","comments":true,"path":"2025/01/30/CS61Aâ€”â€”Environments/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Environments/","excerpt":"","text":"Environments Environments in Higher-orde function Local Names e.g. 123456def f(x,y): return g(x) def g(a): return a+y result = f(1,2) è¯¥ä»£ç ä¼šæŠ¥é”™NameError: global name 'y' is not defined åŸå› å¾ˆæ˜æ˜¾ï¼šå½“æ‰§è¡Œåˆ°è¡Œ4æ—¶ï¼Œç³»ç»Ÿåœ¨gçš„ä½œç”¨åŸŸä¸­æ‰¾ä¸åˆ°yï¼Œæ¥ç€å»å…¨å±€ä½œç”¨åŸŸä¸­ä¹Ÿæ‰¾ä¸åˆ°yï¼Œå› è€ŒæŠ¥é”™ è€Œå¯¹äºåµŒå¥—å‡½æ•°ï¼Œå‡½æ•°ä¸­å®šä¹‰çš„å‡½æ•°æ˜¯å¯ä»¥ç›´æ¥ä½¿ç”¨åµŒå¥—å¤–å‡½æ•°çš„å‚æ•°çš„ï¼Œå› ä¸ºåœ¨åŒä¸€ä¸ªä½œç”¨äºä¸‹ Function Composition e.g. 123456789101112def make_adder(n): def adder(k): return k+n return adder def square(x): return x*x def triple(x): return 3*x def compose1(f,g): def h(x): return f(g(x)) return h compose1å‡½æ•°å°†ä¸¤ä¸ªå‡½æ•°ç»“åˆèµ·æ¥è®¡ç®— compose1(triple,square)(5)çš„ç»“æœä¸º225 compose1(square,triple)(5)çš„ç»“æœä¸º75 compose1(square, makek_adder(2))(3)çš„ç»“æœä¸º25 è¯¥å‡½æ•°å®é™…ä¸Šå¼€è¾Ÿäº†ä¸¤ä¸ªenvironmentsç”¨æ¥åˆ†åˆ«è®¡ç®—ä¸¤ä¸ªå‡½æ•°çš„returnå€¼ å¦‚å›¾ä¸­è“è‰²å’Œç»¿è‰²çš„ä¸¤ä¸ªenvironmentsï¼Œæ¯ä¸ªä¸­éƒ½åŒ…å«äº†ä¸‰ä¸ªä½œç”¨åŸŸï¼Œåˆ†åˆ«ç”¨æ¥è®¡ç®—squareä¸make_adder(2)çš„å€¼ï¼Œå…¶ä¸­make_adderè¿˜ä¼šå…ˆè¿›å…¥adderå‡½æ•°çš„ä½œç”¨åŸŸ Self-Reference e.g.1 12345def print_all(x): print(x) return print_all print_all(1)(3)(5) è¯¥å‡½æ•°æ‰§è¡Œåä¼šè¾“å‡º1 å³print_allå‡½æ•°å¯ä»¥åœ¨å‡½æ•°ä½“å†…ä»¥returnå€¼å½¢å¼è¿”å›è‡ªèº«ï¼Œå› æ­¤è¯¥å‡½æ•°è¢«è°ƒç”¨çš„æ¬¡æ•°ä¸ç¬¬äº”è¡Œåé¢çš„æ‹¬å·æ•°ä¸€è‡´ï¼ˆå³è¢«è°ƒç”¨å‡ æ¬¡ï¼‰ e.g.2 1234567def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) å‡½æ•°ä¼šæŠŠæ‹¬å·åé¢çš„æ•°ä¾æ¬¡ç›¸åŠ ï¼Œè¾“å‡ºæ¯æ¬¡ç›¸åŠ çš„å’Œ é¦–å…ˆä¼ å…¥x=1ï¼Œæ‰“å°1ï¼Œå®šä¹‰next_sumå‡½æ•°ï¼Œprint_sumså‡½æ•°è¿”å›è¯¥å‡½æ•°ï¼Œå¹¶ä¼ å…¥y=3ï¼Œnext_sumè¿”å›print_sumså‡½æ•°ï¼Œä¼ å…¥å€¼ä¸ºx+y=4 å†æ¬¡æ‰“å°4ï¼Œå®šä¹‰next_sumå‡½æ•°ï¼Œprint_sumså‡½æ•°è¿”å›è¯¥å‡½æ•°ï¼Œå¹¶ä¼ å…¥y=5ï¼Œnext_sumè¿”å›print_sumså‡½æ•°ï¼Œä¼ å…¥å€¼ä¸ºx+y=9 å†æ¬¡æ‰“å°9ï¼Œæ²¡æœ‰å‚æ•°ä¼ å…¥ï¼Œç»“æŸ å› æ­¤è¦æ³¨æ„è°ƒç”¨è¡¨è¾¾å¼ä¸­ä¼ å…¥çš„å‚æ•°å»äº†å“ªé‡Œï¼š 1ä¼ å…¥äº†print_sumsï¼Œè€Œ3å’Œ5ä¼ å…¥äº†print_sumsçš„è¿”å›å€¼next_sumå‡½æ•°ç”¨äºæ±‚å’Œ Currying æ³¨æ„ä»¥ä¸‹ä¸¤ç§å‡½æ•° 12345def make_adder(n): return lambda k:n+k def add(x,y): return x+y make_adderå‡½æ•°ä¸€æ¬¡è°ƒç”¨ä¸€ä¸ªå‚æ•°ï¼Œè¿”å›ä¸€ä¸ªå‡½æ•°å†è°ƒç”¨å‚æ•° addå‡½æ•°è°ƒç”¨å¤šä¸ªå‚æ•°ï¼Œè¿”å›æœ€ç»ˆç»“æœ æˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹å‡½æ•°å°†addå‡½æ•°è½¬æ¢ä¸ºmake_adderå‡½æ•° 123456def curry(f): def g(x): def h(y): return f(x,y) return h return g è¿™æ ·ï¼Œå½“æˆ‘ä»¬æŠŠaddå‡½æ•°ä¼ å…¥curryå‡½æ•°ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸€æ¬¡è°ƒç”¨ä¸€ä¸ªå‚æ•°çš„æ–¹æ³•å®ç°ç›¸åŒæ•ˆæœ add_three = curry(add) add_three(3)(2) &gt;&gt;&gt; 5 å®šä¹‰ï¼šæŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰æ˜¯ä¸€ç§å¤„ç†å¤šå…ƒå‡½æ•°çš„æ–¹æ³•ã€‚å®ƒäº§ç”Ÿä¸€ç³»åˆ—è¿é”å‡½æ•°ï¼Œå…¶ä¸­æ¯ä¸ªå‡½æ•°å›ºå®šéƒ¨åˆ†å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°å‡½æ•°ï¼Œç”¨äºä¼ å›å…¶å®ƒå‰©ä½™å‚æ•°çš„åŠŸèƒ½ã€‚ å³å®ƒå¯ä»¥æŠŠä¸€ä¸ªå¤šå…ƒå‡½æ•°è½¬æ¢ä¸ºä¸€ç³»åˆ—å‡½æ•°ï¼Œæ¯ä¸ªå‡½æ•°ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œå³å°†f(a,b,c)è½¬æ¢ä¸ºf(a)(b)(c)","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘STè¡¨","slug":"stè¡¨","date":"2025-01-28T03:05:06.000Z","updated":"2025-02-23T14:20:11.737Z","comments":true,"path":"2025/01/28/stè¡¨/","permalink":"https://izayoisakuye.github.io/2025/01/28/st%E8%A1%A8/","excerpt":"","text":"STè¡¨ ç»™nä¸ªæ•°ï¼Œè¿›è¡Œmæ¬¡è¯¢é—®ï¼Œæ¯æ¬¡å¯»æ‰¾åŒºé—´[l,r]ä¸­çš„æœ€å¤§å€¼ DPæ‰“è¡¨ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; using namespace std; int arr[N]; int ans[N][N]; int n, m; int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; for(int i = 0;i&lt;n;i++){ for(int j = i;j&lt;n;j++){ if (i==j) ans[i][j]=arr[j]; else ans[i][j]=max(ans[i][j-1],arr[j]); } } int l,r; while(m--){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ans[l][r]&lt;&lt;' '; } return 0; } æ—¶é—´å¤æ‚åº¦ï¼š è¿™ç§æ‰“è¡¨æ–¹å¼ä¼šå¾ˆç´§å‡‘ï¼Œç”¨åˆ°äº†è®¸å¤šä¸ç”¨çš„ç©ºé—´ STè¡¨ åŸºäºåŠ¨æ€è§„åˆ’ä¸å€å¢æ€æƒ³ï¼Œæ˜¯ä¸€ç§æ›´ç¨€ç–çš„è¡¨ å®šä¹‰ dp[i][j]ä¸ºä¸€ä¸ªä»å¼€å§‹ï¼Œé•¿åº¦ä¸ºçš„åŒºé—´æœ€å€¼ è¯¢é—® e.g.è¯¢é—®[0,5] ä½¿ç”¨max(dp[0][2],dp[4][1])ï¼Œå³è¯¢é—®åŒºé—´ä»0å¼€å§‹ï¼Œé•¿åº¦ä¸ºï¼Œå³[0,3]ï¼Œä¸åŒºé—´ä»4å¼€å§‹ï¼Œé•¿åº¦ä¸ºå³[4,5]ä¸¤ä¸ªåŒºé—´ä¸­çš„maxå€¼ e.g.è¯¢é—®[0,13] ä½¿ç”¨max(dp[0][3],dp[8][2]),dp[12][1])å³è¯¢é—®åŒºé—´[0,7],[8,11],[12,13]ä¸‰ä¸ªåŒºé—´ä¸­çš„maxå€¼ å¯¹äºä»»æ„åŒºé—´éƒ½å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸ªå°åŒºé—´æ±‚maxå€¼ å› ä¸ºæ ¹æ®äºŒè¿›åˆ¶ï¼Œä»»æ„ä¸€ä¸ªæ•´æ•°éƒ½å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸ª2çš„næ¬¡å¹‚çš„å’Œ å› æ­¤æˆ‘ä»¬å¯ä»¥å°†ä»»æ„åŒºé—´åˆ’åˆ†ä¸ºnä¸ªé•¿åº¦ä¸ºä¸ç›¸äº¤çš„åŒºé—´å¹¶å¤šæ¬¡æ±‚max è‹¥åŒºé—´å‘ç”Ÿé‡å ï¼Œæˆ‘ä»¬å¯ä»¥å–é‡å åŒºé—´çš„max å› æ­¤è¯¢é—®æ­¥éª¤å¦‚ä¸‹ æ±‚å‡ºåŒºé—´é•¿åº¦ è®¡ç®—dpæ•°ç»„ä¸­çš„ è®¡ç®—æœ€å€¼ é¢„å¤„ç† å°†ä¸€ä¸ªåŒºé—´åˆ†æˆä¸¤åŠï¼Œåˆ™æ¯ä¸€åŠçš„é•¿åº¦å‡ä¸ºï¼ŒååŠç¬¬ä¸€ä¸ªå…ƒç´ ä¸‹æ ‡å³ä¸º å¤„ç†ç¬¬ä¸€ä¸ª å¤„ç†åé¢çš„ æ—¶é—´å¤æ‚åº¦ï¼š æ³¨æ„ï¼šstè¡¨æ˜¯ä¸€ä¸ªé™æ€è¡¨ï¼Œé€‚ç”¨äºç¦»çº¿å¤„ç† æ¿å­ 1234567891011121314151617181920212223242526#include &lt;bits\\stdc++.h&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; dp; int query(int l,int r){ int j = (int)log2(r-l+1); return max(dp[l][j],dp[r-(1&lt;&lt;j)+1][j]); } int main(){ vector&lt;int&gt; arr = {9,3,1,7,5,6,0,8}; const int N = 8; // é¢„å¤„ç† dp = vector&lt;vector&lt;int&gt;&gt; (N,vector&lt;int&gt;((int)log2(N)+5,0)); // åˆå§‹åŒ–dpæ•°ç»„ for (int i = 0;i &lt; N;i++) dp[i][0]=arr[i]; for (int j= 1;j&lt;=log2(N);j++){ for (int i = 0; i+(1&lt;&lt;j)-1&lt;N;i++){ dp[i][j]= max(dp[i][j-1], dp[i+(1&lt;&lt;(j-1))][j-1]); } } // è¯¢é—® int l, r; while(cin &gt;&gt; l &gt;&gt; r){ cout &lt;&lt; query(l,r) &lt;&lt; endl; } return 0; } æ—¶é—´å¤æ‚åº¦ï¼š","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ã€é¢˜è§£ã€‘2025ç‰›å®¢å¯’å‡é›†è®­-3","slug":"2025ç‰›å®¢å¯’å‡é›†è®­-3","date":"2025-01-25T16:00:00.000Z","updated":"2025-02-15T04:14:26.702Z","comments":true,"path":"2025/01/26/2025ç‰›å®¢å¯’å‡é›†è®­-3/","permalink":"https://izayoisakuye.github.io/2025/01/26/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-3/","excerpt":"","text":"","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","date":"2025-01-25T07:33:06.000Z","updated":"2025-02-21T13:08:51.521Z","comments":true,"path":"2025/01/25/æ ‘çŠ¶æ•°ç»„/","permalink":"https://izayoisakuye.github.io/2025/01/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"æ ‘çŠ¶æ•°ç»„ ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œå®Œæˆä»¥ä¸‹ä¸¤ä¸ªæ“ä½œ å°†ç¬¬xä¸ªæ•°åŠ ä¸Šk è¾“å‡ºåŒºé—´å†…æ¯ä¸ªæ•°çš„å’Œ å‰ç¼€å’Œ ä½¿ç”¨å‰ç¼€å’Œè¿›è¡Œè¯¢é—®æ—¶ï¼Œå¯ä»¥é€šè¿‡è¯¢é—®rä¸l-1å¤„çš„å‰ç¼€å’Œå¹¶ç›¸å‡è·å¾—åŒºé—´æ•°ä¹‹å’Œ ä½†è¿›è¡Œå¢åŠ æ“ä½œæ—¶ï¼Œè‹¥æƒ³å®ç°åœ¨æŸä½ç½®iå¤„å¢åŠ vï¼Œé‚£ä¹ˆè¯¥æ•°åé¢çš„æ‰€æœ‰å…ƒç´ éƒ½è¦å¯¹åº”å¢åŠ v å¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œæœ´ç´ ç®—æ³•èƒ½åšåˆ°çš„æ—¶é—´å¤æ‚åº¦ï¼Œæ˜“TLE ä¼˜åŒ–æ€ç»´ å•ä¸ªæ±‚åŒºé—´å’Œä¼šè¶…æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ•°ç»„è¿›è¡Œå¤„ç†ï¼š æˆ‘ä»¬å¯ä»¥æŠŠæ•°å­—ä¸¤ä¸¤æ±‚å’Œï¼Œå­˜åˆ°å¦ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œå†è¿›è¡Œä¸¤ä¸¤æ±‚å’Œï¼Œä¸€ç›´åˆ°å‰©ä¸€ä¸ªæ•°å­— è¿™æ ·å³ä½¿è¦æ±‚çš„æ•°å¾ˆå¤šï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨é¢å¤–çš„æ•°ç»„è®¡ç®—ç­”æ¡ˆ å¦‚è®¡ç®—å‰15ä¸ªæ•°çš„å’Œï¼Œæˆ‘ä»¬åªéœ€è¦è®¡ç®—4ä¸ªæ•°å­—å³å¯ ä½†æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæ¯å±‚ä¸­ç¬¬å¶æ•°ä¸ªæ•°å­—æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œå› ä¸ºéƒ½å¯ä»¥æ‰¾åˆ°æ›´ä¸Šä¸€å±‚çš„ä»£æ›¿ï¼Œå»æ‰ä»¥åï¼Œå‰©ä¸‹çš„æ•°æ®æ°å¥½ä¸ºnä¸ªï¼Œå¯ä»¥è£…åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œä¸åŸå§‹æ•°ç»„ä¸€æ ·é•¿ è¯¥æ•°ç»„å³ä¸ºæ ‘çŠ¶æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å¯¹åº”ç€æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œè€Œæ¯ä¸ªèŠ‚ç‚¹å¯¹åº”çš„æ˜¯åŸæ•°ç»„çš„æŸä¸ªåŒºé—´å’Œ ä¹Ÿå¯ä»¥ç†è§£ä¸ºæ¯ä¸ªå…ƒç´ æ˜¯ä»¥è¯¥å…ƒç´ ä¸ºå³è¾¹ç•Œæ‰€ç®¡è¾–çš„æœ€é•¿åŒºé—´å’Œä¸­å…ƒç´ ä¸ªæ•° æ±‚å’Œæ—¶åªéœ€è¦æ‰¾åˆ°å¯¹åº”åŒºé—´ï¼Œç›¸åŠ å³å¯å¾—åˆ°ç­”æ¡ˆ ä¿®æ”¹æŸä¸ªæ•°æ®æ—¶ï¼Œä¹Ÿåªéœ€è¦å‘ä¸Šæ‰¾åˆ°åŒ…å«å®ƒçš„åŒºé—´è¿›è¡Œä¿®æ”¹å³å¯ lowbit()è¿ç®— å®šä¹‰ è¡¨ç¤ºéè´Ÿæ•´æ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹æœ€ä½ä½1åŠå…¶åé¢çš„0æ„æˆçš„æ•° å³å®ç°äº†æå–æœ€å³ä¾§1ï¼Œå¹¶è®©å…¶ä½™ä½ç½®å˜ä¸º0 e.g. æ±‚è§£æ–¹æ³• å¦‚44ï¼ŒäºŒè¿›åˆ¶ä¸º101100 é¦–å…ˆå°†è¯¥æ•°å–åï¼š ç„¶ååŠ ä¸€ï¼š è¿™æ—¶å‘ç°é™¤äº†æœ€ä½ä½1ä¸åé¢çš„0ï¼Œå…¶ä½™ä½ä¸Šä¸åŸæ•°å‡ä¸åŒ å°†è¿™ä¸¤ä¸ªæ•°æŒ‰ä½ä¸ï¼š æ•…lowbit(n)=n&amp;(~n+1)=n&amp;-n æ ‘çŠ¶æ•°ç»„å®ç° æˆ‘ä»¬æ ¹æ®åºåˆ—å»ºé€ ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ ä¿å­˜ä»¥ä¸ºæ ¹çš„å­æ ‘ä¸­å¶èŠ‚ç‚¹å€¼ä¹‹å’Œ å°†æ¯ä¸ªçš„xè½¬åŒ–ä¸ºäºŒè¿›åˆ¶ï¼Œæˆ‘ä»¬å‘ç°æ¯ä¸€å±‚æœ«å°¾0çš„ä¸ªæ•°ç›¸åŒï¼Œä¸”0çš„ä¸ªæ•°ä¸å…¶è¦†ç›–é•¿åº¦æœ‰å…³ï¼Œæ¯å±‚çš„lowbit()å€¼éƒ½ç›¸åŒ æ•…èŠ‚ç‚¹è¦†ç›–é•¿åº¦å°±æ˜¯lowbit(x) ï¼Œåºå·ä¸ºiçš„åºåˆ—æ­£å¥½å°±æ˜¯é•¿åº¦ä¸ºlowbit(i)ä¸”ä»¥iç»“å°¾çš„åºåˆ— ä¸”èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸º æ•´æ£µæ ‘çš„æ·±åº¦ä¸º add()æ“ä½œ å¯¹äºadd(x,k)æ“ä½œï¼Œè‹¥è¦åœ¨æ•´æ£µæ ‘ä¸Šç»´æŠ¤è¿™ä¸ªå€¼ï¼Œéœ€è¦ä¸€å±‚ä¸€å±‚æ‰¾åˆ°çˆ¶èŠ‚ç‚¹ï¼Œå¹¶æŒ‰ç…§éœ€è¦æ¥ä¿®æ”¹è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ 123void add(int x,int k){ for(;x&lt;=n;x+=x&amp;-x) t[x]+=k; } æœ€åå¤æ‚åº¦ï¼š ask()æ“ä½œ å‘åä¸Šæ‰¾ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåªéœ€è¦å°†ä¸‹æ ‡-=lowbit(è¿™ä¸ªèŠ‚ç‚¹çš„ä¸‹æ ‡) 12345int ask(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t[x]; return ans; } æœ€åå¤æ‚åº¦ï¼š åº”ç”¨ æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ä¸ªåŠ¨æ€ç»´æŠ¤å‰ç¼€å’Œçš„å·¥å…· å•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ 12add(x,k); ans=ask(x)-ask(x-1); å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ 12add(x,k); ans=ask(r)-ask(l-1); åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ ç”±å·®åˆ†å¯çŸ¥ï¼ŒåŸæ•°ç»„ç¬¬ié¡¹å¯ä»¥ç”±å·®åˆ†æ•°ç»„ç¬¬1é¡¹åˆ°ç¬¬ié¡¹ç´¯åŠ è·å¾— åˆ™å¯¹äºåŒºé—´ä¿®æ”¹ï¼Œåªéœ€è¦åœ¨å¯¹åº”lä¸r+1å¤„è¿›è¡Œvalçš„ä¿®æ”¹å³å¯å®Œæˆå¯¹æ•´ä¸ªå·®åˆ†æ•°ç»„çš„ä¿®æ”¹ å¼•å…¥å·®åˆ†æ•°ç»„bï¼Œç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤bçš„å‰ç¼€å’Œï¼Œå³aæ•°ç»„æ¯ä¸ªå…ƒç´ çš„å¢é‡ åŒºé—´ä¿®æ”¹ï¼š add(l,d); add(r+1,-d) å•ç‚¹æŸ¥è¯¢ï¼šans = a[x]+ask(x) 12add(l,d); add(r+1,-d); ans=a[x]+ask(x); åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ å°†ké¡¹æ•°æŒ‰å·®åˆ†æ•°ç»„å’Œæ‹†å¼€åˆå¹¶å¦‚ä¸‹ æ•…æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸¤æ£µæ ‘ï¼Œè½¬æ¢ä¸ºå››æ¡add æŸ¥è¯¢æ“ä½œæŒ‰æ‰¾å…¬å¼åˆ†åˆ«è®¡ç®—ä¸¤æ£µæ ‘ è®¾æ ‘çŠ¶æ•°ç»„ç»´æŠ¤b[i]å‰ç¼€å’Œï¼Œç»´æŠ¤i*b[i]å‰ç¼€å’Œ åŒºé—´ä¿®æ”¹ï¼š å¯¹ï¼Œadd1(l,d), add1(r+1,-d) å¯¹ï¼Œadd2(l,(l-1)*d), add2(r+1,-r*d) åŒºé—´æŸ¥è¯¢ï¼šans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) 12345678910111213141516171819int t1[maxn],t2[maxn]; void add1(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t1[x]+=k; } int ask1(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t1[x]; return ans; } void add2(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t2[x]+=k; } int ask2(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t2[x]; return ans; } add1(l,d); add1(r+1,-d); add2(l,(l-1)*d); add2(r+1, -r*d); ans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) åº”ç”¨ï¼šé€†åºå¯¹ æŸ¥è¯¢ç¬¦åˆæ¡ä»¶é€†åºå¯¹æ€è·¯ ä»å³å¾€å·¦éå†ï¼Œæ¯æ¬¡å°†æœåˆ°çš„æ•°è®¡å…¥è¯é¢‘æ•°ç»„++ï¼Œå¹¶æŸ¥è¯¢è¯¥ä½ç½®å³ä¾§æœ‰å¤šå°‘å°äºè¯¥ä½ç½®æ•°çš„æ•°ï¼Œå¯ä»¥é€šè¿‡å¯¹è¯é¢‘æ•°ç»„è¿›è¡Œå‰ç¼€å’Œï¼ˆæ±‚å’Œåˆ°è¯¥ä½ç½®-1ï¼‰è·å¾— ç”±äºä¸€ç›´åœ¨æŸ¥è¯¢å‰ç¼€å’Œï¼Œå¯ä»¥å°†è¯é¢‘æ•°ç»„æ„å»ºæ ‘çŠ¶æ•°ç»„ï¼ŒæŸ¥è¯¢èƒ½åˆ°åˆ° ç”±äºè¯¥é¢˜æ•°æ®èŒƒå›´å¾ˆå¤§ï¼Œè‹¥ç›´æ¥å»ºç«‹æ ‘çŠ¶æ•°ç»„ç©ºé—´ä¼šç‚¸ï¼Œæ•…éœ€è¦ç¦»æ•£åŒ–è·å¾—æ•°æ®é—´çš„ç›¸å¯¹å¤§å° ç¦»æ•£åŒ– è¯¥æ ‘çŠ¶æ•°ç»„å«åšå€¼åŸŸæ ‘çŠ¶æ•°ç»„ï¼šä¸‹æ ‡ä¸ºå€¼ï¼Œå¯¹åº”å€¼ä¸ºè¯é¢‘ï¼Œæ•…ä¸‹æ ‡è¦æ”¯æŒå€¼åŸŸçš„æ•°æ®èŒƒå›´ å¤„ç†ï¼šå°†åŸæ•°ç»„å¤åˆ¶å¹¶æ’åºï¼Œä»å·¦åˆ°å³éå†ï¼Œä¸”è¦å°†ç›¸åŒå€¼å»æ‰ å›åˆ°åŸæ•°ç»„ï¼Œç”¨äºŒåˆ†æŸ¥æ‰¾å½“å‰æ•°åœ¨æ’åºæ•°ç»„ä¸­çš„ä½ç½®ï¼Œç”¨ä½ç½®ä¸‹æ ‡æ›¿æ¢å½“å‰å€¼ è¿™æ ·æ“ä½œç»“æŸåï¼Œæ•°ä¸æ•°ä¹‹é—´çš„ç›¸å¯¹å¤§å°æ²¡æœ‰å˜åŒ–ï¼Œæ•…é€†åºå¯¹çš„æ•°é‡ä¹Ÿä¸ä¼šå˜åŒ– 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 5e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll arr[N]; ll sorted[N]; ll tree[N]; ll n; void add(ll x,ll k){ for (;x&lt;=n;x+=x&amp;-x)tree[x]+=k; } ll ask(ll x){ ll ans = 0; for (;x;x-=x&amp;-x) ans += tree[x]; return ans; } void solve() { ll re = 0; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; arr[i]; sorted[i]=arr[i]; } sort(sorted+1,sorted+n+1); // å¯¹ç”¨äºç¦»æ•£åŒ–çš„æ•°ç»„æ’åº ll m = 1; // å¯¹sortedæ•°ç»„å»é‡ï¼Œä»¥å¾—åˆ°å®é™…å‚ä¸ç¦»æ•£åŒ–çš„èŒƒå›´1-m for (int i = 2;i&lt;=n;i++){ if(sorted[m]!=sorted[i]){ sorted[++m]=sorted[i]; } } // äºŒåˆ†æŸ¥æ‰¾ auto b_sort = [&amp;](ll x){ ll l = 0, r = m+1, ans = 0; while(l+1!=r){ ll mid = (l+r)/2; if (sorted[mid]&gt;=x){ //ans = mid; r=mid; } else l = mid; } return r; }; for (int i = 1;i&lt;=n;i++){ arr[i]=b_sort(arr[i]); // äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°å¯¹åº”æ•°åœ¨sortedçš„ä½ç½®å¹¶å°†å€¼æ›¿æ¢ä¸ºä¸‹æ ‡ï¼Œè¿›è¡Œç¦»æ•£åŒ– } for (int i = n;i&gt;=1;i--){ add(arr[i],1); // è¯é¢‘+1 re += ask(arr[i]-1); // å¯»æ‰¾å°äºå½“å‰æ•°-1çš„è¯é¢‘å‰ç¼€å’Œ } cout &lt;&lt;re &lt;&lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; }","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ã€é¢˜è§£ã€‘2025ç‰›å®¢å¯’å‡é›†è®­-2","slug":"2025ç‰›å®¢å¯’å‡é›†è®­-2","date":"2025-01-23T16:00:00.000Z","updated":"2025-01-25T05:02:24.367Z","comments":true,"path":"2025/01/24/2025ç‰›å®¢å¯’å‡é›†è®­-2/","permalink":"https://izayoisakuye.github.io/2025/01/24/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-2/","excerpt":"","text":"F-ä¸€èµ·æ‰¾ç¥ç§˜çš„æ•°ï¼ ^ï¼šçœ‹ä½œä¸å¸¦è¿›ä½çš„åŠ æ³• &amp;ï¼šçœ‹ä½œå“ªä½å‘ç”Ÿäº†è¿›ä½ï¼ˆè¿›ä½å°±æ˜¯1ï¼Œä¸è¿›ä½å°±æ˜¯0ï¼‰ |ï¼šä¸è¿›ä½ä¸‹å°±æ˜¯a+bï¼Œè¿›ä½å°±æ˜¯1 æ•…è‹¥ä¸¤ä½éƒ½ä¸º1ï¼Œåˆ™&amp;ä¸^ç»“æœéƒ½ä¸º1ï¼Œè‹¥ä¸¤ä½éƒ½ä¸º0ï¼Œåˆ™&amp;ä¸^ç»“æœéƒ½ä¸º0ï¼Œè‹¥ä¸€ä½æ˜¯0ä¸€ä½æ˜¯1åˆ™&amp;ä¸º0^ä¸º1 æ­¤æ—¶ä¸å’Œæˆ–è®¡ç®—æ±‚å’Œä»¥åå°±å¯ä¸åŸä¸¤æ•°ä¹‹å’Œç›¸ç­‰äº† åˆæ—¶æœ‰ï¼Œå› æ­¤ä¸¤æ•°ç›¸ç­‰çš„æ—¶å€™å°±å¯ä»¥æ»¡è¶³ç­‰å¼ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; while(n--){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (l==0 &amp;&amp; r==0) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } cout &lt;&lt; r-l+1 &lt;&lt; endl; } return 0; } G-ä¸€èµ·é“¸æœ€å¥½çš„å‰‘ï¼ æšä¸¾ï¼Œçœ‹å“ªæ¬¡æ›´æ¥è¿‘æœ€ä½³æ¸©åº¦ æ³¨æ„æ—¶ç”±äºæ€ä¹ˆä¹˜æ¸©åº¦éƒ½ä¸å¢é•¿ï¼Œæ•…ä¸€æ¬¡å³å¯æœ€è¿‘ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n, m; ll cnt = 1; cin &gt;&gt;n &gt;&gt;m; if (m==1||n==1){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } if (n&lt;m){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } ll tep = m; while(tep&lt;n){ tep*=m; cnt++; } if (abs(tep-n)&gt;=abs(tep/m-n)) cout &lt;&lt;cnt-1&lt;&lt;endl ; else cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } J-æ•°æ®æ—¶é—´ï¼Ÿ å¤§æ¨¡æ‹Ÿ æ³¨æ„ä¸¤ç‚¹ï¼š scanfæ ¼å¼åŒ–è¾“å…¥å¾ˆå¥½ç”¨ï¼Œå¯ä»¥å¿½ç•¥ä¸­é—´çš„é—´éš”ç¬¦ ç”±äºå‰å¯¼é›¶è¡¥é½ï¼Œæ—¥æœŸä¸æ—¶é—´çš„å¤§å°å¯ä»¥ç”¨å­—ç¬¦ä¸²ç›´æ¥æ¯”è¾ƒ ç”±äºåŒä¸€ä¸ªäººåœ¨åŒä¸€æ—¶æ®µå¤šæ¬¡ç™»å½•è§†ä½œä¸€æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠidæ’å…¥setå»é‡ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n, h, mon; struct node{ string id; int y, m, d; int hour, min, sec; }user[N]; set&lt;string&gt; work,nap,_sleep; // å¯¹åŒä¸€ä¸ªäººå»é‡ int main() { scanf(\"%d %d %d\",&amp;n,&amp;h,&amp;mon); //printf(\"%d %d %d\",n,h,mon); for (int i =1;i&lt;=n;i++){ cin &gt;&gt; user[i].id; scanf(\"%d-%d-%d %d:%d:%d \",&amp;user[i].y,&amp;user[i].m,&amp;user[i].d,&amp;user[i].hour,&amp;user[i].min,&amp;user[i].sec ); //å¥½ç”¨çš„æ ¼å¼åŒ–è¾“å…¥ } for (int i =1;i&lt;=n;i++){ if (user[i].y==h &amp;&amp; user[i].m==mon){ if ((user[i].hour&gt;=7 &amp;&amp; user[i].hour&lt;9)||(user[i].hour==9&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=18 &amp;&amp; user[i].hour&lt;20)||(user[i].hour==20&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=11 &amp;&amp; user[i].hour&lt;13)||(user[i].hour==13&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))nap.insert(user[i].id); else if ((user[i].hour&gt;=22 &amp;&amp; user[i].hour&lt;=23)||(user[i].hour&gt;=0 &amp;&amp; user[i].hour&lt;1)||(user[i].hour==1&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))_sleep.insert(user[i].id); } } printf(\"%d %d %d\",work.size(),nap.size(),_sleep.size()); return 0; } ç‰›å¯ä¹åœ¨æ¼”å¥ä»€ä¹ˆå¥½éš¾çŒœå‘¢ K-å¯ä»¥åˆ†å¼€å—ï¼Ÿ é›¢ã•ãªã„ã§ã„ã¦~ é€’å½’æ‰¾åˆ°è“è‰²åœ°æ¿åbfsæˆ–dfsæœç´¢è¿é€šå—ï¼ŒåŒæ—¶æ‰¾æ¯ä¸ªè¿é€šå—çš„æ¯ä¸ªè“è‰²åœ°æ¿å››è”é€šå‘¨å›´çš„ç°è‰²åœ°æ¿ å–æ‰€æœ‰è¿é€šå—å‘¨å›´ç°è‰²åœ°æ¿çš„æœ€å°å€¼ æ³¨æ„TLEæˆ–MLEï¼šä¸è¦åœ¨æ¯æ¬¡æœè¿é€šå—æ—¶memset visæ•°ç»„ï¼Œä¸ç„¶ä¼šè¶…æ—¶ æ³¨æ„æ³¨æ„ï¼šé¢˜ç›®è¾“å…¥æè¿°è¾“å…¥çš„æ˜¯01å­—ç¬¦ä¸²ï¼Œè°ƒäº†ä¸€ä¸‹åˆæœ€åæ‰å‘ç°æ˜¯è¿™é‡Œå‡ºäº†é—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 510; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int dx[]={1,0,-1,0}; int dy[]={0,1,0,-1}; int n,m; int re = INF; char floors[N][N]; bool vis[N][N]; void bfs(int x, int y){ queue&lt;PII&gt; q; PII cur, net; cur.first = x,cur.second = y; q.push(cur); bool visl[N][N]={}; // bfsæœç´¢è“ç“·ç –å‘¨å›´çš„ç°ç“·ç –æ—¶ä½¿ç”¨çš„è®¿é—®æ•°ç»„ int tot = 0; while(!q.empty()){ cur = q.front(); q.pop(); for (int i = 0;i &lt;4;i++){ net.first = cur.first+dx[i], net.second = cur.second+dy[i]; if (net.first&lt;1 || net.first&gt;n || net.second&lt;1 || net.second &gt;m) continue; // è¶Šç•Œ if (vis[net.first][net.second]) continue; // è®¿é—®è¿‡ if (floors[net.first][net.second]=='0'){ // æœåˆ°ç°ç“·ç – if (!visl[net.first][net.second]) tot++; // æœªè®¿é—®ï¼Œè®¡æ•° visl[net.first][net.second]=true; // æ ‡è®°è®¿é—® continue; } vis[net.first][net.second]=true; // æ ‡è®°è“ç“·ç –å·²ç»è®¿é—®è¿‡ q.push(net); } } re = min(re,tot); } int main() { ios cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { cin&gt;&gt;floors[i][j]; } } // æšä¸¾æŸ¥æ‰¾è“ç“·ç –è¿é€šå— for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { if (floors[i][j]=='1'&amp;&amp;!vis[i][j]) { // ç¢°åˆ°æœªæœè¿‡çš„è¿é€šå—å°±å¼€å§‹æœç°ç“·ç – bfs(i,j); } } } cout &lt;&lt; re; return 0; } D-å­—ç¬¦ä¸²é‡Œä¸² è¯¥å­—ç¬¦ä¸²æŸä¸€ä¸ªå‰ç¼€çš„æœ€åä¸€ä¸ªå­—æ¯åœ¨åé¢èƒ½å‡ºç°ç¬¬äºŒæ¬¡å³å¯æ»¡è¶³ æ³¨æ„ï¼Œä¹Ÿå¯ä»¥ä»åå¾€å‰çœ‹ï¼Œåç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯åœ¨å‰é¢èƒ½å‡ºç°ç¬¬äºŒæ¬¡å³å¯æ»¡è¶³ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; string s; int main() { ios cin &gt;&gt; n &gt;&gt; s; s=' '+s; map&lt;char,int&gt; mp1; map&lt;char,int&gt; mp2; int ans1=0,ans2=0; for (int i = 1;i&lt;=n;i++){ mp1[s[i]]++; if (mp1[s[i]]&gt;1){ ans1 = n-i+1; break; } } for (int i = n;i&gt;=1;i--){ mp2[s[i]]++; if (mp2[s[i]]&gt;1){ ans2 = i; break; } } int ans = max(ans1,ans2); ans==1?cout &lt;&lt; 0:cout &lt;&lt; ans; return 0; } H-ä¸€èµ·ç”»å¾ˆå¤§çš„åœ†ï¼ ç”±å‡ ä½•çŸ¥è¯†å¯å¾—ï¼Œå½“ä¸‰ç‚¹è¿çº¿è¶Šå‘æ¥è¿‘ç›´çº¿æ—¶ï¼Œè¿™ä¸‰ç‚¹æ‰€åœ¨çš„åœ†åŠå¾„è¶Šå¤§ï¼ˆç†è®ºä¸Šä¸‰ç‚¹åœ¨ä¸€æ¡ç›´çº¿ä¸Šæ—¶æ‰€åœ¨çš„åœ†æ˜¯æ— é™å¤§çš„ï¼‰ å¯¹äºä»¥ä¸‹ä¸€ç§æƒ…å†µæ˜¯å¯ä»¥å®ç°çš„ï¼š å³æ‰¾åˆ°ä¸€æ¡è¾¹ä¸Šæœ€å³ä¾§çš„ä¸€ç‚¹ä¸æ¬¡å³ä¾§çš„ä¸€ç‚¹ï¼Œä¸å¦ä¸€æ¡è¾¹ï¼ˆå¯¹ä¾§ï¼‰ä¸Šæœ€æ¥è¿‘å¦å¤–ä¸¤ç‚¹é‚£æ¡è¾¹ä¸‹é¢çš„ä¸€ç‚¹ å³ è‹¥çŸ©å½¢ç«–èµ·æ¥ï¼Œå¯¹åº”çš„ä¸‰ç‚¹ä¸º 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ vector&lt;PII&gt; re; int a,b,c,d; cin &gt;&gt;a &gt;&gt;b&gt;&gt;c&gt;&gt;d; if (b-a&gt;d-c){ // æ¨ªç€çš„çŸ©å½¢ re.push_back({b,d}); re.push_back({b-1,d}); re.push_back({a,d-1}); } else{ // ç«–ç€çš„çŸ©å½¢ re.push_back({a,c}); re.push_back({a,c+1}); re.push_back({a+1,d}); } for (auto t:re) cout &lt;&lt; t.first &lt;&lt;' '&lt;&lt;t.second &lt;&lt; endl; } return 0; } C-å­—ç¬¦ä¸²å¤–ä¸² å¯ä»¥å°†æ„é€ çš„å­—ç¬¦ä¸²åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†ä¸ºæ»¡è¶³å¯çˆ±åº¦çš„mä¸ªå­—ç¬¦ï¼Œç¬¬äºŒéƒ¨åˆ†ä¸ºå‰©ä¸‹çš„å­—ç¬¦ ç”±Då¯çŸ¥ï¼Œè‹¥ç¬¬äºŒéƒ¨åˆ†ä¸­å‡ºç°äº†é‡å¤å­—ç¬¦ï¼Œåˆ™å¯çˆ±åº¦ä¸€å®šä¼šå¤§äºmï¼Œæ•…ä¸æ»¡è¶³æ¡ä»¶ï¼› è‹¥æ€»é•¿åº¦å°äºå¯çˆ±åº¦é‚£ä¸€å®šä¸å¯èƒ½æœ‰æ»¡è¶³çš„å­—ç¬¦ä¸² è¿™ä¸¤ç§æƒ…å†µå¯ä»¥è¾“å‡ºNO æ•…æˆ‘ä»¬åªè¦ä¿è¯ç¬¬ä¸€éƒ¨åˆ†çš„ç»“å°¾å­—æ¯ä¸ç¬¬äºŒéƒ¨åˆ†çš„ç»“å°¾å­—æ¯ç›¸åŒå³å¯ ä¸€ç§å¯èƒ½çš„æ„é€ æ–¹æ³•ï¼š å…ˆæ„é€ ç¬¬äºŒéƒ¨åˆ†ï¼ŒæŒ‰å­—æ¯è¡¨é¡ºåºå¡«å……n-mä¸ªå­—ç¬¦ã€‚ å†æ„é€ ç¬¬ä¸€éƒ¨åˆ†ï¼Œè®©ç¬¬äºŒéƒ¨åˆ†åå¤å‡ºç°å³å¯ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n ,m; cin &gt;&gt; n &gt;&gt; m; if (n&lt;=m || m+26&lt;n) { // ç‰¹æ®Šæ¡ä»¶ cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } cout &lt;&lt; \"YES\"&lt;&lt;endl; string s; for (int i = 0;i&lt;n;i++){ s.push_back('a'+i%(n-m)); // å¾ªç¯æ’å…¥ç¬¬äºŒéƒ¨åˆ†çš„å­—ç¬¦ } cout &lt;&lt; s &lt;&lt;endl; } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"ã€ç®—æ³•ã€‘æ»‘åŠ¨çª—å£","slug":"æ»‘åŠ¨çª—å£","date":"2025-01-23T02:39:01.000Z","updated":"2025-01-23T13:27:35.824Z","comments":true,"path":"2025/01/23/æ»‘åŠ¨çª—å£/","permalink":"https://izayoisakuye.github.io/2025/01/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"æ»‘åŠ¨çª—å£ å®šä¹‰ åœ¨ä¸€ä¸ªæ•°ç»„ä¸­æ¡†å®šä¸€æ®µå­æ•°ç»„ä½œä¸ºçª—å£ è‹¥æƒ³è®©è¯¥çª—å£å…ƒç´ å¢åŠ ï¼Œå¯ä»¥è€ƒè™‘è®©å³è¾¹ç•Œr++ï¼Œå³çª—å£ä»å³è¾¹å¸æ”¶æ•°å­— è‹¥æƒ³è®©è¯¥çª—å£å…ƒç´ å‡å°‘ï¼Œå¯ä»¥è€ƒè™‘è®©å·¦è¾¹ç•Œl++ï¼Œå³çª—å£ä»å·¦è¾¹å¼¹å‡ºæ•°å­— ä¸€èˆ¬è§£å†³å­æ•°ç»„ç›¸å…³é—®é¢˜ ä¾‹1/æ¨¡æ¿ ç»™å®šä¸€ä¸ªå«æœ‰ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•°target æ‰¾åˆ°ç´¯åŠ å’Œtargetçš„é•¿åº¦æœ€å°çš„å­æ•°ç»„å¹¶è¿”å›é•¿åº¦ï¼Œå¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„åˆ™è¿”å›0 æˆ‘ä»¬å¯ä»¥å…ˆå›ºå®šå­æ•°ç»„çš„å·¦ç«¯ç‚¹ï¼Œè®©å³ç«¯ç‚¹å³ç§»ï¼Œç›´åˆ°æ•°ç»„å’Œå¤§äºtargetï¼Œç”±äºæ•°ç»„æ‰€æœ‰æ•°éƒ½ä¸ºæ­£æ•´æ•°ï¼Œå› æ­¤æ‰¾åˆ°ç¬¬ä¸€ä¸ªç´¯åŠ å’Œå¤§äºtargetåï¼Œåé¢å†åŠ ä¸€å®šä¹Ÿå¤§äºtarget æ­¤æ—¶å¾ªç¯åˆ¤æ–­ç´¯åŠ å’Œæ˜¯å¦targetï¼Œè‹¥æˆç«‹åˆ™å‰”å‡ºå·¦ä¾§æ•°å­—ï¼Œè®°å½•å­æ•°ç»„é•¿åº¦ ç„¶åä»¥è¯¥å­æ•°ç»„ä¸ºèµ·ç‚¹ï¼Œå³ç«¯ç‚¹å³ç§»ï¼Œé‡å¤ä¸Šè¿°æ“ä½œï¼Œå¯»æ‰¾ç­‰äºtargetçš„å­æ•°ç»„ï¼Œè®°å½•æ•°ç»„é•¿åº¦ æ—¶é—´å¤æ‚åº¦ï¼š 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,tar; int a[N]; int main() { ios cin &gt;&gt; n &gt;&gt; tar; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } int ans = 0x3f3f3f3f, sum = 0, l = 0; // å®šä¹‰è®°å½•ç»“æœé•¿åº¦ï¼Œæ•°ç»„å…ƒç´ ä¹‹å’Œï¼Œå·¦ç«¯ç‚¹ for (int r = 1;r&lt;=n;r++){ // å…ˆè®©å³ç«¯ç‚¹å³ç§» sum+=a[r]; // ç´¯åŠ æ±‚å’Œ while(sum&gt;=tar){ // å½“æ±‚å’Œå¤§äºç­‰äºç›®æ ‡å¼€å§‹ç§»åŠ¨å·¦ç«¯ç‚¹ä»¥å¯»æ‰¾æ›´å°åŒºé—´ ans = min(ans,r-l+1); // æ›´æ–°æœ€å°åŒºé—´ sum-=a[l++]; // å‡å»æ»‘å‡ºçª—å£çš„æ•°åŒæ—¶è®©å·¦ç«¯ç‚¹å³ç§» } } // æ‰¾åˆ°ç¬¦åˆç›®æ ‡çš„åŒºé—´ if (ans&lt;=n) cout &lt;&lt; ans; else cout &lt;&lt; 0 ; return 0; } ä¾‹2 ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­—ä¸²é•¿åº¦ å³å¯»æ‰¾æœ€é•¿æ— é‡å¤å­—ç¬¦çš„çª—å£ è®©å³è¾¹ç•Œä¸€ç›´å³ç§»ï¼Œç›´åˆ°é‡åˆ°é‡å¤å­—ç¬¦ï¼Œè®©å·¦è¾¹ç•Œç§»åŠ¨åˆ°max(å·¦è¾¹ç•Œï¼Œé‡å¤å­—ç¬¦ä¸Šæ¬¡ä½ç½®+1) å› ä¸ºä»»ä½•æ—¶å€™çª—å£æƒ…å†µä¸€å®šæ˜¯æ²¡æœ‰é‡å¤æ•°ç»„åœ¨å†…çš„ï¼Œè‹¥é‡å¤å­—ç¬¦ä¸Šæ¬¡ä½ç½®æ¯”æ­¤æ—¶å·¦è¾¹ç•Œå°ï¼Œåˆ™è‹¥è¿˜æ˜¯ç§»åŠ¨åˆ°é‡å¤å­—ç¬¦ä¸Šæ¬¡ä½ç½®+1çš„è¯ï¼Œçª—å£ä¼šå˜é•¿ï¼Œä¸ä¿è¯åŠ é•¿éƒ¨åˆ†ä¼šä¸ä¼šåˆå‡ºç°é‡å¤å­—ç¬¦ è‹¥å³ç§»åæ— é‡å¤å­—ç¬¦ï¼Œå¯ä»¥çœ‹ä½œé‡å¤å­—ç¬¦ä½ç½®ä¸º-1æˆ–ä¸å­˜åœ¨ï¼Œç”¨maxä»ä¿æŒåŸå·¦è¾¹ç•Œ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s; for (int i = 0;i&lt;s.size();i++) cnt[s[i]]=-1; // åˆå§‹åŒ–éƒ½ä¸ºç¬¬ä¸€æ¬¡å‡ºç° int ans = 0; // è®°å½•æœ€é•¿åŒºé—´ for (int l = 0, r = 0;r&lt;s.size();r++){ l = max(l,cnt[s[r]]+1); // å·¦è¾¹ç•Œç§»åŠ¨ ans = max(ans,r-l+1); // è®°å½•ç»“æœ cnt[s[r]]=r; // æ›´æ–°ä¸Šæ¬¡å‡ºç°å­—ç¬¦ä½ç½®ä¸ºå½“å‰rä½ç½® } cout &lt;&lt; ans; return 0; } ä¾‹3 ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ã€ä¸€ä¸ªå­—ç¬¦ä¸² t ã€‚è¿”å› s ä¸­æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ s ä¸­ä¸å­˜åœ¨æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² \"\" ã€‚ æˆ‘ä»¬å¯ä»¥é€†å‘ä»¥ä¸€ç§â€debtâ€æ€ç»´è§£å†³ã€‚éå†è¦æŸ¥æ‰¾çš„å­—ç¬¦ï¼Œå‘ç°ä¸€ä¸ª-1ï¼Œè¿™æ ·éœ€è¦æŸ¥æ‰¾çš„å­—ç¬¦æ•°éƒ½ä¸ºè´Ÿæ•°ï¼Œåœ¨æŸ¥æ‰¾æ—¶ï¼Œæ¯ä¸ªå­—ç¬¦å‡ºç°åå¯¹åº”åŠ ä¸€ï¼Œåˆ™é è¦æŸ¥æ‰¾å­—ç¬¦å°†å§‹ç»ˆä¸ºæ­£æ•°ï¼Œè€Œè¦æŸ¥æ‰¾çš„å­—ç¬¦ä¸ºè´Ÿæ•° å…ˆè®©å³è¾¹ç•Œå³ç§»ï¼Œå½“debtå˜ä¸º0ï¼ˆçª—å£åŒ…å«äº†è¶³å¤Ÿè¦æŸ¥æ‰¾çš„å­—ä¸²ï¼‰ï¼Œå¼€å§‹ç§»åŠ¨å·¦è¾¹ç•Œï¼Œä½¿å­—ä¸²æœ€å°ï¼Œè¿™æ—¶debtå¤§äº0çš„éƒ½ä¸ºä¸éœ€è¦æŸ¥æ‰¾çš„å­—ç¬¦ï¼Œæ•…å¯ä»¥å·¦ç§»ï¼Œç›´åˆ°ç¢°åˆ°éœ€è¦æŸ¥æ‰¾çš„ä¸å†ç§»åŠ¨ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s,t; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s &gt;&gt; t; if (s.size()&lt;t.size()){ cout &lt;&lt; \"\"; return 0; } for (int i = 0;i&lt;t.size();i++) cnt[t[i]]--; int len = INF, start = 0; // lenç”¨äºè®°å½•æœ€å°å­—ä¸²ï¼Œstartè®°å½•å­—ä¸²å¼€å¤´ï¼Œä¾¿äºè¾“å‡º int debt = t.size(); for (int l = 0, r = 0;r&lt;s.size();r++){ if (cnt[s[r]]++&lt;0) debt--; // å­—ç¬¦è®¡æ•°åŠ ä¸€åä»æ˜¯è´Ÿçš„ï¼Œè¯æ˜æ˜¯è¦æŸ¥æ‰¾çš„(debtçš„)å­—ç¬¦ï¼Œè®©debt-- if(debt==0){ // æ‰€æœ‰å­—ç¬¦éƒ½æŸ¥åˆ°å while(cnt[s[l]]&gt;0){ // å¯»æ‰¾æœ€å°å­åŒºé—´ cnt[s[l++]]--; // è‹¥æ˜¯éæŸ¥æ‰¾å­—ç¬¦ï¼Œå¯ä»¥è®©å·¦è¾¹ç•Œå³ç§»æ‹¿å› } if (r-l+1&lt;len){ // è®°å½•æœ€å°å­åŒºé—´ä»¥åŠå¼€å§‹ä½ç½® len = r-l+1; start = l; } } } // è‹¥æŸ¥ä¸åˆ°åˆ™è¾“å‡ºç©ºå­—ç¬¦ä¸²ï¼Œå¦åˆ™æˆªå–å­—ç¬¦ä¸²è¾“å‡º len == INF ? cout &lt;&lt;\"\" : cout &lt;&lt; s.substr(start,start+len); return 0; } æ€»ç»“ å…³é”®ï¼šæ‰¾åˆ°èŒƒå›´å’Œç­”æ¡ˆæŒ‡æ ‡ä¹‹é—´çš„å•è°ƒæ€§å…³ç³» æ±‚è§£å¤§æµç¨‹ï¼šæ±‚å­æ•°ç»„åœ¨æ¯ä¸ªä½ç½®å¼€å¤´æˆ–ç»“å°¾æƒ…å†µä¸‹çš„ç­”æ¡ˆ","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘ä¼˜å…ˆé˜Ÿåˆ—","slug":"ä¼˜å…ˆé˜Ÿåˆ—(priority_queue)","date":"2025-01-22T13:35:19.944Z","updated":"2025-01-23T12:54:03.554Z","comments":true,"path":"2025/01/22/ä¼˜å…ˆé˜Ÿåˆ—(priority_queue)/","permalink":"https://izayoisakuye.github.io/2025/01/22/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97(priority_queue)/","excerpt":"","text":"ä¼˜å…ˆé˜Ÿåˆ—(priority_queue) ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥ç”¨æ¥å­˜å‚¨å…·æœ‰ä¼˜å…ˆçº§çš„å…ƒç´ ï¼Œé˜Ÿå¤´çš„å…ƒç´ éƒ½æ˜¯å½“å‰é˜Ÿåˆ—ä¸­ä¼˜å…ˆçº§æœ€é«˜(æˆ–æœ€ä½)çš„å…ƒç´  STLä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—é»˜è®¤ä¸ºæœ€å¤§å †ï¼Œå³ä¼˜å…ˆçº§æœ€é«˜çš„å…ˆå‡ºé˜Ÿ ç»“æ„ ä¼˜å…ˆé˜Ÿåˆ—çš„ç»“æ„ ä¼˜å…ˆé˜Ÿåˆ—ä»…ç»´æŠ¤å †é¡¶(top)ï¼Œå…¶ä½™å…ƒç´ ä¼˜å…ˆçº§éƒ½æ¯”å †é¡¶å° åˆå§‹åŒ– ä¼˜å…ˆé˜Ÿåˆ—ä½¿ç”¨éœ€è¦å¼•å…¥å¤´æ–‡ä»¶queue å¦‚ä¸‹ä»£ç å¯ä»¥å£°æ˜ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œå…¶ä¸­Tä¸ºæ•°æ®ç±»å‹ï¼Œä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æ•°æ®æ•°æ®ç±»å‹éƒ½ç›¸åŒ æ³¨æ„ï¼šä½¿ç”¨ç»“æ„ä½“æ—¶ï¼Œéœ€è¦é‡è½½å°äºå·æˆ–å£°æ˜ä¸€ä¸ªæ¯”è¾ƒç±»å¹¶é‡è½½()è¿ç®—ç¬¦ 123456789101112131415161718192021222324#include &lt;bits\\stdc++.h&gt; using namespace std; struct node{ int x, y; // ä½¿ç”¨ç»“æ„ä½“éœ€è¦é‡è½½å°äºå· bool operator &lt; (const node &amp;u)const{ return x == u.x? y&lt;u.y : x&lt;u.x; } }; // æˆ–é‡è½½()è¿ç®—ç¬¦å®ç°æ¯”è¾ƒ struct cmp{ bool operator ()(const int &amp;u, const int &amp;v)const{ return u&gt;v; } }; int main(){ // å£°æ˜ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ•´å‹ï¼Œé»˜è®¤å¤§é¡¶å †(æœ€å¤§å…ƒç´ åœ¨é¡¶ä¸Š) // ä¸€èˆ¬å£°æ˜ä¸€ä¸ªç©ºä¼˜å…ˆé˜Ÿåˆ— priority_queue&lt;T&gt; pque; // å£°æ˜ä¸€ä¸ªå°é¡¶å †,ä¼ å…¥ä»¿å‡½æ•°, ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºä¼˜å…ˆé˜Ÿåˆ—åº•å±‚å‚¨å­˜å®¹å™¨ä¸ºvector priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; } åŸºæœ¬æ“ä½œ 1234567891011121314// å–å‡ºå †é¡¶ cout &lt;&lt; pque.top() &lt;&lt; endl; // æ’å…¥å…ƒç´ åˆ°é˜Ÿå°¾å¹¶æ‰§è¡Œä¸Šæµ®æ“ä½œ pque.push(1); // å¼¹å‡ºå †é¡¶ pque.pop(); // è¿”å›é˜Ÿåˆ—å…ƒç´ ä¸ªæ•° cout &lt;&lt; pque.size() &lt;&lt; endl; // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º cout &lt;&lt; pque.empty() &lt;&lt; endl; //é—´æ¥ä¿®æ”¹å †é¡¶å…ƒç´  int x = pque.top(); pque.pop(); pque.push(x+1); æ³¨æ„ï¼špriority_queueæ²¡æœ‰è¿­ä»£å™¨ï¼Œä¸èƒ½ç”¨begin()ï¼Œend()ï¼Œautoç­‰éå†ï¼Œä¹Ÿä¸èƒ½ç›´æ¥ä¿®æ”¹é˜Ÿåˆ—ä¸­çš„å…ƒç´ ","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"}]},{"title":"ã€é¢˜è§£ã€‘2025ç‰›å®¢å¯’å‡é›†è®­-1","slug":"2025ç‰›å®¢å¯’å‡é›†è®­-1","date":"2025-01-21T14:15:49.000Z","updated":"2025-01-23T02:30:49.763Z","comments":true,"path":"2025/01/21/2025ç‰›å®¢å¯’å‡é›†è®­-1/","permalink":"https://izayoisakuye.github.io/2025/01/21/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-1/","excerpt":"","text":"(æŒ‰å®˜æ–¹éš¾åº¦æ’åº) A-èŒ•èŒ•å­‘ç«‹ä¹‹å½± è€ƒè™‘ç‰¹æ®Šæƒ…å†µï¼šè‹¥æ•°ç»„ä¸­åŒ…å«1ï¼Œåˆ™ä¸€å®šæ˜¯1çš„å€æ•°ï¼Œå¯ä»¥ç›´æ¥è¾“å‡º-1 è€ƒè™‘ä¸€èˆ¬æƒ…å†µï¼šè´¨æ•°çš„å› æ•°åªæœ‰1å’Œä»–æœ¬èº«ï¼Œåˆæ•°ç»„ä¸­ä¸å«1ï¼Œå› æ­¤ä»»æ„ä¸€ä¸ªæ¯”è¯¥æ•°ç»„ä¸­æœ€å¤§æ•°è¿˜å¤§çš„è´¨æ•°è‚¯å®šä¸æ˜¯æ•°ç»„ä¸­çš„å€æ•°ï¼Œåˆå› ä¸ºè¯¥æ•°éƒ½æ¯”æ•°ç»„ä¸­çš„æ•°å¤§ï¼Œå› æ­¤ä¹Ÿä¸å¯èƒ½æ˜¯ä»–çš„å€æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; bool is_prime(int n){ if (n==1) return 0; if (n==2) return 1; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0) return 0; } return 1; } int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } for (int i = 1;i&lt;=n;i++){ if (a[i]==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; break; } } if (flag) continue; cout &lt;&lt; 1000000007 &lt;&lt; endl; } return 0; } D-åŒç”ŸåŒå®¿ä¹‹å†³ ç”¨mapå­˜å‚¨å‡ºç°æ•°å­—æ¬¡æ•°åæ¯”è¾ƒå³å¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,cnt=0; map&lt;int,int&gt; a; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; a[tep]++; } if (n&amp;1){ cout &lt;&lt; \"No\" &lt;&lt; endl; continue; } if (a.size()!=2){ // åˆ¤æ–­å€¼çš„ä¸ªæ•°ç”¨size cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } else{ set&lt;int&gt; tep; for (auto &amp;pr:a){ tep.insert(pr.second); } if (tep.size()!=1) { cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } } cout &lt;&lt; \"Yes\"&lt;&lt;endl; } return 0; } B-ä¸€æ°”è´¯é€šä¹‹åˆƒ å³åˆ¤æ–­è¿™äº›èŠ‚ç‚¹èƒ½ä¸èƒ½è¿æˆä¸€æ¡é“¾ï¼Œè‹¥æ˜¯çš„è¯è¾“å‡ºå¤´å°¾ï¼Œä¸æ˜¯çš„è¯è¾“å‡º-1 è‹¥æœ‰ä¸¤ä¸ªèŠ‚ç‚¹åº¦æ•°ä¸º1ï¼Œå…¶ä½™èŠ‚ç‚¹åº¦æ•°éƒ½ä¸º2åˆ™æ˜¯ä¸€æ¡é“¾ æ•…å¯ä»¥ç”¨mapè®°å½•æ¯ä¸ªèŠ‚ç‚¹å‡ºç°æ¬¡æ•°å¹¶åˆ¤æ–­ 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=(n-1)*2;i++){ int tep; cin &gt;&gt; tep; num[tep]++; } vector&lt;int&gt; p; for (auto &amp;pr:num){ if (pr.second&gt;2){ cout &lt;&lt; -1 &lt;&lt; endl; return 0; } if (pr.second==1)p.push_back(pr.first); } for (auto t:p) cout &lt;&lt; t &lt;&lt;' '; return 0; } G-äº•ç„¶æœ‰åºä¹‹è¡¡ ç”±äºåŒæ—¶åŠ ä¸€å‡ä¸€å¯¹æ•°ç»„æ€»å’Œæ²¡æœ‰å½±å“ï¼Œè€Œæœ€åç”Ÿæˆçš„permutationæ­£å¥½ä¸ºä¸€ä¸ªçš„ç­‰å·®æ•°åˆ—ï¼Œæ•…å¯ä»¥å®ç°çš„æ¡ä»¶ä¸ºæ•°ç»„æ•°å€¼ä¹‹å’Œç­‰äºè¯¥ç­‰å·®æ•°åˆ—å‰é¡¹å’Œ å°†æ•°ç»„æ’åºï¼Œæ¯ä¸€ä½æ­£å¥½å¯¹åº”permutationä»1å¼€å§‹çš„æ¯ä¸€ä½ï¼Œè®¡ç®—æ¯ä½æ•°ä¸å¯¹åº”permutationä¹‹å·®æ±‚å’Œå³å¯ä»¥å¾—åˆ°éœ€è¦æ“ä½œå¤šå°‘æ¬¡åŠ ä¸€æˆ–å‡ä¸€æ‰èƒ½å˜æˆå¯¹åº”permutation æ³¨æ„ï¼šä¸€æ¬¡æ“ä½œåŒ…å«ä¸€æ¬¡åŠ ä¸€ä¸ä¸€æ¬¡å‡ä¸€ï¼Œæ•…æœ€åç»“æœè¦é™¤äºŒ 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll n,op; ll a[N]; int main() { ios cin &gt;&gt;n; ll sum=0; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; sum+=a[i]; } if (1ll*n*(n+1)/2!=sum){ cout &lt;&lt; -1; return 0; } sort(a+1,a+1+n); for (int i = 1;i&lt;=n;i++){ op += abs(a[i]-i); } cout &lt;&lt; op/2; return 0; } E-åŒç”ŸåŒå®¿ä¹‹é”™ ä¸­ä½æ•°å®šç†ï¼š ä¸­ä½æ•°æœ‰ä¸€ä¸ªæ€§è´¨ï¼šä¸€ä¸ªæ•°åˆ—ä¸­æ‰€æœ‰æ•°ä¸ä¸­ä½æ•°ä¹‹å·®çš„ç»å¯¹å€¼ä¹‹å’Œæœ€å°ï¼Œå› ä¸ºä¸­ä½æ•°æ˜¯å¤„äºä¸­é—´çš„æ•° å³è‹¥è¦é€šè¿‡åŠ ä¸€å‡ä¸€å°†ä¸€ä¸ªæ•°ç»„æ‰€æœ‰æ•°å˜ä¸ºç›¸åŒï¼Œæœ€å°‘æ“ä½œæ¬¡æ•°å³å°†ä»–ä»¬å˜ä¸ºä¸­ä½æ•° å¯¹äºè¿™é“é¢˜ï¼Œæˆ‘ä»¬è¦åšåˆ°çš„æ˜¯å°†æ•°ç»„æ‰€æœ‰æ•°å˜ä¸ºä¸¤ä¸ªæ•°ï¼Œä¸”å‡ºç°æ¬¡æ•°ç›¸åŒï¼Œæ•…æˆ‘ä»¬å¯ä»¥æŒ‰ç…§Dé¢˜çš„æ€è·¯ï¼Œå°†æ•°ç»„æ’åºååˆ†ä¸ºå‰åä¸¤éƒ¨åˆ†ï¼Œåˆ†åˆ«æ±‚å‡ºå…¶ä¸­ä½æ•°åè®¡ç®—ä¸¤éƒ¨åˆ†å„è¾¾åˆ°å„è‡ªä¸­ä½æ•°æ‰€éœ€è¦çš„æ“ä½œæ¬¡æ•°æ±‚å’Œ è‹¥ä¸¤ä¾§ä¸­ä½æ•°ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†å‰åŠéƒ¨åˆ†ä¸­ä½æ•°-1æˆ–å°†ååŠéƒ¨åˆ†ä¸­ä½æ•°+1å¹¶è®¡ç®—ï¼Œå–æœ€ä¼˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n,op=0; ll a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); // æ’åº ll midl = a[((n/2)+1)/2], midr = a[((n/2)+1)/2+n/2]; // è®¡ç®—å‰åä¸¤éƒ¨åˆ†ä¸­ä½æ•° //cout &lt;&lt; midl &lt;&lt; ' ' &lt;&lt; midr &lt;&lt; endl ; if (midl!=midr){ // æ­£å¸¸æƒ…å†µ // åˆ†ä¸¤éƒ¨åˆ†è®¡ç®—åˆ°è¾¾ä¸­ä½æ•°æ‰€éœ€è¦çš„æ“ä½œæ¬¡æ•° for (int i = 1;i&lt;=n/2;i++){ op+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op+=abs(a[i]-midr); } cout &lt;&lt; op &lt;&lt; endl; } else{ // ä¸¤ä¾§ä¸­ä½æ•°ç›¸ç­‰ // å°†å·¦ä¾§ä¸­ä½æ•°-1å¹¶è®¡ç®—æ“ä½œæ¬¡æ•° ll mid1 = midl-1; ll op1 = 0; for (int i = 1;i&lt;=n/2;i++){ op1+=abs(a[i]-mid1); } for (int i = n/2+1;i&lt;=n;i++){ op1+=abs(a[i]-midr); } // å°†å³ä¾§ä¸­ä½æ•°+1å¹¶è®¡ç®—æ“ä½œæ¬¡æ•° ll mid2 = midr+1; ll op2 = 0; for (int i = 1;i&lt;=n/2;i++){ op2+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op2+=abs(a[i]-mid2); } // è¾“å‡ºæ›´ä¼˜ç»“æœ cout &lt;&lt; min(op1,op2)&lt;&lt;endl; } } return 0; } H-äº•ç„¶æœ‰åºä¹‹çª— å¯¹äºnä¸ªåŒºé—´é€‰æ•°ï¼ŒåŒºé—´å†…æ•°å¤šè¦å°½é‡æ”¾åœ¨åé¢é€‰ï¼Œå› ä¸ºé€‰æ‹©å¯èƒ½æ€§æ›´å¤š åœ¨é€‰ç¬¬iä¸ªæ•°æ—¶ï¼Œæˆ‘ä»¬çš„é‡ç‚¹æ˜¯å³ç•Œçš„å¤§å°ï¼Œä¸ç®¡å·¦è¾¹ä»å“ªå¼€å§‹éƒ½å¯ä»¥çœ‹æˆä»iå¼€å§‹ï¼Œå› ä¸ºå…¶ä½™çš„å·²ç»æ”¾å®Œäº† e.g. åŒºé—´ [1,3] [5,5] [3,5] [2,7] [3,4] [2,4] [4,7] permutation 1 5 4 6 3 2 7 å› æ­¤æˆ‘ä»¬å¯ä»¥æ€»ç»“å¦‚ä¸‹æ­¥éª¤ æŒ‰å·¦ç•Œæ’åºï¼šå†³å®šièƒ½ä¸èƒ½æ”¾è¿›å»ï¼ˆå·¦ç•Œç›¸ç­‰æ—¶å³ç•Œå°çš„åœ¨å‰ï¼‰ æ¯æ¬¡è¯¢é—®iæ”¾åœ¨å“ªä¸ªåŒºé—´æ—¶ï¼Œæ‰¾å‡ºå¯¹åº”å·¦ç•Œä¸ºiçš„åŒºé—´ï¼Œæ”¾å…¥å³ç•Œæ›´å°çš„åŒºé—´å†… å› æ­¤éœ€è¦ä¸€ä¸ªå®¹å™¨æ¥å­˜å‚¨åŒºé—´ æ­¤æ—¶ï¼Œæ”¾å…¥çš„åŒºé—´åº”ä¸ºå½“å‰å·¦ç•Œä¸ºiçš„åŒºé—´ä¸å·¦ç•Œä¸ºi-1ä¸”æ²¡è¢«ç”¨è¿‡çš„åŒºé—´ï¼Œè¦åœ¨è¿™äº›åŒºé—´ä¸­å¯»æ‰¾å³ç•Œæ›´å°çš„åŒºé—´ ä¹Ÿå°±æ˜¯æ¯æ¬¡å¾€è¯¥å®¹å™¨é‡Œå¡«å…¥åŒºé—´ï¼Œå¹¶æŠŠå®¹å™¨å†…æ‰€æœ‰åŒºé—´æ’åºï¼Œå–å‡ºå³ç•Œæœ€å°çš„åŒºé—´ï¼Œå½“å‰iå¯ä»¥æ”¾åœ¨è¯¥åŒºé—´å†… æ•…æˆ‘ä»¬å¯ä»¥ä½¿ç”¨priority_queueå®ç°ï¼Œä¸”ä¸ºå°æ ¹å † 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; vector&lt;vector&lt;PII&gt;&gt; a(n+10); // æŒ‰å·¦ç«¯ç‚¹åˆ†ç±»å­˜å…¥åŒºé—´å³ç«¯ç‚¹ä¸åŒºé—´ä½ç½® for (int i = 1;i&lt;=n;i++){ int l,r; cin &gt;&gt; l &gt;&gt; r; a[l].push_back({r,i}); } int ans[N]; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;&gt;&gt; pq; for (int i = 1;i&lt;=n;i++){ // è¯¢é—®å“ªä¸ªæ•°å°±æŠŠè¯¥æ•°æ‰€åœ¨çš„åŒºé—´å·¦ç•Œçš„åŒºé—´å³ç•Œä¸åŒºé—´ä½ç½®æ·»å…¥ä¼˜å…ˆé˜Ÿåˆ— for (auto &amp;pr:a[i]) pq.push(pr); // åˆ¤æ–­å½“å‰æ•°æ˜¯å¦èƒ½ä»åŒºé—´ä¸­å–åˆ°ï¼Œè‹¥ä¸èƒ½å°±popæ¢ä¸‹ä¸€ä¸ª while(!pq.empty() &amp;&amp; pq.top().first&lt;i) pq.pop(); // è‹¥éƒ½ä¸èƒ½ä»å½“å‰åŒºé—´ä¸­å–åˆ°ï¼Œè¡¨æ˜ä¸å­˜åœ¨æ»¡è¶³çš„ï¼Œç›´æ¥-1 if (pq.empty()) { cout &lt;&lt; -1 ; return 0; } // è®°å½•å½“å‰æ•°æ‰€åœ¨çš„åŒºé—´ä½ç½® ans[pq.top().second]=i; pq.pop(); } for (int i = 1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"ã€é¢˜è§£ã€‘Codeforces Round 998 (Div. 3)","slug":"Codeforces-Round-998-Div-3","date":"2025-01-21T14:15:30.000Z","updated":"2025-01-22T06:08:35.976Z","comments":true,"path":"2025/01/21/Codeforces-Round-998-Div-3/","permalink":"https://izayoisakuye.github.io/2025/01/21/Codeforces-Round-998-Div-3/","excerpt":"","text":"A- Fibonacciness é¢˜æ„ ç»™äºˆï¼Œæ±‚æ»¡è¶³çš„ æ€è·¯ æšä¸¾æ‰€æœ‰å¯èƒ½çš„å–æœ€å¤§å€¼ï¼Œæœ‰ä»¥ä¸‹æƒ…å†µ ä»£ç  123456789101112131415161718192021222324252627282930313233// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int a1,a2,a4,a5; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a4 &gt;&gt; a5; int a31 = a1+a2; int a32 = a4-a2; int a33 = a5-a4; if (a31==a32 &amp;&amp; a32 == a33) cout &lt;&lt; 3 &lt;&lt; endl; else if (a31==a32 || a32 == a33 || a31==a33) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; } return 0; } B-Farmer Johnâ€™s Card Game é¢˜æ„ ä¸ªäººæ‰‹é‡Œæœ‰å¼ ç‰Œï¼Œæ¯ä¸ªäººæ¯è½®å‡ºä¸€å¼ ç‰Œåœ¨ç‰Œå †ä¸Šï¼Œéœ€è¦æ»¡è¶³ç‰Œä¸Šæ•°å­—å¤§äºç‰Œå †é¡¶æ•°å­—ï¼Œè‹¥æŸäººæ— æ³•é˜²æ­¢æ»¡è¶³æ¡ä»¶çš„ç‰Œï¼ˆæ‰‹é‡Œæœ‰ç‰Œçš„æƒ…å†µä¸‹ï¼‰æ¸¸æˆä¾¿å¤±è´¥ æ„é€ ä¸€ä¸ªpermutationä»£è¡¨å‡ºç‰Œé¡ºåºï¼Œä½¿å¾—æ‰€æœ‰äººæœ€åéƒ½èƒ½å‡ºå®Œç‰Œ æ€è·¯ è€ƒè™‘ç‰¹æ®Šæƒ…å†µï¼šæ—¶ï¼Œå®ƒåªéœ€è¦æŒ‰ç…§æ•°å€¼é€’å¢é¡ºåºæ”¾ç½®å¡ç‰Œå³å¯èƒœåˆ©ï¼Œæ•…åªéœ€è¦è¾“å‡º1 ä¸€èˆ¬æƒ…å†µï¼šä¸ºäº†æŒ‰ç…§é€’å¢é¡ºåºæ”¾ç½®å¡ç‰Œï¼Œæ¯ä¸ªäººéœ€è¦æŒ‰ç…§ä»å°åˆ°å¤§çš„æ•°å€¼å‡ºç‰Œ åˆå› ä¸ºä¸€ä¸ªäººä¸€è½®åªèƒ½å‡ºä¸€å¼ ç‰Œï¼Œå› æ­¤å¦‚æœä¸€ä¸ªäººæ‰‹é‡Œæœ‰ä¸¤å¼ è¿ç»­æ•°å€¼çš„å¡ç‰Œï¼Œä»–å‡ºå®Œæ›´å°çš„ä¸€å¼ ä¹‹åï¼Œå…¶ä»–äººå‡ºçš„ç‰Œè‚¯å®šä¼šæ¯”ä»–æ›´å¤§çš„ä¸€å¼ ç‰Œå¤§ï¼Œè¿™æ ·ä»–æ‰‹é‡Œæ€»ä¼šç•™ä¸‹é‚£å¼ ç‰Œï¼Œå¯¼è‡´å¤±è´¥ è‹¥æ²¡æœ‰ä¸Šè¿°æƒ…å†µï¼Œåªè¦å¯¹æ¯ä¸ªäººæ‰‹é‡Œçš„ç‰Œæ’åºï¼ŒæŒ‰ç…§ç¬¬ä¸€å¼ ç‰Œçš„å¤§å°ä»å°åˆ°å¤§å‡ºç‰Œå³ä¸ºæ­£ç¡®é¡ºåº ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e3 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; //t++; while(t--){ int n, m,tep=0; int a[N]={},ord[N]={},b[N]={}; cin &gt;&gt; n &gt;&gt; m; int flag=0; for(int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ cin &gt;&gt; a[j]; tep++; } sort(a+1,a+1+m); if (n==1 &amp;&amp; flag != 1) { cout &lt;&lt; 1 &lt;&lt; endl; flag = 1; break; } for (int j = 1;j&lt;m;j++){ if (abs(a[j+1]-a[j])==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; for (int i = 1;i&lt;=n*m-tep;i++) { int t; cin &gt;&gt; t; } break; } } if (flag) break; ord[a[1]]=i; } if (flag) continue; for (int i = 0;i&lt;n*m;i++){ if (ord[i]!=0) cout &lt;&lt; ord[i]&lt;&lt;' '; } cout &lt;&lt; endl; } return 0; } C-Game of Mathletes é¢˜æ„ ä¸ªæ•°ï¼ŒAliceå’ŒBobè½®æµæ¯æ¬¡é€‰æ‹©ä¸€ä¸ªæ•°å¹¶å»é™¤ï¼Œè‹¥ä¸¤æ•°ä¹‹å’Œç­‰äºåˆ™åˆ†æ•°åŠ ä¸€ï¼Œæ±‚æœ€ç»ˆåˆ†æ•° æ€è·¯ å¯¹äºæ¯ç»„æ•°åˆ†æ•°æ˜¯å›ºå®šçš„ï¼Œå› ä¸ºåªè¦Aliceé€‰ä¸€ä¸ªæ•°ï¼ŒBobå°±ä¼šé€‰æ‹©æ•°ï¼Œå› æ­¤åªè¦çœ‹æœ‰å‡ ç»„æ•°æ»¡è¶³å³å¯ è¿™é‡Œå•çº¯æšä¸¾ä¼šTLEï¼Œå¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆä¼˜åŒ– ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,k,score=0; int a[N]; cin &gt;&gt; n &gt;&gt; k; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } sort(a+1,a+1+n); // æ’åº int l = 1, r = n; // å¯¹æ’æŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å¤´å°¾ while(l&lt;r){ int sum = a[l]+a[r]; // è®¡ç®—å’Œ if (sum==k){ // æ»¡è¶³æ¡ä»¶ score++; // åˆ†æ•°åŠ ä¸€ l++,r--; // ä¸¤ç«¯æŒ‡é’ˆåŒæ—¶ç§»åŠ¨ï¼Œè®¡ç®—ä¸‹ä¸€ç»„æ•° } else if (sum&lt;k)l++; // è‹¥å’Œæ¯”æ¡ä»¶å°ï¼Œåˆ™è®©å’Œå˜å¤§ï¼Œå·¦æŒ‡é’ˆå³ç§» else r--; // è‹¥å’Œæ¯”æ¡ä»¶å¤§ï¼Œåˆ™è®©å’Œå˜å°ï¼Œå³æŒ‡é’ˆå·¦ç§» } cout &lt;&lt; score &lt;&lt; endl; } return 0; } D-Subtract Min Sort é¢˜æ„ ä¸€ä¸ªæ•°ç»„ï¼Œä½ æ¯æ¬¡å¯ä»¥è®©ä¸¤ä¸ªç›¸é‚»çš„æ•°ä¸€èµ·å‡å»ä»–ä»¬ä¹‹ä¸­çš„æœ€å°å€¼ã€‚é—®èƒ½ä¸èƒ½ä½¿æ•°ç»„éé€’å‡ æ€è·¯ å¯¹äºæ•°ä¸ï¼Œåœ¨è¿›è¡Œæ“ä½œåä¸€å®šä¼šæœ‰ä¸€ä¸ªæ•°å˜ä¸º0ï¼Œè‹¥ä¸º0ï¼Œåˆ™ä¹‹åçš„æ“ä½œä¸€å®šä¼šè®©å˜ä¸º0ä»¥ä¿è¯æ•°ç»„éé€’å‡ è€ƒè™‘æœ€å³ç«¯çš„ä¸ï¼Œè‹¥ä¸º0ï¼Œåˆ™è¿™ä¹‹å‰çš„æ‰€æœ‰æ•°éƒ½ä¸º0 å› æ­¤æˆ‘ä»¬è€ƒè™‘ä¸¤ä¸ªå…ƒç´ ä¸ï¼Œå°†ä¸¤è€…å‡å»æœ€å°çš„é‚£ä¸ªï¼Œå…¶ä¸­ä¸€ä¸ªå˜ä¸º0ï¼Œåˆ™è¯¥æ•°ä¹‹å‰ä¸€å®šéƒ½ä¸º0ï¼Œè€Œåé¢çš„ä¸å˜ è€ƒè™‘ç‰¹æ®Šæƒ…å†µï¼Œè‹¥æƒ³è®©å˜ä¸º0ï¼Œé‚£ä¹ˆåªèƒ½è®©åŒæ—¶å‡å»è€Œæ²¡æœ‰å…¶ä»–æ–¹æ³•ï¼Œè¿™å¯¼è‡´æ’æˆç«‹ å¯¹äºä¸€èˆ¬æƒ…å†µï¼Œä¸‰ä¸ªè¿ç»­çš„æ•°,ä¸ï¼Œæˆ‘ä»¬å¸Œæœ›å…ˆç®—åé¢ä¸¤ä¸ªæ•°ï¼Œè¿™æ ·å¯ä»¥è®©å‡å»æ›´å¤šçš„å€¼ï¼Œä»¥ç¡®ä¿å°äºï¼Œæ­¤æ—¶è‹¥å˜ä¸º0ï¼Œè¿å¸¦ç€ä¹Ÿä¼šå˜ä¸º0ï¼Œè‹¥ä¸å˜ä¸º0ï¼Œåˆ™ä¹‹åä¸€å®šéœ€è¦åŒæ—¶å‡ä¸€ä¸ªè®©ä»–ä»¬ä¿è¯æ˜¯éé€’å‡çš„ å› æ­¤æˆ‘ä»¬å¯ä»¥åè¿‡æ¥ï¼Œå…ˆä»å¤´å¯¹ä¸æ“ä½œï¼Œä¸€æ­¥æ­¥å¾€åæ“ä½œã€‚è‹¥æ¯ä¸€ç»„éƒ½æ“ä½œç»“æŸåä»æœ‰ï¼Œåˆ™æ— æ³•å®ç°ï¼Œå¦åˆ™æˆ‘ä»¬å¯ä»¥é€šè¿‡æ’åºå®ç°éé€’å‡æ•°ç»„ã€‚ ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 0;i&lt;n;i++) cin &gt;&gt; a[i]; if (a[0]&gt;a[1]){ // ç‰¹åˆ¤ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ª cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } for (int i = 1;i&lt;n-1;i++){ a[i]-=a[i-1]; // å¾€å‰å‡ if (a[i]&gt;a[i+1]){ // å‡åè‹¥è¿˜æ˜¯å¤§åˆ™ä¸è¡Œ cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = 1; break; } } if (!flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"CFé¢˜è§£","slug":"CFé¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"}]},{"title":"ã€é¢˜è§£ã€‘ç‰›å®¢å‘¨èµ› Round 77","slug":"ç‰›å®¢å‘¨èµ›-Round-77","date":"2025-01-19T13:37:37.000Z","updated":"2025-01-21T14:19:46.159Z","comments":true,"path":"2025/01/19/ç‰›å®¢å‘¨èµ›-Round-77/","permalink":"https://izayoisakuye.github.io/2025/01/19/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-Round-77/","excerpt":"","text":"A-æ—¶é—´è¡¨ æŠŠæ—¶é—´æ”¾åˆ°æ•°ç»„ä¸­æŒ‰ä¸‹æ ‡æœç´¢å³å¯ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios int a[]={20250121,20250123,20250126,20250206,20250208,20250211}; cin &gt;&gt; n; cout &lt;&lt; a[n-1]; return 0; } B- æ•°ç‹¬æ•°ç»„ å½¢å¦‚ä»¥ä¸‹çš„æ•°ç»„å…¶å®éƒ½å¯ä»¥ï¼š 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 8 9 1 2 3 4 5 6 7 8 9 â€¦ 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 â€¦ å³æ¯ç§æ•°å­—å‡ºç°æ¬¡æ•°è¦ä¸ç›¸ç­‰ï¼Œè¦ä¸ç›¸å·®1ï¼Œä¸”éƒ½å¿…é¡»å‡ºç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int a[N]; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=9;i++) num[i]=0; // åˆå§‹åŒ–map for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; num[tep]++; // ç»Ÿè®¡æ•°å­—å‡ºç°æ¬¡æ•° } // è¯¥ç‰¹åˆ¤å¯ä»¥ä¸è¦ for (int i = 1;i&lt;=9;i++) { if (num[i]==0){ cout &lt;&lt; \"NO\"; return 0; } } for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;=9;j++){ if (num[i]!=num[j]) { // ä¸¤æ•°ä¸ç­‰çš„æƒ…å†µä¸‹ if(abs(num[i]-num[j])!=1){ // å·®å€¼åªèƒ½ä¸º1 cout &lt;&lt; \"NO\"; return 0; } } } } cout &lt;&lt; \"YES\"; return 0; } C-å°çº¢èµ°ç½‘æ ¼ å°†è¡Œåˆ—åˆ†å¼€çœ‹ï¼Œé€»è¾‘ç›¸åŒ ç”±äºæ¯æ¬¡ç§»åŠ¨è·ç¦»å›ºå®šï¼Œå› æ­¤é—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºä»¥ä¸‹æ¡ä»¶ï¼š åœ¨xæ–¹å‘æ˜¯å¦å­˜åœ¨æ•´æ•°ï¼ˆå‘å³æ¬¡æ•°ï¼‰ä¸ï¼ˆå‘å·¦æ¬¡æ•°ï¼‰ä½¿å¾— åœ¨yæ–¹å‘æ˜¯å¦å­˜åœ¨æ•´æ•°ï¼ˆå‘å³æ¬¡æ•°ï¼‰ä¸ï¼ˆå‘å·¦æ¬¡æ•°ï¼‰ä½¿å¾— å³åŒä½™æ–¹ç¨‹çš„å¯è§£æ€§ï¼Œå¯ä»¥è§é€†å…ƒéƒ¨åˆ† æ•…ä¸¤æ–¹ç¨‹ç­‰ä»·äºä¸ ç”±æ­¤æˆ‘ä»¬å¼•å…¥è£´èœ€å®šç†ï¼š è®¾æ˜¯ä¸å…¨ä¸º0çš„æ•´æ•°ï¼Œå¯¹ä»»æ„æ•´æ•°ï¼Œæ»¡è¶³ï¼Œä¸”å­˜åœ¨æ•´æ•°ä½¿ å› æ­¤åªè¦æ»¡è¶³æ˜¯çš„å€æ•°ï¼Œæ˜¯çš„å€æ•°ï¼Œå°±æœ‰å¯¹åº”çš„è§£ï¼Œå³èƒ½åˆ°è¾¾æŒ‡å®šä½ç½® 123456789101112131415161718192021222324252627282930313233343536373839// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int gcd(int a, int b){ return b?gcd(b,a%b):a; } int main() { ios cin &gt;&gt; t; while(t--){ int x,y,a,b,c,d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (x%gcd(c,d)!=0) { cout &lt;&lt; \"NO\" &lt;&lt; endl; } else if (y%gcd(a,b)!=0){ cout &lt;&lt; \"NO\" &lt;&lt; endl; } else cout &lt;&lt; \"YES\"&lt;&lt;endl; } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"ã€Pythonã€‘CS61Aâ€”â€”Higher-Order Functions","slug":"CS61Aâ€”â€”Higher-order Functions","date":"2025-01-19T01:03:01.170Z","updated":"2025-01-30T09:40:55.863Z","comments":true,"path":"2025/01/19/CS61Aâ€”â€”Higher-order Functions/","permalink":"https://izayoisakuye.github.io/2025/01/19/CS61A%E2%80%94%E2%80%94Higher-order%20Functions/","excerpt":"","text":"Higher-Order Functions å‡½æ•°ç‰¹å¾ ä¸€ä¸ªå‡½æ•°çš„å®šä¹‰åŸŸ(domain)å³ä¸ºæ‰€æœ‰å¯èƒ½çš„è¾“å…¥ ä¸€ä¸ªå‡½æ•°çš„å€¼åŸŸ(range)å³ä¸ºæ‰€æœ‰å¯èƒ½çš„è¾“å‡º ä¸€ä¸ªçº¯å‡½æ•°è¡¨ç°å³ä¸ºå»ºç«‹è¾“å…¥ä¸è¾“å‡ºä¹‹é—´çš„æ˜ å°„ assertè¯­å¥ æ ¼å¼ï¼šassert &lt;bool expression&gt; &lt;output information&gt; ç”¨å¤„ï¼šå½“å¸ƒå°”è¡¨è¾¾å¼æˆç«‹æ—¶ï¼Œè¯­å¥ç»§ç»­æ‰§è¡Œï¼›å½“å¸ƒå°”è¡¨è¾¾å¼ä¸æˆç«‹æ—¶ï¼Œç¨‹åºè·³å‡ºå¹¶æç¤ºæŒ‡å®šçš„æŠ¥é”™ä¿¡æ¯ã€‚ å‡½æ•°ä½œä¸ºå½¢å‚ è®¾è®¡ä¸€ä¸ªè®¡ç®—æ±‚å’Œã€ç«‹æ–¹é¡¹æ±‚å’Œçš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨å¯¹æ±‚å’Œå‡½æ•°ä¸­ä¼ å…¥å¯¹æ¯ä¸€ä½æ•°çš„æ“ä½œå¯¹åº”çš„å‡½æ•°æ¥ç®€åŒ–ä»£ç ï¼Œè€Œéä¸ºä¸åŒç§ç±»æ±‚å’Œåˆ†åˆ«è®¾è®¡å‡½æ•°ï¼Œå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829from math import pow def identity(k): return k def cube(k): return int(pow(k,3)) def summation(n,term): \"\"\"sum the first N terms of a sequence. &gt;&gt;&gt; summation(5,cube) 225 \"\"\" total,k=0,1 while k&lt;=n: total,k = total + term(k), k+1 return total def sum_naturals(n): \"\"\"sum the first N natural numbers &gt;&gt;&gt; sum_naturals(5) 15 \"\"\" return summation(n,identity) # ä¼ å…¥è¿”å›åŸå€¼å‡½æ•°è¿›è¡Œè®¡ç®— def sum_cubes(n): \"\"\"sum the first N cubes of natural numbers &gt;&gt;&gt; sum_cubes(5) 225 \"\"\" return summation(n,cube) # ä¼ å…¥è¿”å›æ¯ä¸ªå€¼çš„ç«‹æ–¹å‡½æ•°è¿›è¡Œè®¡ç®— å…¶ä¸­ï¼Œsummationå‡½æ•°ä¸­çš„termå‚æ•°ä¸ä¼ å…¥çš„å‡½æ•°æœ‰å…³ identityä¸cubeå‡½æ•°ä½œä¸ºå•ä¸ªå‚æ•°ä¼ å…¥summationå‡½æ•°ï¼Œä»¥å¤„ç†ä¸åŒæƒ…å†µä¸‹çš„æ±‚å’Œ å½¢å‚termå‡½æ•°åœ¨è®¡ç®—totalæ—¶è¢«å›è°ƒï¼Œå›è°ƒçš„æ˜¯ä¼ å…¥çš„å¯¹åº”å‡½æ•° å‡½æ•°ä½œä¸ºè¿”å›å€¼ å½“ä¸€ä¸ªå‡½æ•°åœ¨å¦ä¸€ä¸ªå‡½æ•°ä½“å†…å®šä¹‰ï¼Œè¯¥å‡½æ•°çš„åç§°ç»‘å®šåœ¨æœ¬åœ°ä½œç”¨åŸŸä¸­ å¦‚ä¸‹ï¼š 123456789def make_adder(n): \"\"\"return a function that takes one argument called k and return k+N &gt;&gt;&gt; add_three = make_adder(3) &gt;&gt;&gt; add_three(4) 7 \"\"\" def adder(k): return k+n # adderå‡½æ•°è¿”å›æ•°å€¼k+n return adder # make_adderå‡½æ•°è¿”å›adderå‡½æ•° make_adderå‡½æ•°è¿”å›ä¸€ä¸ªå‡½æ•°adderï¼Œè€Œå‡½æ•°adderæ˜¯å±€éƒ¨å®šä¹‰çš„å‡½æ•°ï¼Œå®ƒå¯ä»¥ä½¿ç”¨make_adderå†…éƒ¨çš„å˜é‡ï¼ˆkä¸nï¼‰ å¯¹äºè¯­å¥make_adder(1)(2)ï¼Œå®ç°çš„æ•ˆæœå³ä¸º1+2 ä½œç”¨ å‡½æ•°æ˜¯ç¬¬ä¸€ç±»å€¼(first-class)ï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œä½œä¸ºè¿”å›å€¼è¿”å› higher-orderå‡½æ•°æŒ‡ä»£ä»¥å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å€¼çš„å‡½æ•° å®ƒå¯ä»¥è¡¨ç¤ºè®¡ç®—çš„ä¸€èˆ¬æƒ…å†µ å®ƒå¯ä»¥é˜²æ­¢ç¨‹åºä»£ç è¿‡äºé‡å¤å†—æ‚ å®ƒå¯ä»¥å°†ä¸åŒåŠŸèƒ½åˆ†ç¦»æˆå¤šä¸ªå‡½æ•° åŒ¿åå‡½æ•°(Lambda Expressions ) æ ¼å¼ï¼šlambda &lt;formal parameter&gt;: &lt;return value&gt; lambdaæŒ‡å®šä¹‰ä¸€ä¸ªåŒ¿åå‡½æ•° lambdaåç´§è·Ÿä¸€ä¸ªå½¢å¼å‚æ•°ï¼Œå†’å·åä¸ºè¿”å›å€¼ï¼ˆæ— returnå…³é”®å­—ï¼‰ è¿”å›å€¼åªèƒ½æ˜¯ä¸€å¥è¡¨è¾¾å¼ ä½¿ç”¨æ—¶å°†å…¶èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡å¹¶æŒ‰ç…§defå‡½æ•°æ–¹å¼è°ƒç”¨æˆ–ç›´æ¥æŒ‰ç…§defå‡½æ•°æ–¹å¼è°ƒç”¨ ä¸defä¸åŒçš„ä¸€ç‚¹æ˜¯ï¼šdefå®šä¹‰çš„å‡½æ•°æ‹¥æœ‰ä¸€ä¸ªå†…éƒ¨åç§°(intrinsic name)ï¼Œè€Œlambdaå®šä¹‰çš„å‡½æ•°å³ä½¿èµ‹å€¼ç»™äº†å¦ä¸€ä¸ªåå­—çš„å˜é‡ï¼Œå®ƒçš„åç§°ä»ä¸ºlambda è¿”å›è¯­å¥(Return Statements) å‡½æ•°ä¸­çš„returnè¯­å¥è®©ç¨‹åºè¿”å›åˆ°å…ˆå‰çš„environmentï¼Œå¹¶ç»™å‡½æ•°ä¸€ä¸ªå€¼ åœ¨æ‰§è¡Œå‡½æ•°ä½“æ—¶ï¼Œé‡åˆ°returnè¯­å¥å‡½æ•°å³ç»“æŸ çœ‹å¦‚ä¸‹ä¾‹å­ï¼š 123456789101112131415161718192021def search(f): \"\"\"find a number that one more than the square root of the number put in the positive function &gt;&gt;&gt; search(positive) 11 \"\"\" x=0 while not f(x): # å½“positiveå‡½æ•°è¿”å›ä¸º0æ—¶è¿›å…¥å¾ªç¯ x+=1 return x def square(x): return x**2 def positive(x): return max(0,square(x)-100) def inverse(f): \"\"\"return g(y) such that g(f(x)) -&gt;x &gt;&gt;&gt; inverse(square)(16) 4 \"\"\" return lambda y: search(lambda x:f(x)==y) # è¿”å›æŸä¸ªå®Œå…¨å¹³æ–¹æ•°çš„å¹³æ–¹æ ¹ positiveå‡½æ•°ï¼š â€‹ ä¼ å…¥searchåï¼Œå¯»æ‰¾çš„æ˜¯ç¬¬ä¸€ä¸ªæ¯”positiveå‡½æ•°ä¸­å‡æ•°çš„å¹³æ–¹æ ¹å¤§çš„æ•° â€‹ å› ä¸ºè‹¥æ•°xçš„å¹³æ–¹æ¯”å‡æ•°å°ï¼Œreturnå€¼è‚¯å®šæ˜¯0ï¼Œwhileæ¡ä»¶æˆç«‹ï¼Œx++ç»§ç»­å¯»æ‰¾ inverseå‡½æ•°ï¼š inverseç”¨äºå¯»æ‰¾å®Œå…¨å¹³æ–¹æ•°yçš„å¹³æ–¹æ ¹ ä¼ å…¥squareå‡½æ•°ç”¨äºè®¡ç®—searchå‡½æ•°ä¸­xçš„å¹³æ–¹ï¼Œä¸inverseå‡½æ•°è¿”å›çš„lambdaå‡½æ•°ä¸­ä¼ å…¥çš„yæ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ï¼Œè‹¥ä¸ç›¸ç­‰ï¼Œæ»¡è¶³whileå¾ªç¯æ¡ä»¶ï¼Œx++ç»§ç»­æ¯”è¾ƒï¼Œè‹¥ç›¸ç­‰åˆ™æ‰¾åˆ°ï¼Œè·³å‡ºå¾ªç¯è¿”å›æ­¤æ—¶xå€¼ã€‚ æ§åˆ¶è¯­å¥(Control Statements) æ¡ä»¶è¯­å¥ æ‰§è¡Œæ¡ä»¶ï¼šæ¯ä¸€å¥clauseæŒ‰åºæ‰§è¡Œ åˆ¤æ–­æ¡ä»¶åˆ¤æ–­è¯­å¥æ˜¯å¦æˆç«‹ï¼ˆè‹¥å­˜åœ¨ï¼‰ è‹¥å€¼ä¸ºtrueæˆ–é‡åˆ°elseçš„clauseï¼Œæ‰§è¡Œè¯­å¥å—å¹¶è·³è¿‡å…¶ä½™clauses ä½†ä¸ºä½•æ²¡æœ‰ä¸€ä¸ªå‡½æ•°èƒ½å®ç°æ¡ä»¶åˆ¤æ–­å‘¢ï¼Ÿ å¯¹äºè°ƒç”¨è¡¨è¾¾å¼(call expression)çš„æ‰§è¡Œå¦‚ä¸‹ï¼š è€Œåœ¨ifè¯­å¥ä¸­ï¼Œåªæœ‰å…¶ä¸­ä¸€å¥ä¼šè¢«æ‰§è¡Œï¼Œå› æ­¤ä½¿ç”¨å‡½æ•°æ›¿ä»£å¹¶ä¸åˆé€‚ï¼Œå¦‚ä¸‹ä»£ç ï¼š 12345678910111213def if_(c,t,f): if c: return t else: return f from math import sqrt def real_sqrt(x): return if_(x&gt;0,sqrt(x),0.0) if __name__ == '__main__': print(real_sqrt(-4)) æˆ‘ä»¬éœ€è¦å®ç°è¿”å›ä¸€ä¸ªå®æ•°å¹³æ–¹æ ¹ç»“æœçš„å®éƒ¨ï¼Œä¼—æ‰€å‘¨çŸ¥ï¼Œè´Ÿæ•°å¼€å¹³æ–¹åå®éƒ¨ä¸º0ï¼Œå› æ­¤è´Ÿæ•°åº”è¾“å‡º0 ä½†æ‰§è¡Œåå‘ç°å´å‡ºç°äº†sqrtçš„ ValueError: math domain error å› ä¸ºåœ¨å‡½æ•°è°ƒç”¨æ—¶ï¼Œsqrt(x)åŒæ—¶ä¹Ÿä¼šæ‰§è¡Œï¼Œæ­¤æ—¶xå°äº0æ•…è§¦å‘äº†sqrtçš„assert å› æ­¤æ²¡æœ‰äº†æ§åˆ¶è¯­å¥ï¼Œæˆ‘ä»¬åªèƒ½åœ¨å€¼ä¹‹é—´é€‰æ‹©è€Œä¸èƒ½åœ¨æ¡ä»¶ä¹‹é—´é€‰æ‹© æ¡ä»¶è¯­å¥çš„ç®€å•å½¢å¼ &lt;consequent&gt; if &lt;predicate&gt; else &lt;alternative&gt; æ‰§è¡Œpredicateè¯­å¥ è‹¥ä¸ºçœŸï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„å€¼ä¸ºconsequentçš„å€¼ è‹¥ä¸ºå‡ï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„å€¼ä¸ºalternativeçš„å€¼ é€»è¾‘è¿ç®—ç¬¦çš„çŸ­è·¯æ•ˆåº” æ‰§è¡Œä¸€ä¸ªè¯­å¥&lt;left&gt; and &lt;right&gt; è®¡ç®—leftè¯­å¥ è‹¥ç»“æœæ˜¯falseï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœæ˜¯false è‹¥ç»“æœæ˜¯trueï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœæ˜¯rightè¯­å¥çš„ç»“æœ æ‰§è¡Œä¸€ä¸ªè¯­å¥&lt;left&gt; or &lt;right&gt; è®¡ç®—leftè¯­å¥ è‹¥ç»“æœä¸ºtrueï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœæ˜¯true è‹¥ç»“æœä¸ºfalseï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœæ˜¯rightè¯­å¥çš„ç»“æœ HW Lecture4çš„ä½œä¸šéƒ¨åˆ† æŸ¯é‡ŒåŒ–(Currying) å®šä¹‰ï¼šæŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰æ˜¯ä¸€ç§å¤„ç†å¤šå…ƒå‡½æ•°çš„æ–¹æ³•ã€‚å®ƒäº§ç”Ÿä¸€ç³»åˆ—è¿é”å‡½æ•°ï¼Œå…¶ä¸­æ¯ä¸ªå‡½æ•°å›ºå®šéƒ¨åˆ†å‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°å‡½æ•°ï¼Œç”¨äºä¼ å›å…¶å®ƒå‰©ä½™å‚æ•°çš„åŠŸèƒ½ã€‚ å³å®ƒå¯ä»¥æŠŠä¸€ä¸ªå¤šå…ƒå‡½æ•°è½¬æ¢ä¸ºä¸€ç³»åˆ—å‡½æ•°ï¼Œæ¯ä¸ªå‡½æ•°ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œå³å°†f(a,b,c)è½¬æ¢ä¸ºf(a)(b)(c) å¦‚ä¸Šæ–‡ä¸­çš„makeadderå‡½æ•°ï¼Œè¿”å›çš„æ˜¯åœ¨å†…éƒ¨å®šä¹‰çš„adderå‡½æ•°ï¼Œæ¯ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªå‚æ•°ï¼Œç­‰åŒäºmakeadder(k,n) æŸ¯é‡ŒåŒ–æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ä¸€ä¸ªä½“ç°ï¼Œä½¿å¾—å‡½æ•°ä»£ç æ›´ç®€æ´ 1-Product My solution: 123456x = 1 re = 1 while x&lt;=n: re*=term(x) x+=1 return re productå‡½æ•°æœ‰ä¸€ä¸ªtermå‚æ•°ç”¨äºæ¥æ”¶å‡½æ•°ï¼Œæ ¹æ®ä¸åŒè®¡ç®—éœ€è¦å¯ä»¥ä¼ å…¥ä¸åŒè®¡ç®—ç›¸å…³å‡½æ•°(squareï¼Œidentityç­‰) 2- Accumulate My solution: 123456a=1 re=start while a&lt;=n: re = fuse(re,term(a)) a+=1 return re 1return accumulate(add, 0, n, term) 1return accumulate(mul, 1, n, term) åœ¨ä¸Šä¸€é¢˜çš„åŸºç¡€ä¸Šæ·»åŠ äº†é€‰æ‹©æ¯ä¸ªæ•°ä¹‹é—´ä½¿ç”¨åŠ æ³•è¿˜æ˜¯ä¹˜æ³•çš„å‚æ•°fuseï¼ŒfuseåŒæ—¶ä¹Ÿæ˜¯æ¥æ”¶å‡½æ•°æ¥æŒ‡å®šæ¯ä¸ªtermè¿ç®—ä¹‹é—´çš„è¿ç®—æ–¹å¼(add,mul ç­‰) 3-Make repeater My solution: 12if n == 0: return lambda x: x return lambda x: f(make_repeater(f,n-1)(x)) è¿™é‡Œéœ€è¦å°†ä¼ å…¥çš„æ•°å€¼æ‰§è¡Œnæ¬¡æŒ‡å®šè¿ç®—fï¼Œå³f(f(...f(x)...)) æœ¬äººä½¿ç”¨äº†é€’å½’å®ç°ï¼Œå³make_repeater(f,n)(x)=f(make_repeater(f,n-1)(x))=f(f(make_repeater(f,n-2)))=...=f(f(...f(x)...)) æ¯æ¬¡åŠ ä¸€å±‚f()ï¼Œç›´åˆ°æ—¶æ›¿æ¢ä¸ºx","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"ã€é¢˜è§£ã€‘ç‰›å®¢å°ç™½æœˆèµ›109-C","slug":"ç‰›å®¢å°ç™½æœˆèµ›109-C","date":"2025-01-17T14:16:39.000Z","updated":"2025-01-17T16:42:49.194Z","comments":true,"path":"2025/01/17/ç‰›å®¢å°ç™½æœˆèµ›109-C/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B109-C/","excerpt":"","text":"é¢˜ç›®æè¿° Tobo å…»äº† nnn åªçŒªçŒªï¼ŒçŒªçŒªä»¬çš„ç¼–å·ä¸º ã€‚æˆ‘ä»¬è§„å®šä¸¤ç§æ“ä½œï¼š 1. å¯¹äºç»™å®šçš„ l,r è¡¨ç¤º Tobo è¦å’Œç¼–å·ä¸º l åˆ° rçš„çŒªçŒªæŒ‰é¡ºåºç©è€ï¼Œä½†å› ä¸º Tobo å–œæ–°åŒæ—§ï¼Œæ‰€ä»¥å·²ç»ç©è€è¿‡çš„çŒªçŒªä¸ä¼šå†ä¸€èµ·ç©ï¼Œä¼šç›´æ¥è·³è¿‡å®ƒã€‚ 2. å¯¹äºç»™å®šçš„ x ï¼Œè¡¨ç¤ºç¼–å·ä¸º x çš„çŒªçŒªæƒ³çŸ¥é“è‡ªå·±æ˜¯ç¬¬å‡ ä¸ªå’Œ Tobo ç©è€çš„ï¼Œå¦‚æœæ²¡æœ‰ç©è€è¿‡åˆ™è¾“å‡º 0 ã€‚ ä½ ä¸€å…±éœ€è¦å¤„ç† q æ¬¡æ“ä½œã€‚ è¾“å…¥æè¿°: ç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° ä»£è¡¨ Tobo å…»çš„çŒªçŒªæ•°é‡ã€æ“ä½œæ¬¡æ•°ã€‚ æ­¤å q è¡Œï¼Œæ¯è¡Œå…ˆè¾“å…¥ä¸€ä¸ªæ•´æ•° è¡¨ç¤ºæ“ä½œç±»å‹ï¼Œéšåï¼š è‹¥ op=1ï¼Œåœ¨åŒä¸€è¡Œä¸Šè¾“å…¥ä¸¤ä¸ªæ•´æ•° ä»£è¡¨ Tobo å°†ä¾æ¬¡å’Œç¼–å·ä¸º l åˆ° rçš„çŒªçŒªç©è€ã€‚ è‹¥ op=2ï¼Œåœ¨åŒä¸€è¡Œä¸Šè¾“å…¥ä¸€ä¸ªæ•´æ•° ä»£è¡¨ä¸€æ¬¡è¯¢é—®ã€‚ è¾“å‡ºæè¿°: å¯¹äºæ¯ä¸€æ¬¡è¯¢é—®ï¼Œåœ¨å•ç‹¬çš„ä¸€è¡Œä¸Šè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¯¢é—®çš„çŒªçŒªæ˜¯ç¬¬å‡ ä¸ªå’Œ Tobo ç©è€çš„ï¼›è‹¥æ²¡æœ‰ç©è€è¿‡ï¼Œåˆ™ç›´æ¥è¾“å‡º 0ã€‚ è¾“å…¥ 123456785 7 1 2 3 2 3 1 3 5 2 4 2 1 1 1 5 2 1 è¾“å‡º 12342 3 0 5 è¯´æ˜ 123å¯¹äºç¬¬ä¸€æ¬¡æ“ä½œï¼ŒTobo å°†ä¾æ¬¡å’Œç¼–å·ä¸º 2,3 çš„çŒªçŒªç©è€ï¼› å¯¹äºç¬¬äºŒæ¬¡æ“ä½œï¼Œç¼–å·ä¸º 3 çš„çŒªçŒªæƒ³çŸ¥é“è‡ªå·±æ˜¯ç¬¬å‡ ä¸ªå’Œ Tobo ç©çš„ï¼Œè¾“å‡º 2 ï¼› å¯¹äºç¬¬ä¸‰æ¬¡æ“ä½œï¼ŒTobo å°†ä¾æ¬¡å’Œç¼–å·ä¸º 3,4,5çš„çŒªçŒªç©è€ï¼Œè¿™å…¶ä¸­ï¼Œç”±äºç¼–å·ä¸º 3 çš„çŒªçŒªå·²ç»å’Œ Tobo ç©è¿‡ï¼Œæ‰€ä»¥ Tobo ä¼šè·³è¿‡å®ƒï¼Œç›´æ¥å’Œç¼–å·ä¸º 4 çš„çŒªçŒªç©è€ã€‚ é”™è§£ æ¯æ¬¡æ“ä½œ1éå†åŒºé—´ï¼Œæš´åŠ›æšä¸¾æ¯ä¸€åªçŒªï¼Œè‹¥æ²¡æœ‰ç©è¿‡åˆ™èµ‹å€¼ä¸ºå½“å‰ç©è¿‡çš„ç¬¬nåªçŒªï¼Œè‹¥ç©è¿‡åˆ™ç›´æ¥è·³è¿‡ è¯¥æ–¹æ³•ä¼šTLEï¼ˆåé¢åˆåŠ å¼ºæ•°æ®äº†ä¼˜åŒ–åçš„æš´åŠ›ä¹Ÿå·®ä¸€ç‚¹ç‚¹wwï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; int play[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; int tep = 0; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (tep&gt;=n) continue; // å…¨éƒ¨ç©è¿‡åç›´æ¥è·³è¿‡ if (play[l]==0) { // éå†åŒºé—´çš„å·¦ç«¯èµ‹å€¼ tep++; play[l]+=tep; } for(int i = l; i&lt;r;i++){ // éå†låˆ°rå¹¶èµ‹å€¼ä¸ºç¬¬tepåªç©è¿‡çš„çŒª if (play[i+1]==0) { tep++; play[i+1]=tep; } } } else { // è¯¢é—®æ“ä½œ int p; cin &gt;&gt;p; cout &lt;&lt; play[p]&lt;&lt;endl; } } return 0; } æ­£è§£ å‰ç½®çŸ¥è¯† lower_bound()å‡½æ•°ï¼š å®šä¹‰ï¼šconst_iterator lower_bound( const K&amp; x ) const; STLå†…ç½®å‡½æ•°ï¼Œç”¨äºå¯»æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºkeyçš„å€¼ï¼Œè¿”å›å€¼ä¸ºæŒ‡å‘åˆšå¥½å¤§äºç­‰äºkeyçš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè‹¥ä¸å­˜åœ¨åˆ™è¿”å›æœ«å°¾è¿­ä»£å™¨ï¼ˆæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ ï¼‰ è§£æ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨setæ¥ä¼˜åŒ– ç”±äºæ¯åªçŒªçš„ç¼–å·éƒ½è¿ç»­ä¸”ä¸ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ç”¨setæ¥å­˜å‚¨ ä½¿ç”¨lower_bound()å‡½æ•°æŸ¥æ‰¾åœ¨å¾…æŸ¥æ‰¾åŒºé—´é‡Œä¸‹ä¸€ä¸ªæ²¡æœ‰ç©è¿‡çš„çŒª ç„¶åå°†è¯¥çŒªæ ‡è®°ä¸ºç¬¬nä¸ªç©çš„ï¼Œä»é›†åˆä¸­åˆ é™¤ è¿™æ ·å¯ä»¥ä¿è¯é›†åˆé‡Œå§‹ç»ˆéƒ½æ˜¯æ²¡æœ‰è¢«ç©è¿‡çš„çŒªï¼Œæ¯æ¬¡æŸ¥æ‰¾éƒ½æ‰¾åˆ°ç¦»læœ€è¿‘çš„ä¸€ä¸ªæ²¡æœ‰è¢«ç©è¿‡çš„çŒªï¼Œç›´åˆ°åŒºé—´åˆ ç©ºï¼Œå³æ‰€æœ‰çŒªéƒ½è¢«ç©è¿‡ è¯¢é—®æ“ä½œç›´æ¥è¾“å‡ºæ ‡è®° å‚è€ƒä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; set&lt;int&gt; pig; int tag[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; pig.insert(1e9); // é˜²æ­¢æœ€åå…¨åˆ å®Œåå‰©ä¸‹ç´¢å¼•0å¤„æ— æ³•è·³å‡º for (int i = 1;i&lt;=n;i++) pig.insert(i); // æŠŠæ‰€æœ‰çŒªå­˜å…¥é›†åˆ int cnt = 1; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l,r; cin &gt;&gt; l &gt;&gt; r; while(1){ int tep = (*pig.lower_bound(l)); // ç”¨lower_bound()è¿”å›ç¬¬ä¸€ä¸ªå¤§äºlçš„æ•°ï¼Œå³æ‰¾åˆ°ä¸‹ä¸€ä¸ªåœ¨åŒºé—´å†…ä¸”æ²¡æœ‰ç©è¿‡çš„çŒª if (tep&gt;r) break; // åŒºé—´ä¸ºç©ºï¼Œå¯»æ‰¾ç»“æŸ tag[tep]=cnt; // æ ‡è®°æ‰¾åˆ°çš„çŒªæ˜¯ç¬¬å‡ ä¸ªè¢«ç©çš„ cnt++; pig.erase(tep); // æŠŠè¢«ç©è¿‡çš„çŒªä»é›†åˆä¸­åˆ é™¤ } } else { // è¯¢é—®çŒªæ˜¯ç¬¬å‡ ä¸ªç©çš„ int p; cin &gt;&gt; p; cout &lt;&lt; tag[p]&lt;&lt;endl; } } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"ã€C/C++ã€‘æŒ‡é’ˆ","slug":"æŒ‡é’ˆ","date":"2025-01-17T06:53:15.466Z","updated":"2025-01-22T12:16:27.333Z","comments":true,"path":"2025/01/17/æŒ‡é’ˆ/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E6%8C%87%E9%92%88/","excerpt":"","text":"æŒ‡é’ˆ æ•°æ®åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ è¿™æ˜¯ä¸€æ®µå†…å­˜ï¼Œä»–è¢«åˆ†æˆäº†è®¸å¤šæ®µï¼Œæ¯æ®µä¸€ä¸ªbyte å½“æˆ‘ä»¬å£°æ˜ä¸€ä¸ªå˜é‡int aï¼Œè®¡ç®—æœºä¼šç»™è¯¥å˜é‡åˆ†é…ä¸€å—ç©ºé—´ï¼Œåˆ†é…å–å†³äºæ•°æ®ç±»å‹ä¸ç¼–è¯‘å™¨ å¦‚ï¼šint ä¸floatå 4bytesï¼Œcharå 1bytes å½“æˆ‘ä»¬ç»™å˜é‡aèµ‹å€¼a=5ï¼Œè®¡ç®—æœºä¼šå»å¯»æ‰¾è¯¥å˜é‡ï¼Œå»åˆ°ä»–çš„åœ°å€ï¼Œä»¥äºŒè¿›åˆ¶å†™å…¥æ•°æ® æŒ‡é’ˆçš„åŸºç¡€ä½¿ç”¨ æŒ‡é’ˆæ˜¯ä¸€ç§å˜é‡ï¼Œå®ƒå¯ä»¥å­˜å‚¨å˜é‡çš„åœ°å€ ä½¿ç”¨æ•°æ®ç±»å‹* å˜é‡ååˆ›å»ºä¸€ä¸ªæŒ‡é’ˆï¼šint *p char *c ä½¿ç”¨å–åœ°å€ç¬¦&amp;è·å–ä¸€ä¸ªå˜é‡çš„åœ°å€ï¼Œå¹¶å¯ä»¥å°†æŒ‡é’ˆæŒ‡å‘è¯¥å˜é‡åœ°å€ï¼šp=&amp;a print pï¼Œprint &amp;aï¼Œprint &amp;påˆ†åˆ«å¯¹åº”æ‰“å°pæŒ‡å‘(a)çš„åœ°å€ï¼Œaçš„åœ°å€ï¼Œpçš„åœ°å€ å°†ä¸€ä¸ª*æ”¾åœ¨æŒ‡é’ˆå˜é‡å‰ï¼Œå¯ä»¥å¯¹æŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨ï¼Œå³è·å–pæŒ‡å‘åœ°å€çš„å€¼ åˆ™print *pä¼šè¿”å›açš„å€¼ï¼Œ*p = 8ä¼šæ›´æ”¹açš„å€¼åˆ°8 å®ä¾‹ä»£ç ï¼š 1234567891011121314151617181920#include&lt;stdio.h&gt; int main(){ int a=5; int* p; // è‹¥è¯¥æŒ‡é’ˆpæ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œpä¼šå˜æˆä¸€ä¸ªé‡æŒ‡é’ˆï¼Œä¼šå› ä¸ºæŒ‡å‘ä»»æ„ä½ç½®è€ŒæŠ¥é”™ p = &amp;a; // å‚¨å­˜açš„åœ°å€ // ä¸Šä¸¤è¡Œç­‰åŒäºint* p = &amp;a; printf(\"A:%d\\n\",p); // açš„åœ°å€ printf(\"V:%d\\n\",*p); // açš„å€¼ printf(\"A:%d\\n\",&amp;a); // açš„åœ°å€ *p = 12; // æ›´æ”¹pæŒ‡å‘åœ°å€(a)çš„å…ƒç´ å€¼ printf(\"A:%d\\n\",a); // æ›´æ”¹åçš„aå€¼ int b = 20; *p = b; // pä¸ä¼šæŒ‡å‘bï¼Œåªä¼šå°†bçš„å€¼èµ‹ç»™a printf(\"A:%d\\n\",p); // è¿˜æ˜¯açš„åœ°å€ printf(\"V:%d\\n\",*p); // bçš„å€¼ return 0; } æŒ‡é’ˆç±»å‹ ä¸åŒçš„æ•°æ®ç±»å‹å æ®ä¸åŒçš„å†…å­˜ï¼š intï¼š4bytes charï¼š1byte floatï¼š4bytes voidæŒ‡é’ˆï¼š å¯ä»¥å­˜æ”¾ä»»æ„ç±»å‹çš„æŒ‡é’ˆï¼Œä¸”æ— éœ€å¼ºåˆ¶ç±»å‹è½¬æ¢ éœ€è¦è¿›è¡Œæ˜¾å¼è½¬æ¢åæ‰èƒ½èµ‹å€¼ç»™å…¶ä»–ç±»å‹ å¯ä»¥ä¸å…¶ä»–ç±»å‹æŒ‡é’ˆç›´æ¥æ¯”è¾ƒåœ°å€å€¼ åªæœ‰å¼ºåˆ¶ç±»å‹è½¬æ¢åæ‰èƒ½æ“ä½œï¼ˆè§£å¼•ç”¨ã€ç®—æœ¯è¿ç®—ç­‰ï¼‰ å¯ä»¥å’Œæ™®é€šæŒ‡é’ˆä¸€æ ·ä¼ å…¥NULLæˆ–nullptrè¡¨ç¤ºç©ºæŒ‡é’ˆ ä½œä¸ºå‡½æ•°è¾“å…¥è¾“å‡ºæ—¶ï¼Œè¡¨ç¤ºå¯ä»¥æ¥å—ä»»æ„ç±»å‹å’Œè¾“å‡ºä»»æ„ç±»å‹çš„æŒ‡é’ˆ æŒ‡é’ˆç±»å‹é—´çš„è½¬æ¢ å®šä¹‰ä¸€ä¸ªå˜é‡int a=1025ï¼š ä»–åœ¨å†…å­˜ä¸­çš„å¸ƒå±€ä¸ºï¼ˆä»å³åˆ°å·¦åˆ†åˆ«ä¸ºç¬¬0 1 2 3ä¸ªå­—èŠ‚ï¼Œä»–ä»¬çš„åœ°å€ä¹Ÿæ˜¯è¿ç»­çš„ï¼‰ï¼š å…¶ä¸­ï¼Œæœ€å·¦è¾¹çš„ä¸€ä½ä¸ºç¬¦å·ä½ï¼Œ0ä¸ºæ•´æ•°1ä¸ºè´Ÿæ•° è‹¥æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆcæŒ‡å‘aï¼Œç”±äºå­—ç¬¦åªå ä¸€ä¸ªå­—èŠ‚ï¼Œæ•…cåªä¼šæŒ‡å‘açš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼š å¯¹cè¿›è¡Œç®—æœ¯è¿ç®—(+1)ä¼šè®©ä»–æŒ‡å‘ä¸‹ä¸€ä¸ªå­—èŠ‚ ä»¥è‡³äºå¾—åˆ°4 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; int main(){ // ä¸€ä¸ªæ•´å½¢æŒ‡é’ˆ int a = 1025; // åœ¨äºŒè¿›åˆ¶ä¸­ä¸ºå››å­—èŠ‚:00000000 00000000 00000100 00000001 int* p; p = &amp;a; printf(\"size of integer is %d\\n\", sizeof(int)); printf(\"Address = %d, value = %d\\n\",p,*p); // ä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆ char *c; c = (char*)p; // è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ printf(\"size of integer is %d\\n\", sizeof(char)); // ç”±äºcharæŒ‡é’ˆåªæœ‰ä¸€ä¸ªå­—èŠ‚,åˆ™æœºå™¨åªçœ‹ä»å³è¾¹å¼€å§‹çš„ä¸€ä¸ªå­—èŠ‚ å³00000001 printf(\"Address = %d, value = %d\\n\",c,*c); // å¢åŠ ä¸€ä¸ªå­—èŠ‚,åˆ™æŒ‡é’ˆæŒ‡å‘ä»å³è¾¹å¼€å§‹çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ å³00000100 printf(\"Address = %d, value = %d\\n\",c+1,*(c+1)); // ä¸€ä¸ªvoidæŒ‡é’ˆ void *p0; p0 = p; // ä¸éœ€è¦æ˜¾å¼çš„ç±»å‹è½¬æ¢ // å½“p0æ²¡æŒ‡å‘ä»»ä½•ç‰¹å®šç±»å‹æ—¶,ä¸èƒ½è§£å¼•ç”¨ printf(\"Address = %d, value = %d\\n\",p0,*p0); // ä¹Ÿä¸è¦è¿›è¡Œç®—æœ¯è¿ç®— printf(\"Address = %d %d\\n\",p0,p0+1); } æŒ‡é’ˆç®—æœ¯è¿ç®— å¯¹ä¸€ä¸ªæŒ‡é’ˆè¿›è¡ŒåŠ 1æ“ä½œï¼Œç›¸å½“äºå°†è¯¥æŒ‡é’ˆå¢åŠ ä¸€ä¸ªè¯¥æŒ‡é’ˆæ•°æ®ç±»å‹æ‰€å å­—èŠ‚æ•°çš„å­—èŠ‚æ•° ä¾‹å¦‚å¯¹int *p=&amp;a; p++;å¾—åˆ°pçš„å€¼ä¸ºaçš„åœ°å€åŠ 4 123456789101112#include &lt;stdio.h&gt; int main(){ int a = 10; int *p; p = &amp;a; // æŒ‡é’ˆåŠ æ³• : +1ä»£è¡¨å¢åŠ ä¸€ä¸ªæ•°æ®ç±»å‹çš„å­—èŠ‚æ•° printf(\"Address p is %d\\n\",p); // pçš„åœ°å€ printf(\"Value at address p is %d\\n\",*p); // pæŒ‡å‘çš„å€¼ printf(\"size of integer is %d bytes\\n\", sizeof(int)); // intç±»å‹æ‰€å çš„å­—èŠ‚æ•° printf(\"Address p+1 is %d\\n\",p+1); // p+1æŒ‡å‘çš„åœ°å€ printf(\"Value at address p+1 is %d\\n\",*(p+1)); // p+1æŒ‡å‘çš„å€¼(åƒåœ¾å€¼) } æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆ å‡è®¾å®šä¹‰äº†ä¸€ä¸ªæ•°æ®int x = 5; æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘x int *p = &amp;x æ­¤æ—¶æˆ‘ä»¬å¯ä»¥å†å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æŒ‡é’ˆp int **q = &amp;p ç”šè‡³è¿˜å¯ä»¥å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æŒ‡é’ˆq int ***r = &amp;q (ræ˜¯205) ç¤ºä¾‹ä»£ç  123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int x =5; int* p = &amp;x; *p = 6; int** q = &amp;p; int*** r = &amp;q; printf(\"%d\\n\",*p); // pæŒ‡å‘xçš„å€¼ printf(\"%d\\n\",*q); // qæŒ‡å‘pçš„å€¼(xçš„åœ°å€) printf(\"%d\\n\",*(*q)); // qæŒ‡å‘pçš„å€¼æŒ‡å‘xçš„å€¼ printf(\"%d\\n\",*(*r)); // ræŒ‡å‘qçš„å€¼,qæŒ‡å‘pçš„å€¼ printf(\"%d\\n\",*(*(*r))); // ræŒ‡å‘qçš„å€¼,qæŒ‡å‘pçš„å€¼,pæŒ‡å‘xçš„å€¼ // æ›´æ”¹xçš„å€¼ ***r = 10; print(\"x = %d\\n\", x); // **qä¸*péƒ½æŒ‡å‘xçš„å€¼,åˆ™ç›¸å½“äºxè‡ªåŠ 2 **q = *p +2; print(\"x = %d\\n\", x); } æŒ‡é’ˆç”¨ä¾‹â€”å‡½æ•°ä¼ å¼•ç”¨ or ä¼ å€¼ï¼Ÿ e.g. å±€éƒ¨å˜é‡ä¸å…¨å±€å˜é‡ï¼š æœ‰ä»¥ä¸‹ä»£ç  12345678910#include &lt;stdio.h&gt; void f(int x){ x=x+1; } int main(){ int x=10; f(x); printf(\"%d\\n\",x); return 0; } è¯¥ä»£ç ä¸­çš„å‡½æ•°æƒ³è®©å˜é‡+1ï¼Œä½†è¾“å‡ºçš„ç»“æœæ˜¾ç„¶è¿˜æ˜¯10ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ çœ‹ä»¥ä¸‹ä»£ç ï¼š 1234567891011#include &lt;stdio.h&gt; void f(int x){ printf(\"Address of x in f is:%d\\n\",&amp;x); x=x+1; } int main(){ int x=10; f(x); printf(\"Address of x in main is:%d\\n\",&amp;x); return 0; } ä½ ä¼šæƒŠå¥‡çš„å‘ç°ï¼Œfå‡½æ•°ä¸­çš„xä¸mainå‡½æ•°ä¸­çš„xçš„åœ°å€ä¸ä¸€æ ·ï¼Œè¿™ä¹Ÿå°±è¯´æ˜äº†ä¸ºä»€ä¹ˆ+1ä¸æˆç«‹ å½“ç¨‹åºè¿è¡Œæ—¶ï¼Œè®¡ç®—æœºä¼šé¢„ç•™ä¸€éƒ¨åˆ†å†…å­˜ç»™ç¨‹åºï¼Œä»–ä»¬è¢«åˆ†ä¸ºå››ä¸ªéƒ¨åˆ†ï¼šæ ˆã€å †ã€æ•°æ®åŒºã€ä»£ç åŒº æ ˆï¼šéé™æ€å±€éƒ¨å˜é‡ï¼ˆå‡½æ•°å‚æ•°ç­‰ï¼‰ã€‚æ ˆæ˜¯å‘ä¸‹ç”Ÿé•¿çš„ å †ï¼šç”¨äºåŠ¨æ€å†…å­˜åˆ†é…ã€‚å †æ˜¯å‘ä¸Šç”Ÿé•¿çš„ æ•°æ®åŒºï¼šå­˜å‚¨å…¨å±€å˜é‡å’Œé™æ€å˜é‡ ä»£ç åŒºï¼šå¯æ‰§è¡Œçš„ä»£ç ä¸å¸¸é‡ å½“ä¸€ä¸ªç¨‹åºè¿›è¡Œæ—¶ï¼Œmainå‡½æ•°è¢«è°ƒç”¨ï¼Œå…³äºè¿™ä¸ªå‡½æ•°çš„ä¿¡æ¯ï¼ˆå¦‚å‚æ•°ï¼Œå±€éƒ¨å˜é‡ï¼Œè¿”å›åœ°å€ï¼‰ä¼šå­˜åœ¨æ ˆä¸Šï¼Œæ ˆä¾¿ä¸ºè¯¥å‡½æ•°å¼€è¾Ÿä¸€å—ç©ºé—´ï¼Œç§°ä¸ºæ ˆå¸§(stack frame)ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¼šæœ‰ä¸€ä¸ªæ ˆå¸§ è®©ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œä¸¤ä¸ªå‡½æ•°åˆ†åˆ«ç§°ä¸ºä¸»è°ƒå‡½æ•°ä¸è¢«è°ƒå‡½æ•°ï¼Œåœ¨ä¸»è°ƒå‡½æ•°ä¸­è°ƒç”¨å…¶ä»–å‡½æ•°ç”¨åˆ°çš„å‚æ•°ç§°ä¸ºå®é™…å‚æ•°ï¼Œè¢«è°ƒå‡½æ•°ä¸­çš„å‡½æ•°ç§°ä¸ºå½¢å¼å‚æ•°ï¼Œå®å‚ä¼šè¢«æ˜ å°„åˆ°å½¢å‚ã€‚è¿™ä¸ªæ“ä½œå³ä¼ å€¼ å½“mainå‡½æ•°è°ƒç”¨få‡½æ•°æ—¶ï¼Œä¸€å—å®ƒçš„æ ˆå¸§ä¼šè¢«åˆ›å»ºï¼Œå…¶ä¸­çš„å‚æ•°ä¼šè¢«åˆ†é…åˆ°å¯¹åº”ç©ºé—´ï¼Œæ‰§è¡Œ+1æ“ä½œåï¼Œè¿™ä¸ªå‡½æ•°çš„æ ˆå¸§ä¸­çš„å˜é‡æ‰§è¡Œäº†+1ï¼Œä½†ä¸å½±å“å…¶ä»–åœ°æ–¹çš„å˜é‡ã€‚ å½“få‡½æ•°æ‰§è¡Œå®Œæ¯•ï¼Œç¨‹åºå›åˆ°mainå‡½æ•°ï¼Œæ­¤æ—¶fçš„æ ˆå¸§ä¼šè¢«æ¸…é™¤ï¼Œmainå‡½æ•°ä¼šè¢«ç»§ç»­æ‰§è¡Œï¼Œæ•…å±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸåªæ˜¯å‡½æ•°æ‰§è¡ŒæœŸé—´ã€‚ æ¥ä¸‹æ¥è¿›è¡Œçš„å‡½æ•°æ˜¯printfå‡½æ•°ï¼Œè¿™æ˜¯ä¸€ä¸ªåº“å‡½æ•°ï¼Œåœ¨æ ˆä¸­åˆ›å»ºå®ƒçš„æ ˆå¸§å¹¶æŒ‡å‹ã€‚è¿™ä¸€ä¸ªç»“æ„è¢«ç§°ä¸º(å‡½æ•°)è°ƒç”¨æ ˆï¼Œå³ï¼šæ˜¯å°†ä¸€ä¸ªä¸ªå‡½æ•°çš„æ ˆå¸§ï¼ŒæŒ‰ç…§è°ƒç”¨çš„é¡ºåºä¾æ¬¡å‹å…¥æ ˆä¸­ï¼Œç­‰æœ€ä¸Šå±‚çš„å‡½æ•°æ‰§è¡Œå®Œäº†ï¼Œå°±å¼¹å‡ºç›¸åº”çš„æ ˆå¸§çš„è¿‡ç¨‹ æ³¨æ„ï¼šæ ˆæ˜¯æœ‰å¤§å°çš„ï¼Œå¦‚æœå› ä¸ºæ— é™é€’å½’ç­‰åŸå› å¯¼è‡´æ ˆå¸§ä¸€ç›´è¢«åˆ›å»ºè€Œä¸æ¸…é™¤ï¼Œç¨‹åºä¼šå› ä¸ºæ ˆæº¢å‡ºè€Œç»ˆæ­¢ é‚£ä¼ å¼•ç”¨èƒ½å¦å®ç°ï¼Ÿ 1234567891011#include &lt;stdio.h&gt; void f(int *p){ *p = (*p)+1; } int main(){ int a; a = 10; f(&amp;a); printf(\"a = %d\", a); return 0; } è¯¥å‡½æ•°ä¼ çš„æ˜¯åœ°å€ å½“è°ƒç”¨mainå‡½æ•°ï¼Œå®ƒçš„æ ˆå¸§è¢«åˆ›å»ºï¼Œa=10è¿›å…¥æ ˆã€‚ è°ƒç”¨få‡½æ•°ï¼Œå®ƒçš„æ ˆå¸§è¢«åˆ›å»ºï¼Œåˆ™pæ¥æ”¶åˆ°açš„åœ°å€ï¼Œå…¥æ ˆï¼Œæ­¤æ—¶pæŒ‡å‘aã€‚ åœ¨å‡½æ•°ä¸­è§£å¼•ç”¨pï¼Œå¹¶æ‰§è¡Œæ“ä½œï¼ŒpæŒ‡å‘çš„å†…å­˜(a)çš„å€¼å°±ä¼šå¢åŠ ï¼Œå³açš„å€¼å¢åŠ 1 å›åˆ°mainå‡½æ•°ï¼Œaçš„å€¼å°±æ˜¯11 è¿™å°±æ˜¯ä¼ å¼•ç”¨ï¼Œå®ƒå¯ä»¥èŠ‚çœå¾ˆå¤šå†…å­˜ç©ºé—´ï¼Œä¹Ÿå¯ä»¥å¤„ç†ä¸€äº›å¤æ‚æ•°æ®ç±»å‹ä»¥èŠ‚çœå†…å­˜ æŒ‡é’ˆä¸æ•°ç»„ è®©æˆ‘ä»¬å£°æ˜ä¸€ä¸ªæ•°ç»„ int a[5] å³æˆ‘ä»¬åˆ›å»ºäº†äº”ä¸ªæ•´å‹å˜é‡ï¼Œåœ¨å†…å­˜ä¸­è¿ç»­å­˜åœ¨(int å å››ä¸ªå­—èŠ‚)ï¼Œåˆ™æ•´ä¸ªæ•°ç»„å çš„å¤§å°ä¸º20bytesï¼Œä½œä¸ºä¸€ä¸ªè¿ç»­çš„å— æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆint* pï¼Œå°†pæŒ‡å‘açš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™pè§£å¼•ç”¨åæ‰“å°çš„æ˜¯a[0]çš„å€¼ å›å¿†ä¹‹å‰è¯´çš„æŒ‡é’ˆç®—æœ¯ï¼Œè‹¥æˆ‘ä»¬å°†p+1ï¼Œåˆ™pä¼šå¾€å‰ç§»åŠ¨å››ä¸ªå­—èŠ‚ï¼Œ**æ­¤æ—¶*(p+1)å³a[0]åå››ä¸ªå­—èŠ‚çš„å€¼ï¼Œå³a[1]** ä¸ä¹‹å‰ä¸åŒï¼Œä¸€ä¸ªå€¼å®ƒçš„åœ°å€+1åä¼šç§»åŠ¨åˆ°ä¸€ä¸ªæœªçŸ¥å†…å®¹çš„åœ°å€ï¼Œè€Œæ•°ç»„aä¸­+1åpæŒ‡å‘çš„å€¼æ˜¯å·²çŸ¥çš„ è‹¥ç›´æ¥å°†æ•°ç»„åèµ‹å€¼ç»™pï¼Œåˆ™pé»˜è®¤æ¥æ”¶åˆ°çš„æ˜¯æ•°ç»„aé¦–å…ƒç´ çš„åœ°å€ï¼Œç§°ä¸ºæ•°ç»„çš„åŸºåœ°å€ è‹¥æƒ³è·å¾—æ•°ç»„æŸä¸ªå€¼çš„åœ°å€ï¼Œå¯ä»¥ä½¿ç”¨&amp;a[i]æˆ–è€…a+i è‹¥æƒ³è·å¾—æ•°ç»„æŸä¸ªå€¼ï¼Œå¯ä»¥ä½¿ç”¨a[i]æˆ–è€…*(a+i) æ³¨æ„ï¼šå¯¹æ•°ç»„åï¼ˆå¸¸é‡ ï¼‰è‡ªåŠ æ˜¯éæ³•çš„ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„åè®©è¯¥æŒ‡é’ˆè‡ªåŠ  å®ä¾‹ä»£ç ï¼š 1234567891011#include &lt;stdio.h&gt; int main(){ int a[]={2,4,5,8,1}; for (int i = 0;i&lt;5;i++){ printf(\"Address = %d\\n\",&amp;a[i]); printf(\"Address = %d\\n\",a+i); printf(\"Value = %d\\n\",a[i]); printf(\"Value = %d\\n\", *(a+i)); } } æŒ‡é’ˆç”¨ä¾‹â€”æ•°ç»„ä¼ å‚ 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int suma(int a[],int size){ int sum = 0; for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int sumb(int a[]){ int sum = 0; int size = sizeof(a)/sizeof(a[0]); printf(\"In sumb - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int main(){ int a[]={1,2,3,4,5}; // è®¡ç®—æ•°ç»„å¤§å° printf(\"In main - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); int size = sizeof(a)/sizeof(a[0]); // ä¼ å…¥æ•°ç»„å¤§å°åè¿›è¡ŒåŠ å’Œ int tot = suma(a,size); // åœ¨å‡½æ•°ä¸­è®¡ç®—æ•°ç»„å¤§å°å¹¶åŠ å’Œ int tot2 = sumb(a); printf(\"tot = %d\\n\", tot); printf(\"tot2 = %d\\n\", tot2); } ä»¥ä¸Šä»£ç ä¼šå‡ºç°ä¸€äº›é—®é¢˜ï¼š åœ¨è°ƒç”¨mainä¸sumbå‡½æ•°æ—¶ï¼Œå®ƒä»¬çš„æ ˆå¸§ä¼šè¢«åˆ›å»º è°ƒç”¨sumbå‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨åªä¼šåˆ›å»ºä¸€ä¸ªåŒåçš„æŒ‡é’ˆåœ¨sumbçš„æ ˆå¸§ä¸­ï¼Œå³å®ƒåªæŒ‡å‘mainå‡½æ•°ä¸­æ•°ç»„açš„é¦–å…ƒç´ åœ°å€ï¼ˆå³int a[]ç­‰åŒäºint *aï¼‰ å› æ­¤å‡½æ•°ä¸­çš„sizeof aæ˜¯ä¸€ä¸ª8å­—èŠ‚çš„æŒ‡é’ˆã€‚ æŒ‡é’ˆä¸å­—ç¬¦æ•°ç»„ å­—ç¬¦æ•°ç»„ Cä¸­çš„å­—ç¬¦ä¸²å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼Œå¿…é¡»ä»¥â€™\\0â€™ç»“æŸ å­—ç¬¦æ•°ç»„èµ‹å€¼ï¼š å¯ä»¥æŒ‡å®šæ¯ä¸€ä½è¿›è¡Œèµ‹å€¼ï¼Œ æˆ–è€…ä½¿ç”¨å­—ç¬¦ä¸²å­—é¢å€¼ï¼ˆç”¨åŒå¼•å·æ‹¬èµ·æ¥çš„å­—ç¬¦ä¸²ï¼‰èµ‹å€¼ï¼Œè¯¥æ–¹æ³•ä¼šéšå¼åœ°æ·»åŠ ä¸€ä¸ªâ€™\\0â€™ æˆ–è€…ä½¿ç”¨å¤§æ‹¬å·åˆå§‹åŒ–æ¯ä¸€ä½ï¼Œä»¥é€—å·é—´éš”å¹¶åœ¨ç»“å°¾åŠ ä¸Šâ€™\\0â€™ æ³¨æ„ï¼šåªèƒ½åœ¨å£°æ˜åŒæ—¶ç”¨å­—ç¬¦ä¸²å­—é¢å€¼èµ‹å€¼ ä½¿ç”¨æŒ‡é’ˆ å­—ç¬¦æ•°ç»„ä¸­æ•°ç»„åä»£è¡¨çš„æ˜¯æ•°ç»„é¦–å…ƒç´ çš„åœ°å€ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªæŒ‡é’ˆå˜é‡æŒ‡å‘å®ƒï¼Œè¯¥å˜é‡ä¹Ÿå¯ä»¥å¯¹å­—ç¬¦æ•°ç»„è¿›è¡Œæ“ä½œ 12345678910#include &lt;stdio.h&gt; int main(){ char c1[6]=\"Hello\"; char *c2; c2 = c1; c2[0]='A'; // equal to c1[0]='A'; c2++; // æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´  c1++; // éæ³• } æœ‰ç­‰ä»·å…³ç³»ï¼š c2[i]ç­‰åŒäº*(c2+i) c1[i]ç­‰åŒäº*(c1+i) å‡½æ•°ä¼ å‚ 12345678910111213141516171819#include&lt;stdio.h&gt; void print(char *c){ int i = 0; // while (c[i]!='\\0'){ // *(c+i)ä¹Ÿå¯ä»¥ // printf(\"%c\",c[i]); // i++; // } // ç”±äºcæ˜¯æŒ‡é’ˆï¼Œæ•…å¯ä»¥é€šè¿‡è‡ªå¢ä¸è§£å¼•ç”¨æ¥è¿›è¡Œè®¿é—® while(*c!='\\0'){ printf(\"%c\",*c); c++; } printf(\"\\n\"); } int main(){ char c[20] = \"Hello\"; print(c); return 0; } æŒ‡é’ˆä¸äºŒç»´æ•°ç»„ å¦‚æœæˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„b[2][3] æ­¤æ—¶ï¼Œb[0]ä¸b[1]è¡¨ç¤ºä¸‰ä¸ªæ•´æ•°çš„ä¸€ç»´æ•°ç»„ï¼Œåœ¨å†…å­˜ä¸­å ç”¨3*4=12ä¸ªå­—èŠ‚ï¼Œæ˜¯æŒ‰è¡Œå­˜å‚¨çš„ æ•…int *p=b;æŒ‡ä»£çš„æ˜¯è¿”å›ä¸€ä¸ªæŒ‡å‘ä¸€ç»´æ•°ç»„çš„æŒ‡é’ˆï¼Œæ­¤æ—¶ä¸èƒ½æŒ‡é’ˆè¿ç®—æˆ–è§£å¼•ç”¨ï¼Œæ•…ä¸èƒ½è¿™ä¹ˆç”¨ æ•…åº”ä½¿ç”¨int (*p)[3]æ¥åˆ›å»ºä¸€ä¸ªäºŒç»´æŒ‡é’ˆæ•°ç»„ï¼Œå…¶ä¸­3è¡¨ç¤ºä¸‰ä¸ªæŒ‡å‘ä¸€ç»´æ•°ç»„çš„æŒ‡é’ˆ è¿™æ—¶print b or &amp;b[0]éƒ½æŒ‡ä»£ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ â€‹ print *b or b[0] or &amp;b[0][0]éƒ½æŒ‡ä»£ç¬¬ä¸€ä¸ªå…ƒç´ åœ°å€çš„å€¼ â€‹ print b+1 or &amp;b[1]ä¼šè·³åˆ°ä¸‹ä¸€ä¸ªæ•°ç»„çš„é¦–åœ°å€ï¼ˆ+12ï¼‰ ä½¿ç”¨print *(b+ 1)or b[i]or&amp;b[1][0]æŒ‡ä»£ä¸‹ä¸€ä¸ªæŒ‡å‘ä¸€ç»´æ•°ç»„çš„å¹¶è¿”å› å€¼ è§£å¼•ç”¨æ—¶ï¼Œéœ€è¦ä¸€æ­¥æ­¥è§£ ä¾‹ *(*b+1) *b ä¸ºb[0]ï¼Œä¸€ä¸ªä¸€ç»´æ•°ç»„çš„é¦–å…ƒç´ åœ°å€ï¼Œ*b+1ä¼šè®©æŒ‡é’ˆç§»åŠ¨å››ä¸ªå­—èŠ‚å¸¦åˆ°ä¸‹ä¸€ä¸ªæ•´å‹å˜é‡ï¼Œ ç›¸å½“äº&amp;b[0][1] æˆ‘ä»¬è§£å¼•ç”¨åï¼Œ*(*b+1)å°±ç›¸å½“äºb[0][1] æŒ‡é’ˆè¿ç®—ï¼šb[i][j]=*(b[i]+j)=*(*(b+i)+j) æŒ‡é’ˆä¸å¤šç»´æ•°ç»„ åŸç† ä¸äºŒç»´æ•°ç»„ç±»ä¼¼ å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªintæ•°ç»„c[3][2][2]ï¼Œåœ¨å†…å­˜ä¸­çš„å­˜å‚¨å¦‚ä¸‹ ç®€åŒ–ä¸ºä¸‰ä¸ªäºŒç»´æ•°ç»„çº¿æ€§å­˜å‚¨ï¼Œæ¯ä¸ªäºŒç»´æ•°ç»„å†…ä¸¤ä¸ªä¸€ç»´æ•°ç»„çº¿æ€§å­˜å‚¨ æ•…æˆ‘ä»¬å¯ä»¥å£°æ˜ä¸€ä¸ªæŒ‡é’ˆint (*p)[2][2] = c;ï¼ŒæŒ‡å‘2*2çš„äºŒç»´æ•°ç»„ è¿™æ—¶print cï¼Œprint *cï¼Œprint c[0]ï¼Œprint &amp;c[0][0]å‡è¾“å‡ºç¬¬ä¸€ä¸ªä¸€ç»´æ•°ç»„çš„åœ°å€ æŒ‡é’ˆè¿ç®—ï¼šc[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) å¯ä»¥ç†è§£ä¸ºè§£å¼•ç”¨ä¸€æ¬¡å°±è„±ä¸€å±‚[] e.g. print *(c[0][1]+1)æŒ‡å‘çš„æ˜¯c[0][1][1] print *(c[1]+1)æŒ‡å‘çš„æ˜¯c[1][1]ï¼Œå³c[1][1][0] ç”¨äºå‡½æ•°ä¼ å‚ å¦‚ä¸€ç»´æ•°ç»„ä¼ å‚ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¼ å€¼æˆ–ä¼ å¼•ç”¨ä¸¤ç§æ–¹æ³•ä¼ å‚ æ³¨æ„ï¼šä¼ å€¼æ—¶é™¤äº†æœ€é«˜ç»´åº¦ï¼Œå…¶ä»–ç»´åº¦å¿…é¡»è¦æŒ‡å®šåç§»é‡ï¼ˆå³å½¢å‚å®šä¹‰æ—¶å¿…é¡»å’Œä¼ å…¥æ•°ç»„é•¿åº¦ä¸€æ ·ï¼‰ 123456int two_dim(int a[][3]){ } int three_dim(int a[][2][2]){ } è€Œæ ¹æ®æ•°ç»„åå°±æ˜¯æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä¼ å¼•ç”¨æ¥å®ç°é™ç»´åº¦ æ³¨æ„ï¼šåªèƒ½é™åˆ°æ¬¡ä¸€çº§ç»´åº¦ï¼Œä¸”å…¶ä½™çš„å¿…é¡»æŒ‡å®šåç§»é‡ 123456int two_dim(int (*a)[3]){ } int three_dim(int (*a)[2][2]){ } æŒ‡é’ˆä¸åŠ¨æ€å†…å­˜ å†…å­˜çš„åˆ†é… åœ¨ä¸€ä¸ªå…¸å‹æ¶æ„ä¸­ï¼Œåˆ†é…ç»™åº”ç”¨ç¨‹åºçš„å†…å­˜åˆ†ä¸ºå››ä¸ªåŒºæ®µï¼šæ ˆã€å †ã€æ•°æ®åŒºã€ä»£ç åŒº æ ˆï¼šéé™æ€å±€éƒ¨å˜é‡ï¼ˆå‡½æ•°å‚æ•°ç­‰ï¼‰ï¼Œå‡½æ•°è°ƒç”¨ä¿¡æ¯ã€‚æ ˆæ˜¯å‘ä¸‹ç”Ÿé•¿çš„ å †ï¼šç”¨äºåŠ¨æ€å†…å­˜åˆ†é…ã€‚å †æ˜¯å‘ä¸Šç”Ÿé•¿çš„ æ•°æ®åŒºï¼šå­˜å‚¨å…¨å±€å˜é‡å’Œé™æ€å˜é‡ ä»£ç åŒºï¼šå¯æ‰§è¡Œçš„ä»£ç ä¸å¸¸é‡ æ ˆ å½“ä¸€ä¸ªç¨‹åºè¿›è¡Œæ—¶ï¼Œmainå‡½æ•°è¢«è°ƒç”¨ï¼Œå…³äºè¿™ä¸ªå‡½æ•°çš„ä¿¡æ¯ï¼ˆå¦‚å‚æ•°ï¼Œå±€éƒ¨å˜é‡ï¼Œè¿”å›åœ°å€ï¼‰ä¼šå­˜åœ¨æ ˆä¸Šï¼Œæ ˆä¾¿ä¸ºè¯¥å‡½æ•°å¼€è¾Ÿä¸€å—ç©ºé—´ï¼Œç§°ä¸ºæ ˆå¸§(stack frame)ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¼šæœ‰ä¸€ä¸ªæ ˆå¸§ï¼Œå¤§å°åœ¨ç¼–è¯‘æœŸé—´å†³å®š æ‰€æœ‰å‡½æ•°ä»ä¸‹å¾€ä¸Šå¼€è¾Ÿæ ˆå¸§åï¼Œåœ¨æ‰§è¡Œæ—¶æ€»æ˜¯æ ˆé¡¶çš„å‡½æ•°åœ¨æ‰§è¡Œï¼Œå…¶ä½™å‡½æ•°æš‚åœï¼Œç­‰å¾…ä¸Šæ–¹å‡½æ•°è¿”å›å€¼ç­‰ã€‚å½“ä¸Šæ–¹å‡½æ•°è¿”å›åï¼Œå®ƒå ç”¨æ ˆçš„å†…å­˜ä¹Ÿä¼šè¢«æ¸…é™¤ï¼Œä¸‹ä¸€ä¸ªå‡½æ•°è¿è¡Œã€‚ä»»ä½•æ—¶å€™æ­£åœ¨æ‰§è¡Œçš„å‡½æ•°éƒ½æ˜¯æ ˆé¡¶çš„é‚£ä¸ªå‡½æ•° é¢„ç•™ç»™æ ˆçš„ç©ºé—´åœ¨è¿è¡ŒæœŸé—´å¹¶ä¸ä¼šå¢é•¿ï¼Œä¹Ÿä¸èƒ½è¯·æ±‚æ›´å¤šå†…å­˜ã€‚å¦‚æœè¿è¡Œæ—¶çš„æ ˆå¢é•¿è¶…è¿‡äº†ç¨‹åºé¢„ç•™çš„æ ˆå†…å­˜å¤§å°ï¼Œé‚£ä¹ˆä¼šé€ æˆæ ˆæº¢å‡º(stack overflow) å› æ­¤æ ˆæœ‰ä¸¤ä¸ªé™åˆ¶ï¼š åœ¨æ ˆä¸Šçš„å˜é‡æ— æ³•æ“ä½œéª‘ä½œç”¨åŸŸ å½“å£°æ˜ä¸€ä¸ªå¾ˆå¤§çš„æ•°æ®ç±»å‹ï¼Œå¯èƒ½ä¼šé€ æˆæº¢å‡ºï¼›ä¸”åªèƒ½åœ¨ç¼–è¯‘æ—¶åˆ†é…ä»–çš„å¤§å°ï¼Œæ— æ³•åœ¨ç¨‹åºè¿è¡Œæ—¶åˆ†é…å®ƒçš„å¤§å° å †(åŠ¨æ€å†…å­˜) è¿™æ—¶æˆ‘ä»¬éœ€è¦ç”¨åˆ°å †æ¥åˆ†é…æˆ–é”€æ¯æˆ–å†…å­˜ã€‚æˆ‘ä»¬å¯ä»¥ä»»æ„ä½¿ç”¨å †ä¸Šçš„å†…å­˜ï¼Œåªè¦ä¸è¶…è¿‡ç³»ç»Ÿå†…å­˜é™åˆ¶ã€‚ å †åˆç§°ä¸ºåŠ¨æ€å†…å­˜ï¼Œä½¿ç”¨å †å†…å­˜ç§°ä¸ºåŠ¨æ€å†…å­˜åˆ†é… (æ³¨æ„è¿™é‡Œçš„å †å¹¶ä¸æ˜¯æ•°æ®ç»“æ„) Cé£æ ¼ï¼š 12345678910111213#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; // åˆ†é…åˆ°æ ˆä¸Š int *p; // æŒ‡å‘å †å†…å­˜çš„æŒ‡é’ˆ p = (int*)malloc(sizeof(int)); // åœ¨å †ä¸Šå¼€è¾Ÿä¸€å—å››å­—èŠ‚çš„å†…å­˜ï¼Œè®©æŒ‡é’ˆpæŒ‡å‘å…¶åœ°å€ *p=10; // è§£å¼•ç”¨å°†å€¼å­˜å…¥å † free(p); // é‡Šæ”¾å†…å­˜ p = (int*)malloc(20*sizeof(int)); // åœ¨å †ä¸Šå†å¼€è¾Ÿä¸€å—20ä¸ªå››å­—èŠ‚çš„å†…å­˜ä½œä¸ºæ•°ç»„ï¼Œè®©æŒ‡é’ˆpæŒ‡å‘å…¶é¦–å…ƒç´ åœ°å€ // å¯ä»¥ç”¨ä»¥ä¸‹ä¸¤ç§æ–¹å¼è®¿é—® p[0] = 1; *(p+1) = 2; } å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆå˜é‡pï¼Œå®ƒè¢«å­˜å‚¨åœ¨æ ˆä¸­ï¼ŒæŒ‡å‘å †ä¸­åˆ†é…çš„å†…å­˜åœ°å€ é€šè¿‡mallocåœ¨å †ä¸Šåˆ†é…ä¸€å—å››å­—èŠ‚çš„å†…å­˜ï¼Œmallocä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘è¿™å—å†…å­˜èµ·å§‹åœ°å€çš„æŒ‡é’ˆï¼Œvoidç±»å‹ã€‚æ•…æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€ä¸ªå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå¹¶èµ‹ç»™æŒ‡é’ˆå˜é‡p ä½¿ç”¨å †ä¸Šå†…å­˜çš„å”¯ä¸€æ–¹å¼æ˜¯é€šè¿‡å¼•ç”¨ï¼Œè‡ªå·±ç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¿™å—å†…å­˜ã€‚æˆ‘ä»¬é€šè¿‡å¯¹æŒ‡é’ˆå˜é‡pè§£å¼•ç”¨å¹¶èµ‹å€¼æ¥ä½¿ç”¨ã€‚ è‹¥æˆ‘ä»¬å†ä»¥åŒæ ·æ–¹å¼åˆ†é…ä¸€å—å››å­—èŠ‚å†…å­˜ï¼Œè®©pæŒ‡å‘å®ƒï¼Œå¹¶èµ‹å€¼ä¸º20ï¼Œpæ­¤æ—¶æŒ‡å‘çš„ä¾¿æ˜¯å †ä¸­çš„å¦ä¸€å—å†…å­˜ã€‚è€Œä¹‹å‰é‚£å—å†…å­˜ä»åœ¨å †ä¸Šï¼Œå¹¶ä¸ä¼šè¢«è‡ªåŠ¨å›æ”¶ï¼Œæ­¤æ—¶ç§°ä¸ºå†…å­˜æ³„æ¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨ç”¨å®Œä¸€å—å†…å­˜åï¼ŒåŠæ—¶è°ƒç”¨free()é‡Šæ”¾å†…å­˜ã€‚ å¦‚æœè¦åˆ†é…ä¸€ä¸ªæ•°ç»„å†…å­˜ï¼Œæˆ‘ä»¬åªéœ€è¦ä¼ å…¥æ•°ç»„å¤§å°å­—èŠ‚æ•°å³å¯ï¼Œè¿”å›çš„æ˜¯å†…å­˜çš„åˆå§‹åœ°å€ è‹¥mallocæ— æ³•åœ¨å †ä¸ŠæˆåŠŸåˆ†é…å†…å­˜ï¼Œä¼šè¿”å›NULL C++é£æ ¼ï¼š 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; int *p; // æŒ‡å‘å †å†…å­˜çš„æŒ‡é’ˆ p = new int; // åœ¨å †ä¸Šå¼€è¾Ÿä¸€å—intå¤§å°çš„å†…å­˜(å››å­—èŠ‚) *p = 10; // è§£å¼•ç”¨å¹¶èµ‹å€¼ delete p; // é‡Šæ”¾å†…å­˜ p = new int[20]; // åœ¨å †ä¸Šå¼€è¾Ÿä¸€ä¸ª20å¤§å°çš„intæ•°ç»„ delete[] p; // é‡Šæ”¾æ•°ç»„å†…å­˜ } c++ä¸­ä½¿ç”¨å…³é”®å­—newä¸deleteå¼€è¾Ÿä¸é‡Šæ”¾å†…å­˜ï¼Œä¸éœ€è¦ç±»å‹è½¬æ¢ ç›¸å…³å‡½æ•° malloc å®šä¹‰ï¼švoid* malloc(size_t size)(size_tç›¸å½“äºæ— ç¬¦å·æ•´æ•°) ç”¨æ³•ï¼šint *p = (int*)malloc(åˆ†é…ç©ºé—´å¤§å°) åˆ†é…ç©ºé—´å¤§å°ä¸€èˆ¬ä¹ æƒ¯é€šè¿‡sizeofè®¡ç®—ï¼Œå¦‚æƒ³è¦å¼€è¾Ÿä¸€ä¸ªå­˜å‚¨ä¸‰ä¸ªintå˜é‡çš„æ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨3*sizeof(int)æ¥è®¡ç®—å¤§å°ï¼Œä¸€èˆ¬ä¸ç›´æ¥å†™ã€‚ ç”±äºmallocè¿”å›çš„æ˜¯voidæŒ‡é’ˆï¼ŒæŒ‡å‘å…¶åˆå§‹åœ°å€ï¼Œè€ŒvoidæŒ‡é’ˆæ— æ³•è§£å¼•ç”¨ï¼Œå› æ­¤æˆ‘ä»¬ä¸€èˆ¬åœ¨å‰é¢è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢æ¥è½¬åŒ–æˆintæŒ‡é’ˆä»¥æ–¹ä¾¿æ“ä½œ mallocä¸ä¼šå°†åˆ†é…çš„ç©ºé—´åˆå§‹åŒ–ï¼Œå»ºè®®ä½¿ç”¨memset(p,0x00,sizeof(p))åˆå§‹åŒ– calloc å®šä¹‰ï¼švoid* calloc(size_t num, size_t size) ç”¨æ³•ï¼šint *p = (int*)calloc(åˆ†é…å…ƒç´ ä¸ªæ•°, æ¯ä¸ªå…ƒç´ ç©ºé—´å¤§å°) callocå¯ä»¥æŒ‡å®šåˆ†é…çš„å…ƒç´ ä¸ªæ•° callocåœ¨åˆ†é…ç©ºé—´åä¼šè‡ªåŠ¨å°†å…¶åˆå§‹åŒ–ä¸º0 realloc å®šä¹‰ï¼švoid* realloc(void* ptr, size_t size) ç”¨æ³•ï¼šrealloc(å·²æŒ‡å‘æŸå¤„å†…å­˜çš„æŒ‡é’ˆ, ä¿®æ”¹ç©ºé—´å¤§å°) reallocç”¨äºä¿®æ”¹åˆ†é…çš„å†…å­˜å¤§å° è‹¥éœ€è¦çš„æ–°å†…å­˜å—æ¯”åŸæ¥å¤§ï¼Œç¨‹åºä¼šåˆ›å»ºä¸€å—æ–°å†…å­˜å¹¶å°†å†…å®¹å¤åˆ¶è¿‡å» è‹¥ä¹‹å‰çš„å†…å­˜çš„ç›¸é‚»éƒ¨åˆ†è¿˜æœ‰å¯ç”¨å†…å­˜ï¼Œç¨‹åºä¼šç›´æ¥æ‹“å±•åŸç©ºé—´ è‹¥éœ€è¦çš„æ–°å†…å­˜å—æ¯”åŸæ¥å°ï¼Œåˆ™å¤šä½™éƒ¨åˆ†çš„å†…å­˜ä¼šè¢«é‡Šæ”¾æ‰ æ³¨æ„ä»¥ä¸‹ç”¨æ³•ï¼š 12int *a = (int*)realloc(a,0); // ç›¸å½“äºfree(a) int *b = (int*)realloc(NULL,n*sizeof(int)); // ç›¸å½“äºmalloc å†…å­˜æ³„æ¼ å½“æˆ‘ä»¬åŠ¨æ€ç”³è¯·äº†å†…å­˜åï¼Œå¿˜è®°å»é‡Šæ”¾ï¼Œæ­¤æ—¶ç¨‹åºå ç”¨äº†ä¸€äº›æœªä½¿ç”¨çš„å†…å­˜ï¼Œç§°ä¸ºå†…å­˜æ³„éœ² å¯¹äºæ ˆï¼šç”±äºæ ˆå¸§åœ¨ä½¿ç”¨å®Œåä¼šè¢«è‡ªåŠ¨é”€æ¯ï¼Œæ•…ä¸ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼ å¯¹äºå †ï¼šåœ¨å¼€è¾Ÿç©ºé—´åï¼Œå †ä¸Šçš„å†…å­˜å¿…é¡»è¦è¢«æ˜¾å¼åœ°é‡Šæ”¾æ‰ï¼Œå¦åˆ™ä¼šä¸€ç›´å­˜åœ¨ æ³¨æ„ï¼šä»»ä½•æœªä½¿ç”¨å’Œæœªå¼•ç”¨çš„å †ä¸Šå†…å­˜éƒ½æ˜¯åƒåœ¾ï¼Œç¨‹åºå‘˜è¦ç¡®ä¿ä¸è¦æµªè´¹å†…å­˜ å‡½æ•°è¿”å›æŒ‡é’ˆ æˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°ç±»å‹å¤„åŠ ä¸Š*æ¥å£°æ˜å‡½æ•°è¿”å›å€¼æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚ æ³¨æ„ä»¥ä¸‹æƒ…å†µï¼š 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // ç°åœ¨è¯¥å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªintç±»å‹çš„æŒ‡é’ˆï¼Œå³cçš„åœ°å€ void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int c = (*a)+(*b); return &amp;c; } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } è¯¥ç¨‹åºå¯¹printçš„è¾“å‡ºæ­£å¸¸ï¼Œè€Œè¾“å‡ºsumæ—¶å‡ºç°äº†å¼‚å¸¸ï¼Œä»åº•å±‚åŸç†åˆ†æï¼š æ‰§è¡Œmainå‡½æ•°ï¼Œå¼€è¾Ÿæ ˆå¸§ï¼Œæ‰§è¡Œaddå‡½æ•°ï¼Œåœ¨mainå‡½æ•°ä¸Šå†å¼€è¾Ÿæ ˆå¸§ï¼Œmainå‡½æ•°ä¼šç­‰å¾…addè¿”å› æ­¤æ—¶addä¸­aä¸bå­˜å‚¨äº†mainå‡½æ•°ä¸­xä¸yçš„åœ°å€ï¼Œcå­˜å‚¨äº†*aä¸*bçš„å’Œï¼Œè¿”å›çš„æ˜¯cçš„åœ°å€ï¼Œæ•…mainå‡½æ•°ä¸­çš„pæŒ‡é’ˆå­˜å‚¨çš„æ˜¯cçš„åœ°å€ addæ‰§è¡Œå®Œæ¯•ï¼Œå ç”¨ç©ºé—´è¢«æ¸…é™¤ã€‚ä½†æ³¨æ„ï¼Œæ­¤æ—¶pæŒ‡å‘çš„å†…å­˜ä»æœªå˜åŒ–ï¼Œå³æ­¤æ—¶å®ƒæŒ‡å‘äº†è¢«é‡Šæ”¾æ‰çš„å†…å­˜ç©ºé—´ï¼Œå€¼æ˜¯éšæœºçš„ ç°åœ¨æ‰§è¡Œprintå‡½æ•°ï¼Œå¼€è¾Ÿæ ˆå¸§ï¼ŒåŸç©ºé—´è¢«è¦†ç›–ï¼Œå› æ­¤på­˜å‚¨çš„åœ°å€å¯¹åº”çš„å€¼å·²ç»ä¸æ˜¯cçš„å€¼äº†ï¼Œå› æ­¤è¾“å‡ºå¼‚å¸¸ã€‚ è¿˜æœ‰ä¸€ç§æƒ…å†µï¼šè‹¥ä¸æ‰§è¡Œprintå‡½æ•°ï¼Œè¾“å‡ºçš„å€¼å¯èƒ½ä¼šæ­£ç¡®ã€‚å› ä¸ºæ­¤æ—¶ç¨‹åºè¿˜æ²¡é‡å†™æˆ–æ¸…é™¤é‚£ä¸ªç©ºé—´ä¸Šçš„æ•°æ®ï¼ˆè™½ç„¶å·²ç»é‡Šæ”¾ç©ºé—´ï¼‰ è€Œå¯¹äºmainä¸addå‡½æ•°ï¼Œç”±äºè¢«è°ƒå‡½æ•°çš„æ ˆç©ºé—´æ€»æ˜¯åœ¨ä¸»è°ƒå‡½æ•°ä¹‹ä¸Šï¼Œå› æ­¤è¢«è°ƒå‡½æ•°æ‰§è¡Œæ—¶ä¸»è°ƒå‡½æ•°ä»åœ¨æ ˆå†…å­˜ä¸­ï¼Œå› æ­¤addå¯ä»¥è®¿é—®mainå‡½æ•°ä¸­çš„å˜é‡ã€‚ä½†è‹¥æˆ‘ä»¬æƒ³è¦è¿”å›è¢«è°ƒå‡½æ•°çš„ä¸€ä¸ªå±€éƒ¨å˜é‡ç»™ä¸»è°ƒå‡½æ•°ï¼Œå½“è¢«è°ƒå‡½æ•°ç»“æŸåï¼Œå†…å­˜å·²è¢«é‡Šæ”¾ï¼Œå› æ­¤ä¼šå‡ºé—®é¢˜ã€‚ å› æ­¤å¯ä»¥ä»æ ˆåº•å‘ä¸Šä¼ å±€éƒ¨å˜é‡æˆ–å±€éƒ¨å˜é‡çš„åœ°å€ï¼Œä½†ä¸èƒ½ä»æ ˆé¡¶å‘ä¸‹ä¼ å±€éƒ¨å˜é‡æˆ–å±€éƒ¨å˜é‡çš„åœ°å€ å› æ­¤æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ï¼š 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // ç°åœ¨è¯¥å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªintç±»å‹çš„æŒ‡é’ˆï¼Œå³cçš„åœ°å€ void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int *c = (int*)malloc(sizeof(int)); // åœ¨å †ä¸Šå¼€è¾Ÿå†…å­˜ *c = (*a)+(*b); return c; // è¿”å›çš„æ˜¯å †ä¸Šçš„æŒ‡é’ˆ } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } æˆ‘ä»¬å°†cå¼€è¾Ÿåœ¨å †ä¸Šï¼Œæ­¤æ—¶å°±ä¸ä¼šè¢«æ¸…é™¤äº†ï¼Œè¿”å›cæ˜¯å®‰å…¨çš„ å‡½æ•°æŒ‡é’ˆ æˆ‘ä»¬å¯ä»¥ç”¨æŒ‡é’ˆæŒ‡å‘å‡½æ•°åœ°å€ï¼Œå³æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆã€‚æˆ‘ä»¬å¯ä»¥ç”¨è¿™ç§æŒ‡é’ˆè§£å¼•ç”¨å’Œè°ƒç”¨å‡½æ•°ã€‚ å‡½æ•°çš„åœ°å€ åœ¨å†…å­˜ä¸­ï¼Œä¸€ä¸ªå‡½æ•°å°±æ˜¯ä¸€å—è¿ç»­çš„å†…å­˜ã€‚ ä¸€èˆ¬ç¨‹åºæ‰§è¡ŒæŒ‡ä»¤ä¼šæŒ‰ç…§åœ°å€ä¾æ¬¡æ‰§è¡Œï¼Œè€Œå‡½æ•°è°ƒç”¨å¯ä»¥è®©ç¨‹åºè·³åˆ°æŸä¸€ä¸ªåœ°å€å¼€å§‹æ‰§è¡Œå…¶ä¸­çš„æŒ‡ä»¤ã€‚ æ­¤æ—¶å¯¹åº”çš„å‡½æ•°åœ°å€å¯ä»¥ç§°ä¸ºå‡½æ•°çš„å…¥å£ç‚¹ï¼Œå³å‡½æ•°ç¬¬ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ å‡½æ•°æŒ‡é’ˆçš„ä½¿ç”¨ 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(char *name){ printf(\"hello\"); } int add(int a, int b){ return a+b; } int main(){ int c; int (*p)(int,int); // å‡½æ•°æŒ‡é’ˆ p = &amp;add; // æŒ‡é’ˆæŒ‡å‘addå‡½æ•°çš„åœ°å€(ä¸ç”¨&amp;ä¹Ÿå¯) c = (*p)(2,3); // è§£å¼•ç”¨ï¼Œå¹¶ä¼ å…¥å‚æ•°æ‰§è¡Œå‡½æ•°(ä¸ç”¨è§£å¼•ç”¨ä¹Ÿè¡Œ) printf(\"%d\\n\",c); void (*ptr)(char*); ptr = print; // ä¸ç”¨&amp;çš„æƒ…å†µ ptr(\"mixbp\"); // ä¸ç”¨è§£å¼•ç”¨çš„æƒ…å†µ } ç”±äºå•çº¯çš„å‡½æ•°åä»£è¡¨å‡½æ•°å…¥å£ç‚¹ï¼Œæ•…ä¸ç”¨&amp;ä¸è§£å¼•ç”¨ä¹Ÿå¯ä»¥ æ³¨æ„ï¼šä¸ºäº†æŒ‡å‘ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°æŒ‡é’ˆçš„ç±»å‹å¿…é¡»æ˜¯æ­£ç¡®çš„ å›è°ƒå‡½æ•° å°†å‡½æ•°æŒ‡é’ˆä½œä¸ºå‡½æ•°å‚æ•°ä¼ å…¥ï¼Œå¹¶åœ¨å‡½æ•°å†…éƒ¨é€šè¿‡è¯¥å‡½æ•°æŒ‡é’ˆè°ƒç”¨å‡½æ•°ï¼Œè¢«è°ƒç”¨çš„å‡½æ•°å³ä¸ºå›è°ƒå‡½æ•° 123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(){ printf(\"hello\"); } void b(void (*ptr)()){ ptr(); // ç”¨ptrå›è°ƒä¼ è¿›æ¥çš„å‡½æ•° } int main(){ void (*p)() = print; // å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘print b(p); // ä¼ å…¥è¯¥å‡½æ•°æŒ‡é’ˆ b(print); // è¿™æ ·ä¹Ÿå¯ä»¥ä¼  } ä»£ç ä¸­ï¼Œå‡½æ•°bå¯ä»¥é€šè¿‡å‡½æ•°æŒ‡é’ˆæ¥å›è°ƒå‡½æ•°print å¯ä»¥å®šä¹‰ä¸€ä¸ªæŒ‡å‘printå‡½æ•°çš„æŒ‡é’ˆä¼ å…¥ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä¼ å…¥printï¼Œæ­¤æ—¶æŒ‡ä»£çš„æ˜¯printå‡½æ•°çš„é¦–åœ°å€ åº”ç”¨ï¼šæ’åº è®¾è®¡ä¸€ä¸ªæ’åºå‡½æ•°ï¼Œå¹¶å¯ä»¥æŒ‰ç…§ä¸åŒé€»è¾‘è¿›è¡Œæ’åº æˆ‘ä»¬å¯ä»¥åœ¨æ™®é€šæ’åºå‡½æ•°ä¸­æ·»åŠ ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆå‚æ•°(æ¯”è¾ƒå‡½æ•°)ï¼Œé€šè¿‡è®¾è®¡èš‚èšæ¯”è¾ƒé€»è¾‘å¹¶ä¼ å…¥æ’åºå‡½æ•°ï¼Œå¯ä»¥çµæ´»å®ç°ä¸åŒæƒ…æ™¯çš„æ¯”è¾ƒï¼Œè€Œä¸ç”¨æ¯æ¬¡éƒ½æ ¹æ®ä¸åŒé€»è¾‘é‡æ–°å†™ä¸€éæ’åºå‡½æ•° å¦‚å®ç°æ­£åºã€é€†åºã€æŒ‰ç»å¯¹å€¼æ’åº 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;math.h&gt; int compare(int a,int b){ if (a&gt;b) return 1; else return -1; } int r_compare(int a, int b){ if (a&gt;b) return -1; else return 1; } int abs_compare(int a, int b){ if (abs(a)&gt;abs(b)) return 1; else return -1; } void sort(int *a, int n, int (*cmp)(int,int)){ int tep; for (int i = 0;i&lt;n;i++){ for (int j = 0;j&lt;n-1;j++){ if (cmp(a[j],a[j+1])&gt;0){ tep = a[j]; a[j] = a[j+1]; a[j+1]=tep; } } } } int main(){ int a[]={3,2,1,5,6,4}; int b[]={-2,-3,5,4,1,-6}; sort(a,6,compare); // æ­£åºæ’åº for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(a,6,r_compare); // é€†åºæ’åº for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(b,6,abs_compare); // ç»å¯¹å€¼æ’åº for (int i = 0;i&lt;6;i++) printf(\"%d \",b[i]); printf(\"\\n\"); } åŒæ ·çš„é€»è¾‘ï¼Œåœ¨cçš„stdlib.håº“ä¸­æœ‰ä¸€ä¸ªqsortå‡½æ•°ï¼Œåªè¦ç»™äºˆå®ƒæ’åºé€»è¾‘å¹¶ä¼ å…¥å°±å¯ä»¥å¯¹ä»»æ„æ•°ç»„æ’åº","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"åº•å±‚é€»è¾‘","slug":"åº•å±‚é€»è¾‘","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"ã€ç®—æ³•ã€‘å¿«é€Ÿå¹‚","slug":"å¿«é€Ÿå¹‚","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-17T07:01:52.295Z","comments":true,"path":"2024/12/20/å¿«é€Ÿå¹‚/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"å¿«é€Ÿå¹‚ é—®é¢˜å¼•å…¥ å¦‚ä½•è®¡ç®— æœ´ç´ ç®—æ³•ï¼šè®©nä¸ªaç›¸ä¹˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼Œå½“nç‰¹åˆ«å¤§çš„æ—¶å€™ï¼Œè€—æ—¶ç‰¹åˆ«é•¿ è€Œå¿«é€Ÿå¹‚ç®—æ³•å¯ä»¥å¤§å¤§å‡å°‘æ—¶é—´å¤æ‚åº¦ nçš„åˆ†ç±» nä¸º2çš„å¹‚æ¬¡æ—¶ å¦‚ æˆ‘ä»¬å¯ä»¥ç”¨ä¸Šä¸€æ¬¡çš„ç»“æœå½“ä½œä¸‹ä¸€æ¬¡çš„ä¹˜æ•°ï¼š å¿«é€Ÿå¹‚åŸç† è¿™æ ·åªéœ€è¦è¿›è¡Œå…­æ¬¡ä¹˜æ³•å°±å¯ä»¥å¾—å‡ºç»“æœï¼Œæ—¶é—´å¤æ‚åº¦ä¸º å³ä½¿ç”¨äº†å€å¢åŸç†ï¼Œå°†æ¯æ¬¡açš„æ•°é‡ç¿»å€ nä¸ä¸º2çš„å¹‚æ¬¡æ—¶ æˆ‘ä»¬å¯ä»¥å°†ä¸æ˜¯2çš„å¹‚çš„æ•°å†™æˆè‹¥å¹²ä¸ª2çš„å¹‚çš„æ•°çš„å’Œï¼Œå¦‚ å¯ä»¥æ”¹å†™ä¸ºï¼Œå†æ ¹æ®ä»¥ä¸Šæ–¹æ³•è®¡ç®— å¦‚ä½•å°†nåˆ†è§£ä¸º2çš„å¹‚æ¬¡ä¹‹å’Œï¼Ÿ ç­”æ¡ˆæ˜¯ä½è¿ç®— è®©æˆ‘ä»¬çœ‹çœ‹è¿™å‡ ä¸ªæ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºå½¢å¼ äºŒè¿›åˆ¶è¡¨ç¤ºåˆ†è§£nçš„åŸç† ä¼šå‘ç°ï¼Œç›®æ ‡æ•°nçš„äºŒè¿›åˆ¶ä¸­çš„1çš„ä¸ªæ•°ä¸ä½ç½®æ­£å¥½å¯¹åº”å®ƒåˆ†è§£åçš„æ•°å­— ä¼ªä»£ç  12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r é€»è¾‘ è¡Œ3ï¼Œ7ï¼šæ¯æ¬¡é™¤äºŒï¼Œè®©äºŒè¿›åˆ¶ä½ä»å³åˆ°å·¦å‡å°‘ä¸€ä½ï¼Œç›¸å½“äºå³ç§»ä¸€ä½ è¡Œ6ï¼šæ¯æ¬¡è®©ç¿»å€ï¼ˆ,,,,â€¦ï¼‰ è¡Œ2ï¼Œ4ï¼Œ5ï¼Œ8ï¼šå¦‚æœmod2==1ï¼Œä»£è¡¨è¯¥ä½æ˜¯1ï¼Œåˆ™å°†è¯¥ä½ä»£è¡¨çš„ä¸ç»“æœç›¸ä¹˜ï¼Œå³è®©å¹‚æ¬¡ç›¸åŠ  ä½è¿ç®—æ”¹è¿› n mod 2==1ç­‰åŒäºn&amp;1ï¼Œn/2ç­‰åŒäºn&gt;&gt;1 æ—¶é—´å¤æ‚åº¦ ï¼Œå¾ªç¯æ¬¡æ•°ä¸ºnçš„äºŒè¿›åˆ¶ä½æ•°ï¼Œå¯¹äºæ•´æ•°nï¼Œå®ƒçš„äºŒè¿›åˆ¶ä½æ•°ä¸º æ¿å­ 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } åº”ç”¨1ï¼šå¹‚å–æ¨¡ 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } æ³¨ï¼š åº”ç”¨2ï¼šæ–æ³¢é‚£å¥‘æ•°åˆ— 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } ç”¨çŸ©é˜µå½¢å¼è¡¨ç¤ºæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œå¦‚ä¸‹å›¾ æ–æ³¢é‚£å¥‘çŸ©é˜µè¡¨ç¤º æˆ‘ä»¬å¯ä»¥å‘ç°å®ƒå¯ä»¥åˆ†ä¸ºnä¸ªçŸ©é˜µç›¸ä¹˜ å†ä¹˜åˆ—å‘é‡F1 F0","categories":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"ã€æ•°å­¦ã€‘é€†å…ƒ","slug":"é€†å…ƒ","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/é€†å…ƒ/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"é€†å…ƒ å‰ç½®çŸ¥è¯† å•ä½å…ƒ åœ¨ä¸€ä¸ªé›†åˆä¸­ï¼Œå¯¹äºæŸç§è¿ç®—ï¼Œå¦‚æœå¯¹äºä»»ä½•çš„é›†åˆå…ƒç´  aï¼Œå’Œå…ƒç´  e è¿ç®—ï¼Œå¾—åˆ°è¿˜æ˜¯é›†åˆå…ƒç´  a æœ¬èº«ï¼Œåˆ™ç§° e ä¸ºè¿™ä¸ªè¿ç®—ä¸‹çš„å•ä½å…ƒã€‚ åœ¨åŠ æ³•è¿ç®—ä¸­ï¼Œå¯¹äºä»»æ„å®æ•°ï¼Œæœ‰ï¼Œåˆ™å•ä½å…ƒ (å¯ä»¥è®¤ä½œç›¸åæ•°) åœ¨ä¹˜æ³•è¿ç®—ä¸­ï¼Œå¯¹äºä»»æ„å®æ•°ï¼Œæœ‰ï¼Œåˆ™å•ä½å…ƒ (å¯ä»¥è®¤ä½œå€’æ•°) æ¨¡ä¹˜çš„å•ä½å…ƒæ˜¯ (è¯æ˜è‡ªå·±æœ) é€†å…ƒ åœ¨ä¸€ä¸ªé›†åˆä¸­ï¼Œå¯¹äºæŸç§è¿ç®— ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªå…ƒç´ çš„è¿ç®—ç»“æœç­‰äºå•ä½å…ƒï¼Œåˆ™ç§°è¿™ä¸¤ä¸ªå…ƒç´ äº’ä¸ºé€†å…ƒã€‚ æ¨¡æ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒ è‹¥ ä¸”(aä¸päº’è´¨)ï¼Œåˆ™ç§°aå…³äºæ¨¡pçš„ä¹˜æ³•é€†å…ƒä¸ºx é€†å…ƒå³æ•°è®ºä¸­çš„å¹¿ä¹‰å€’æ•°ã€‚ è´¹é©¬å°å®šç† è‹¥pä¸ºè´¨æ•°ï¼Œåˆ™ï¼Œåˆ™ æˆ–å¯¹äºä»»æ„æ•´æ•°aï¼Œæœ‰ æ¬§æ‹‰å‡½æ•° ï¼Œè¡¨ç¤ºå°äºç­‰äºnçš„æ­£æ•´æ•°ä¸­å’Œnäº’è´¨çš„æ•°çš„ä¸ªæ•°ï¼Œå¦‚ å½“næ˜¯è´¨æ•°æ—¶ï¼Œæœ‰ æ¬§æ‹‰å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°ï¼Œå³å¯¹ä»»æ„æ»¡è¶³çš„æ•´æ•°a,bï¼Œæœ‰ ç‰¹åˆ«åœ°ï¼Œå½“næ˜¯å¥‡æ•°æ—¶ æ±‚ä¸€ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°å€¼ï¼šåœ¨è´¨å› æ•°åˆ†è§£çš„åŒæ—¶æ±‚è§£å³å¯ 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } æ¬§æ‹‰å®šç† è‹¥ï¼Œåˆ™ åˆ™å¯¹äºè´¹é©¬å°å®šç†ï¼Œæœ‰æ›´ä¸€èˆ¬çš„ç»“è®ºï¼š åº”ç”¨ æ±‚é™¤æ³•çš„æ¨¡è¿ç®—æ—¶ï¼Œç»å¸¸ä¼šå› ä¸ºç²¾åº¦æˆ–æº¢å‡ºé—®é¢˜è€Œå¯¼è‡´ç»“æœäº§ç”Ÿè¯¯å·®ã€‚ æ•…æˆ‘ä»¬å¯ä»¥å°†æ±‚è½¬åŒ–ä¸ºçš„é€†å…ƒ å°†é™¤æ³•è½¬ä¸ºä¹˜æ³•ï¼Œç²¾åº¦é—®é¢˜ä¾¿å°±è§£å†³äº† æ‰©å±•æ¬§å‡ é‡Œå¾—å®šç†æ±‚é€†å…ƒ ç»™å®šæ­£æ•´æ•°aï¼Œbï¼Œæ±‚æ»¡è¶³çš„xçš„æœ€å°æ­£æ•´æ•°è§£ï¼Œè‹¥æ— è§£è¿”å›-1 ç»“è®º å½“aä¸bä¸äº’è´¨æ—¶ï¼Œé€†å…ƒå¿…å®šä¸å­˜åœ¨ å½“aä¸bäº’è´¨æ—¶ï¼Œæœ‰ å¯¹åº”ç³»æ•°å¯å¾—ï¼š è‹¥æ”¹ä¸ºæ±‚æ»¡è¶³ çš„æœ€å°æ­£æ•´æ•°è§£ï¼Œç»è¿‡å˜å½¢ åŸå¼å¯ä»¥ç”±å˜ä¸ºï¼Œåˆ™å’Œä¸Šæ–¹ä¸€è‡´ æ¨¡æ¿ 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } è´¹é©¬å°å®šç† ç»™å®šç´ æ•°på’Œæ­£æ•´æ•°aï¼Œæ±‚æ»¡è¶³çš„æœ€å°æ­£æ•´æ•°xï¼Œè‹¥ä¸å­˜åœ¨è¿”å›-1 æ­¤æ—¶æ¨¡æ•°å›ºå®šä¸ºç´ æ•°ï¼Œæ•…ç›´æ¥å¯ä»¥ç”¨è´¹é©¬å°å®šç†æ±‚è§£ å½“aä¸ºpçš„å€æ•°æ—¶ï¼Œï¼Œæ‰€ä»¥ä¸€å®šä¸å­˜åœ¨ï¼Œè¿”å›-1 æ ¹æ®è´¹é©¬å°å®šç†æœ‰ï¼Œåˆ åˆ™ï¼Œé€†å…ƒxæ»¡è¶³ ä»£ç  12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } çº¿æ€§æ±‚é€†å…ƒ å¯¹äºæ±‚ä¸€è¿ä¸²æ•°å­—æ¨¡pçš„é€†å…ƒï¼Œä¸Šä¸¤ç§æ–¹æ³•å®¹æ˜“è¶…æ—¶ï¼Œç”¨è¿™ç§æ–¹æ³•æ›´å¿«ä¸€äº› ç»“è®º (è¯æ˜è§oi-wiki) æœ‰é€’æ¨å¼ ä»£ç  123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } çº¿æ€§æ±‚ä»»æ„é€†å…ƒ é¦–å…ˆæˆ‘ä»¬æ±‚å‡ºnä¸ªæ•°çš„å‰ç¼€ç§¯ï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥ç”¨exgcdæˆ–è´¹é©¬å°å®šç†æ±‚å‡ºçš„ä¹˜æ³•é€†å…ƒ åˆå› ä¸ºï¼Œï¼Œæ•…æˆ‘ä»¬å¯ä»¥å°†ï¼Œå°±ä¼šå’Œå…¶é€†å…ƒæŠµæ¶ˆï¼Œä»¥æ±‚å‡º æ±‚å‡ºæ‰€æœ‰å‰ç¼€ç§¯çš„é€†å…ƒåï¼Œæˆ‘ä»¬å¯ä»¥è®©å‰ç¼€ç§¯çš„é€†å…ƒä¹˜i-1çš„å‰ç¼€ç§¯æ¥æ¶ˆé™¤å…¶ä»–é€†å…ƒï¼Œä»¥å¾—åˆ°çš„é€†å…ƒï¼Œå³ 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // ä¹Ÿå¯ä»¥ç”¨exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"ã€æ•°æ®ç»“æ„ã€‘å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-25T07:36:57.832Z","comments":true,"path":"2024/12/13/å¹¶æŸ¥é›†(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"å¹¶æŸ¥é›†(Disjoint Set) æ¦‚å¿µ ä¸ç›¸äº¤é›†åˆï¼šè‹¥æœ‰nä¸ªå…ƒç´ ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ å¦‚æœåªå±äºæŸä¸ªé›†åˆï¼Œåˆ™å¯ä»¥æŠŠä»–ä»¬åˆ’ä¸ºä¸æƒ³äº¤é›†åˆ é—®é¢˜æè¿°ï¼šå°†ç¼–å·åˆ†åˆ«ä¸º1-nçš„nä¸ªå¯¹è±¡åˆ’åˆ†ä¸ºä¸ç›¸äº¤é›†åˆï¼Œåœ¨æ¯ä¸ªé›†åˆä¸­ï¼Œé€‰æ‹©å…¶ä¸­æŸä¸ªå…ƒç´ ä»£è¡¨æ‰€åœ¨é›†åˆ è§£å†³çš„é—®é¢˜ï¼š åˆå¹¶ä¸¤ä¸ªé›†åˆ æŸ¥æ‰¾æŸä¸ªå…ƒç´ å±äºå“ªä¸ªé›†åˆ å®šä¹‰ä¸€ä¸ªæ•°ç»„setï¼Œset[i]ä»£è¡¨iæ‰€åœ¨çš„é›†åˆ æˆ‘ä»¬ç”¨æ¯ä¸ªé›†åˆç¼–å·æœ€å°çš„å…ƒç´ æ ‡è®°æ‰€åœ¨é›†åˆ å®ç°1 å¦‚set: 1 2 1 4 2 6 1 6 2 2 ä»–çš„ä¸ç›¸äº¤é›†åˆä¸º{1,3,7}, {4}, {2,5,9,10}, {6,8} æ•ˆç‡ æŸ¥ï¼šåªéœ€è¦è¿”å›ä¸‹æ ‡å¯¹åº”å…ƒç´ ï¼Œå› ä¸ºæ­¤æ—¶å¯¹åº”çš„å°±æ˜¯é›†åˆä¸­çš„æœ€å°å…ƒç´ ï¼Œ 123find1(x){ return set[x]; } å¹¶ï¼šåˆå¹¶ä¸¤ä¸ªé›†åˆåï¼Œè¦æ‰¾å‡ºä¸€ä¸ªæ›´å°çš„ä½œä¸ºä»£è¡¨å…ƒç´ ï¼Œåˆå¹¶æ—¶è¦éå†setä¸­æ‰€æœ‰å…ƒç´ ï¼ŒæŠŠè¿˜æ˜¯åŸæ¥å…ƒç´ çš„æ”¹æˆæ–°çš„æ›´å°å…ƒç´ ï¼Œ 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } å®ç°2 æ¯ä¸ªé›†åˆç”¨ä¸€é¢—æœ‰æ ¹æ ‘è¡¨ç¤º å®šä¹‰ä¸€ä¸ªæ•°ç»„set è‹¥set[i]=i, åˆ™iä¸ºè¯¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œiä»£è¡¨æœ¬é›†åˆ è‹¥set[i]=j, è‹¥ji, åˆ™jæ˜¯içš„çˆ¶èŠ‚ç‚¹ æ•ˆç‡ æŸ¥ï¼šå¦‚æœé›†åˆå¯¹åº”çš„ä¸æ˜¯è‡ªå·±ï¼Œåˆ™è‡ªå·±ä¸Šé¢æœ‰çˆ¶èŠ‚ç‚¹ï¼Œå°†çˆ¶èŠ‚ç‚¹å­˜ä¸‹æ¥ç»§ç»­æŸ¥æ‰¾ç›´åˆ°æŸ¥åˆ°æ ¹èŠ‚ç‚¹ï¼Œæœ€åï¼Œä¸€èˆ¬ 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } å¹¶ï¼šåªéœ€è¦å°†æ ¹èŠ‚ç‚¹æ”¹ä¸ºå¦ä¸€ä¸ªé›†åˆçš„æ ¹èŠ‚ç‚¹å³å¯ï¼Œ 123merge2(a,b){ set[a]=b; } æ”¹è¿› å¦‚ä½•é¿å…æœ€åæƒ…å†µï¼Ÿ æ–¹æ³•ï¼šå°†æ·±åº¦å°çš„æ ‘åˆå¹¶åˆ°æ·±åº¦å¤§çš„æ ‘ï¼Œåˆå¹¶åæ·±åº¦ä¸ä¼šå˜åŒ– æ•ˆæœï¼šåˆå¹¶åï¼ŒåŒ…å«kä¸ªèŠ‚ç‚¹çš„æ ‘æœ€å¤§é«˜åº¦ä¸è¶…è¿‡ ä»£ç ï¼š åœ¨åˆå¹¶æ—¶è®°å½•æ¯æ£µæ ‘çš„é«˜åº¦ï¼Œè°çš„é«˜åº¦å¤§è°æ˜¯æ–°çš„æ ¹èŠ‚ç‚¹ 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } æ­¤æ—¶æŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å˜æˆäº† è·¯å¾„å‹ç¼© é—®é¢˜ï¼šè‹¥ä¸€æ£µæ ‘çš„é«˜åº¦å¾ˆå¤§ï¼ŒæŸ¥æ‰¾è·¯å¾„å¾ˆé•¿ï¼ŒæŸ¥æ‰¾é‡å¾ˆå¤§çš„æ—¶å€™ï¼Œå¾ˆå®¹æ˜“tle æ€æƒ³ï¼šæŸ¥æ‰¾æ—¶å¦‚æœè·¯å¾„è¾ƒé•¿ï¼Œåˆ™ä¿®æ”¹ä¿¡æ¯ï¼Œè®©ä¸‹æ¬¡æŸ¥æ‰¾çš„æ—¶å€™é€Ÿåº¦æ›´å¿« æ–¹æ¡ˆï¼š æ‰¾åˆ°æ ¹èŠ‚ç‚¹ ä¿®æ”¹æŸ¥æ‰¾è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå°†å®ƒä»¬éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ è·¯å¾„å‹ç¼©ç¤ºæ„ ä»£ç  1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //å½“ä¸æ˜¯æ ¹èŠ‚ç‚¹æ—¶ï¼Œè°ƒç”¨find3æ‰¾åˆ°å…¶çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå¹¶èµ‹ç»™ä»–çš„çˆ¶èŠ‚ç‚¹ï¼Œæ­¤æ—¶xçš„çˆ¶èŠ‚ç‚¹æ”¹ä¸ºä»–çš„çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°æŒ‡åˆ°ä»–çš„æ ¹èŠ‚ç‚¹ return set[x]; } æ¨¡æ¿ é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œä½ éœ€è¦å®Œæˆåˆå¹¶å’ŒæŸ¥è¯¢æ“ä½œã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° ,è¡¨ç¤ºå…±æœ‰ ä¸ªå…ƒç´ å’Œ ä¸ªæ“ä½œã€‚ æ¥ä¸‹æ¥ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° ã€‚ å½“ æ—¶ï¼Œå°† ä¸ æ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚ å½“ æ—¶ï¼Œè¾“å‡º ä¸ æ˜¯å¦åœ¨åŒä¸€é›†åˆå†…ï¼Œæ˜¯çš„è¾“å‡º Y ï¼›å¦åˆ™è¾“å‡º N ã€‚ è¾“å‡ºæ ¼å¼ å¯¹äºæ¯ä¸€ä¸ª çš„æ“ä½œï¼Œéƒ½æœ‰ä¸€è¡Œè¾“å‡ºï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œä¸º Y æˆ–è€… N ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 æ ·ä¾‹è¾“å‡º #1 1234N Y N Y æç¤º å¯¹äº çš„æ•°æ®ï¼Œï¼Œã€‚ å¯¹äº çš„æ•°æ®ï¼Œï¼Œã€‚ å¯¹äº çš„æ•°æ®ï¼Œï¼Œï¼Œï¼Œã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // å¹¶æŸ¥é›† // æŸ¥æ‰¾æ“ä½œï¼Œä½¿ç”¨è·¯å¾„å‹ç¼© int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // åˆå¹¶æ“ä½œï¼Œå¯»æ‰¾ä¸¤è€…æœ€å°æ ¹èŠ‚ç‚¹å¹¶å°†å¤§çš„ä¿®æ”¹æˆå°çš„ void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // åˆå§‹åŒ–æ¯ä¸€ä½çš„æ ¹èŠ‚ç‚¹æ˜¯ä»–è‡ªå·± for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // è¿›è¡Œåˆå¹¶ if (z==1){ merge(x,y); } else { // å¦‚æœä¸¤è€…çš„æ ¹èŠ‚ç‚¹ç›¸åŒï¼Œåˆ™å±äºåŒä¸€é›†åˆ if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"æ¢¦å¼€å§‹çš„åœ°æ–¹","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-17T07:00:58.279Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å¸–å­ ä¸‰çº§æ ‡é¢˜ å››çº§æ ‡é¢˜ äº”çº§æ ‡é¢˜ æµ‹è¯•ä»£ç  123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } å°†æ¥å¯ä»¥åœ¨é‡Œé¢å‘ä¸€äº›å­¦ä¹ ç¬”è®° é¢˜è§£ æ¨¡æ¿ä¹‹ç±»çš„ æ¯•ç«Ÿè·Œè·Œæ’æ’æœ€åè¿˜æ˜¯å¼€å§‹äº†ACMä¹‹è·¯ï¼ˆ ### ã˜ã‚„â€¦â€¦ä¸€ç”Ÿ ACMã—ã¦ãã‚Œã‚‹?","categories":[{"name":"æ‚é¡¹","slug":"æ‚é¡¹","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"è®¡ç®—æœºç½‘ç»œ","slug":"è®¡ç®—æœºç½‘ç»œ","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"},{"name":"æ•°è®º","slug":"æ•°è®º","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"æ‚é¡¹","slug":"æ‚é¡¹","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"è¡¨","slug":"è¡¨","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"},{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"è®¡ç®—æœºç½‘ç»œ","slug":"è®¡ç®—æœºç½‘ç»œ","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"},{"name":"åŸºç¡€ç®—æ³•","slug":"åŸºç¡€ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"ç‰›å®¢é¢˜è§£","slug":"ç‰›å®¢é¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"},{"name":"CFé¢˜è§£","slug":"CFé¢˜è§£","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"åº•å±‚é€»è¾‘","slug":"åº•å±‚é€»è¾‘","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}