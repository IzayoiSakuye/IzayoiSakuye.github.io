{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【数据结构】字典树","slug":"字典树","date":"2025-02-01T09:02:16.436Z","updated":"2025-02-02T02:44:29.472Z","comments":true,"path":"2025/02/01/字典树/","permalink":"https://izayoisakuye.github.io/2025/02/01/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"字典树(trie) 给予n个单词，在这n个单词中查询给定的单词是否存在 遍历 使用string遍历每一个单词比较，s1==s2，时间复杂度为，m为单词长度 若询问q次，则复杂度高达 字典树 字典树是一种树形结构，树的每个节点上存储了一个字符 标红的节点表示存在一个以该节点字符结尾的字符串 可以发现，以某个字符结尾的字符串在trie树上是唯一的，因为该节点只有一个父节点，沿着往上即可获得唯一的字符串。 还可以发现，若按照前序遍历，每个节点的字符是按字典序排列的，故trie树还可以用于排序 建树 建立一个根节点，将字符串每一个字符依次从根节点插入，若存在对应字符节点便沿用，否则在上个父节点基础上新建节点，传入结尾位置时标记（是否结尾或第几个相同单词） 时间复杂度 询问 将读入的字符串从根节点开始一个个字符比对，若某个字符在同层节点中都没有则不存在该字符串，若到达该字符串末尾，但此时节点并未标记结尾位置，也判断为不存在该字符串。否则判断为存在 时间复杂度：，x为每次询问字符串长度，共q次询问 删除 判断是否有子节点 若没有子节点，标记不为一时-1，为1时递归删除到根节点 存储 用数组表示层数，每层再用数组表示26个字符在该层出现的次数 缺点：若字符少可行，若字符数过多，或每层分配的节点过多，占用空间会过大 时间换空间：使用map或unordered_map，但时间复杂度会变高 板子 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; // 开辟空间 struct trieNode{ char val; trieNode** son; int cnt; trieNode(char c){ val = c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; // 插入操作 void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c])p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; } p-&gt;cnt++; } // 查询操作 int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main(){ root = new trieNode(' '); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 int trie[M][N]; int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } map实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 vector&lt;map&lt;char,int&gt;&gt; trie; // 或使用unordered_map int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ trie = vector&lt;map&lt;char,int&gt;&gt;(M); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 应用-查询前缀 题目描述 给定 个模式串 和 次询问，每次询问给定一个文本串 ，请回答 中有多少个字符串 满足 是 的前缀。 一个字符串 是 的前缀当且仅当从 的末尾删去若干个（可以为 0 个）连续的字符后与 相同。 输入的字符串大小敏感。例如，字符串 Fusu 和字符串 fusu 不同。 输入格式 本题单测试点内有多组测试数据。 输入的第一行是一个整数，表示数据组数 。 对于每组数据，格式如下： 第一行是两个整数，分别表示模式串的个数 和询问的个数 。 接下来 行，每行一个字符串，表示一个模式串。 接下来 行，每行一个字符串，表示一次询问。 输出格式 按照输入的顺序依次输出各测试数据的答案。 对于每次询问，输出一行一个整数表示答案。 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 3e6 + 10; const int M = 70; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int trie[N][M]; int cnt[N]; int idx = 0; // char到int的转换 int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!trie[p][c]) trie[p][c]=++idx; p=trie[p][c]; cnt[p]++; // 这里与查询整个单词不同，需要每层计数 } } // 询问操作 int query(string s){ int p = 0; //int sum = 0; for (int i = 0;i&lt;s.size();i++){ int c =ascii(s[i]); if (!trie[p][c]) return 0; p=trie[p][c]; // sum+=cnt[p]; } return cnt[p]; } int main() { ios cin &gt;&gt; t; while(t--){ int n , q; cin &gt;&gt; n &gt;&gt; q; // 每次清空使用过的部分 for (int i = 0;i&lt;=idx;i++){ for (int j = 0;j&lt;=M;j++){ trie[i][j]=0; } } for(int i = 0;i&lt;=idx;i++){ cnt[i]=0; } idx = 0; for (int i = 0; i&lt;n;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;q;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s) &lt;&lt; endl; } } return 0; } 缺点是每次查询后数组重置时容易TLE，解决方法为只清空使用的部分 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 63; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; struct trieNode{ char val; int cnt; trieNode** son; trieNode(char c){ val =c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; p-&gt;cnt++; } } int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main() { ios cin &gt;&gt; t; while(t--){ int n,q; cin &gt;&gt; n &gt;&gt; q; root = new trieNode(' '); while(n--){ string s; cin &gt;&gt; s; insert(s); } while(q--){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } } return 0; } 缺点是滥用指针容易MLE，解决方法为N开小一点（差点炸的程度）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【Python】CS61A——Lab2","slug":"CS61A——Lab2","date":"2025-01-30T13:44:27.000Z","updated":"2025-01-30T14:56:07.204Z","comments":true,"path":"2025/01/30/CS61A——Lab2/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Lab2/","excerpt":"","text":"WWPD部分省略 Composite Identity Function 题意：写一个函数，传入f与g两个函数，返回一个含有参数x的函数，用于判断是否等于 123456789101112131415def composite_identity(f, g): \"\"\" Return a function with one parameter x that returns True if f(g(x)) is equal to g(f(x)). You can assume the result of g(x) is a valid input for f and vice versa. &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 # squares x [returns x^2] &gt;&gt;&gt; b1 = composite_identity(square, add_one) &gt;&gt;&gt; b1(0) # (0 + 1) ** 2 == 0 ** 2 + 1 True &gt;&gt;&gt; b1(4) # (4 + 1) ** 2 != 4 ** 2 + 1 False \"\"\" return lambda x: f(g(x))==g(f(x)) 按照题意返回一个lambda函数，传入x即可 Count Cond predicate function: 返回True或False的函数 题意：写一个函数，传入一个两个参数的predicate function condition，返回一个含有参数n的函数，判断1-n中有几个数满足condition函数 1234567891011121314151617181920212223242526272829303132def count_cond(condition): \"\"\"Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5) &gt;&gt;&gt; count_fives(10) # 50 (10 * 5) 1 &gt;&gt;&gt; count_fives(50) # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46) 4 &gt;&gt;&gt; is_i_prime = lambda n, i: is_prime(i) # need to pass 2-argument function into count_cond &gt;&gt;&gt; count_primes = count_cond(is_i_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 \"\"\" def judge(n): cnt = 0 for i in range(1,n+1): if condition(n,i): cnt+=1 return cnt return judge 遍历1-n，传入condition函数并计数即可 注意返回的是函数，传入n Multiple 题意：写一个函数求参数a，b的最小公倍数 12345678910111213def multiple(a, b): \"\"\"Return the smallest number n that is a multiple of both a and b. &gt;&gt;&gt; multiple(3, 4) 12 &gt;&gt;&gt; multiple(14, 21) 42 \"\"\" def gcd(a,b): if b==0: return a return gcd(b,a%b) return a*b//gcd(a,b) 辗转相除法求gcd，用gcd求lcm I Heard You Liked Functions… 题意：定义一个函数传入三个函数f1,f2,f3，返回一个参数为n的函数g，函数g返回一个参数为x的函数h 函数x将会循环传给函数f1，f2，f3，具体如下： n=0时返回x，n=1时返回f1(x)，n=2时返回f2(f1(x))，n=3时返回f3(f2(f1(x)))，n=4时返回f1(f3(f2(f1(x))))，以此类推 12345678910111213141516171819202122232425262728293031323334353637383940414243def cycle(f1, f2, f3): \"\"\"Returns a function that is itself a higher-order function. &gt;&gt;&gt; def add1(x): ... return x + 1 &gt;&gt;&gt; def times2(x): ... return x * 2 &gt;&gt;&gt; def add3(x): ... return x + 3 &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3) &gt;&gt;&gt; identity = my_cycle(0) &gt;&gt;&gt; identity(5) 5 &gt;&gt;&gt; add_one_then_double = my_cycle(2) &gt;&gt;&gt; add_one_then_double(1) 4 &gt;&gt;&gt; do_all_functions = my_cycle(3) &gt;&gt;&gt; do_all_functions(2) 9 &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4) &gt;&gt;&gt; do_more_than_a_cycle(2) 10 &gt;&gt;&gt; do_two_cycles = my_cycle(6) &gt;&gt;&gt; do_two_cycles(1) 19 \"\"\" def g(n): def h(f,g): return lambda x: f(g(x)) if n==0: return lambda x : x elif n==1: return f1 else: temp = f1 i=2 while i&lt;=n: if i%3==1: temp= h(f1,temp) elif i%3==2: temp= h(f2,temp) else: temp= h(f3,temp) i+=1 return temp return g 遍历1-n，每次取模3来判断该套哪个函数，注意0和1时特判，2开始从f1往外套 即执行顺序为","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Environments","slug":"CS61A——Environments","date":"2025-01-30T08:23:18.274Z","updated":"2025-01-30T13:43:44.143Z","comments":true,"path":"2025/01/30/CS61A——Environments/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Environments/","excerpt":"","text":"Environments Environments in Higher-orde function Local Names e.g. 123456def f(x,y): return g(x) def g(a): return a+y result = f(1,2) 该代码会报错NameError: global name 'y' is not defined 原因很明显：当执行到行4时，系统在g的作用域中找不到y，接着去全局作用域中也找不到y，因而报错 而对于嵌套函数，函数中定义的函数是可以直接使用嵌套外函数的参数的，因为在同一个作用于下 Function Composition e.g. 123456789101112def make_adder(n): def adder(k): return k+n return adder def square(x): return x*x def triple(x): return 3*x def compose1(f,g): def h(x): return f(g(x)) return h compose1函数将两个函数结合起来计算 compose1(triple,square)(5)的结果为225 compose1(square,triple)(5)的结果为75 compose1(square, makek_adder(2))(3)的结果为25 该函数实际上开辟了两个environments用来分别计算两个函数的return值 如图中蓝色和绿色的两个environments，每个中都包含了三个作用域，分别用来计算square与make_adder(2)的值，其中make_adder还会先进入adder函数的作用域 Self-Reference e.g.1 12345def print_all(x): print(x) return print_all print_all(1)(3)(5) 该函数执行后会输出1 即print_all函数可以在函数体内以return值形式返回自身，因此该函数被调用的次数与第五行后面的括号数一致（即被调用几次） e.g.2 1234567def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) 函数会把括号后面的数依次相加，输出每次相加的和 首先传入x=1，打印1，定义next_sum函数，print_sums函数返回该函数，并传入y=3，next_sum返回print_sums函数，传入值为x+y=4 再次打印4，定义next_sum函数，print_sums函数返回该函数，并传入y=5，next_sum返回print_sums函数，传入值为x+y=9 再次打印9，没有参数传入，结束 因此要注意调用表达式中传入的参数去了哪里： 1传入了print_sums，而3和5传入了print_sums的返回值next_sum函数用于求和 Currying 注意以下两种函数 12345def make_adder(n): return lambda k:n+k def add(x,y): return x+y make_adder函数一次调用一个参数，返回一个函数再调用参数 add函数调用多个参数，返回最终结果 我们可以用以下函数将add函数转换为make_adder函数 123456def curry(f): def g(x): def h(y): return f(x,y) return h return g 这样，当我们把add函数传入curry函数，我们就可以通过一次调用一个参数的方法实现相同效果 add_three = curry(add) add_three(3)(2) &gt;&gt;&gt; 5 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c)","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【数据结构】ST表","slug":"st表","date":"2025-01-28T03:05:06.000Z","updated":"2025-02-01T03:00:01.799Z","comments":true,"path":"2025/01/28/st表/","permalink":"https://izayoisakuye.github.io/2025/01/28/st%E8%A1%A8/","excerpt":"","text":"ST表 给n个数，进行m次询问，每次寻找区间[l,r]中的最大值 DP打表 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; using namespace std; int arr[N]; int ans[N][N]; int n, m; int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; for(int i = 0;i&lt;n;i++){ for(int j = i;j&lt;n;j++){ if (i==j) ans[i][j]=arr[j]; else ans[i][j]=max(ans[i][j-1],arr[j]); } } int l,r; while(m--){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ans[l][r]&lt;&lt;' '; } return 0; } 时间复杂度： 这种打表方式会很紧凑，用到了许多不用的空间 ST表 基于动态规划与倍增思想，是一种更稀疏的表 定义 dp[i][j]为一个从开始，长度为的区间最值 询问 e.g.询问[0,5] 使用max(dp[0][2],dp[4][1])，即询问区间从0开始，长度为，即[0,3]，与区间从4开始，长度为即[4,5]两个区间中的max值 e.g.询问[0,13] 使用max(dp[0][3],dp[8][2]),dp[12][1])即询问区间[0,7],[8,11],[12,13]三个区间中的max值 对于任意区间都可以分解为若干个小区间求max值 因为根据二进制，任意一个整数都可以分解为若干个2的n次幂的和 因此我们可以将任意区间划分为n个长度为不相交的区间并多次求max 若区间发生重叠，我们可以取重叠区间的max 因此询问步骤如下 求出区间长度 计算dp数组中的 计算最值 预处理 将一个区间分成两半，则每一半的长度均为，后半第一个元素下标即为 处理第一个 处理后面的 时间复杂度： 注意：st表是一个静态表，适用于离线处理 板子 1234567891011121314151617181920212223242526#include &lt;bits\\stdc++.h&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; dp; int query(int l,int r){ int j = (int)log2(r-l+1); return max(dp[l][j],dp[r-(1&lt;&lt;j)+1][j]); } int main(){ vector&lt;int&gt; arr = {9,3,1,7,5,6,0,8}; const int N = 8; // 预处理 dp = vector&lt;vector&lt;int&gt;&gt; (N,vector&lt;int&gt;((int)log2(N)+5,0)); // 初始化dp数组 for (int i = 0;i &lt; N;i++) dp[i][0]=arr[i]; for (int j= 1;j&lt;=log2(N);j++){ for (int i = 0; i+(1&lt;&lt;j)-1&lt;N;i++){ dp[i][j]= max(dp[i][j-1], dp[i+(1&lt;&lt;(j-1))][j-1]); } } // 询问 int l, r; while(cin &gt;&gt; l &gt;&gt; r){ cout &lt;&lt; query(l,r) &lt;&lt; endl; } return 0; } 时间复杂度：","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】树状数组","slug":"树状数组","date":"2025-01-25T07:33:06.000Z","updated":"2025-01-26T13:11:13.646Z","comments":true,"path":"2025/01/25/树状数组/","permalink":"https://izayoisakuye.github.io/2025/01/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"树状数组 给出一个长度为n的数组，完成以下两个操作 将第x个数加上k 输出区间内每个数的和 对于这个问题，朴素算法能做到的时间复杂度，易TLE 而使用树状数组可以将时间复杂度降为 优化思维 单个求区间和会超时，我们可以对数组进行处理： 我们可以把数字两两求和，存到另一个数组中，再进行两两求和，一直到剩一个数字 这样即使要求的数很多，我们也可以利用额外的数组计算答案 如计算前15个数的和，我们只需要计算4个数字即可 但我们可以发现，每层中第偶数个数字是没有用的，因为都可以找到更上一层的代替，去掉以后，剩下的数据恰好为n个，可以装到一个数组中，与原始数组一样长 该数组即为树状数组，每个元素都对应着树的每个节点，而每个节点对应的是原数组的某个区间和 求和时只需要找到对应区间，相加即可得到答案 修改某个数据时，也只需要向上找到包含它的区间进行修改即可 lowbit()运算 定义 表示非负整数二进制表示下最低位1及其后面的0构成的数 e.g. 求解方法 如44，二进制为101100 首先将该数取反： 然后加一： 这时发现除了最低位1与后面的0，其余位上与原数均不同 将这两个数按位与： 故lowbit(n)=n&amp;(~n+1)=n&amp;-n 树状数组实现 我们根据序列建造一棵树，每个节点 保存以为根的子树中叶节点值之和 将每个的x转化为二进制，我们发现每一层末尾0的个数相同，且0的个数与其覆盖长度有关，每层的lowbit()值都相同 故节点覆盖长度就是lowbit(x) ，序号为i的序列正好就是长度为lowbit(i)且以i结尾的序列 且节点的父节点为 整棵树的深度为 注意：树状数组下标从1开始 add()操作 对于add(x,k)操作，若要在整棵树上维护这个值，需要一层一层找到父节点，并按照需要来修改这个节点的值 123void add(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t[x]+=k; } 最坏复杂度： ask()操作 向坐上找一个节点，只需要将下标-=lowbit(这个节点的下标) 12345int ask(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t[x]; return ans; } 最坏复杂度： 应用 树状数组是一个动态维护前缀和的工具，一般用来可差分的信息（不可差分信息用线段树） 单点修改，单点查询 12add(x,k); ans=ask(x)-ask(x-1); 单点修改，区间查询 12add(x,k); ans=ask(r)-ask(l-1); 区间修改，单点查询 引入差分数组b，用树状数组维护b的前缀和，即a数组每个元素的增量 区间修改： add(l,d); add(r+1,-d) 单点查询：ans = a[x]+ask(x) 12add(l,d); add(r+1,-d); ans=a[x]+ask(x); 区间修改，区间查询 设树状数组维护b[i]前缀和，维护i*b[i]前缀和 区间修改： 对，add1(l,d), add1(r+1,-d) 对，add2(l,(l-1)*d), add2(r+1,-(r*d)) 区间查询：ans=ask1(r)*r-ask2(r)-ask1(l-1)*(l-1)+ask2(l-1) 12345678910111213141516171819int t1[maxn],t2[maxn]; void add1(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t1[x]+=k; } int ask1(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t1[x]; return ans; } void add2(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t2[x]+=k; } int ask2(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t2[x]; return ans; } add1(l,d); add1(r+1,-d); add2(l,(l-1)*d); add2(r+1,-(r*d)) ans=ask1(r)*r-ask2(r)-ask1(l-1)*(l-1)+ask2(l-1) 二维数组 和一维类似 add与ask操作 1234567891011121314151617void add(int x, int y, int k){ for (;x&lt;=n;x+=x&amp;-x){ for (;y&lt;=m;y+=y&amp;-y){ t[x][y]+=k; } } } int ask(int x, int y){ ans = 0; for (;x;x-=x&amp;-x){ for (;y;y-=y&amp;-y){ ans+=t[x][y]; } } return ans; } 单点修改，区间查询 12add(x,y,k); ask(x2,y2)-ask(x1-1,y2)-ask(x2,y1-1)+ask(x1-1,y1-1) 区间修改，单点查询 12add(x1,y1,k); add(x1,y2+1,-k); add(x2+1,y1,-k); add(x2+1,y2+1,k) ask(x,y); 区间修改，区间查询 有些麻烦，需要开四个数组 1234567891011121314151617181920int ta[N][N],tb[N][N],tc[N][N],td[N][N]; void add(int x, int y, int k){ for (int i = x;i&lt;=n;i+=i&amp;-i){ for (int j = y;j&lt;=m;j+=j&amp;-j){ t1[i][j]+=k; t2[i][j]+=(x-1)*k; t3[i][j]+=(y-1)*k; t4[i][j]+=(x-1)*(y-1)*k; } } } int ask(int x, int y){ int ans = 0; for (int i = x;i;i-=i&amp;-i){ for (int j = y;j;j-=j&amp;-j){ ans+=t1[i][j]*x*y-t2[i][j]*y-t3[i][j]*x+t4[i][j]; } } return ans; } 修改：add(x1,y1,k); add(x1,y2+1,-k); add(x2+1,y1,-k); add(x2+1,y2+1,k); 查询：ask(x2,y2)-ask(x1-1,y2)-ask(x2,y1-1)+ask(x1-1,y1-1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【题解】2025牛客寒假集训-2","slug":"2025牛客寒假集训-2","date":"2025-01-23T16:00:00.000Z","updated":"2025-01-25T05:02:24.367Z","comments":true,"path":"2025/01/24/2025牛客寒假集训-2/","permalink":"https://izayoisakuye.github.io/2025/01/24/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-2/","excerpt":"","text":"F-一起找神秘的数！ ^：看作不带进位的加法 &amp;：看作哪位发生了进位（进位就是1，不进位就是0） |：不进位下就是a+b，进位就是1 故若两位都为1，则&amp;与^结果都为1，若两位都为0，则&amp;与^结果都为0，若一位是0一位是1则&amp;为0^为1 此时与和或计算求和以后就可与原两数之和相等了 又时有，因此两数相等的时候就可以满足等式 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; while(n--){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (l==0 &amp;&amp; r==0) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } cout &lt;&lt; r-l+1 &lt;&lt; endl; } return 0; } G-一起铸最好的剑！ 枚举，看哪次更接近最佳温度 注意时由于怎么乘温度都不增长，故一次即可最近 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n, m; ll cnt = 1; cin &gt;&gt;n &gt;&gt;m; if (m==1||n==1){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } if (n&lt;m){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } ll tep = m; while(tep&lt;n){ tep*=m; cnt++; } if (abs(tep-n)&gt;=abs(tep/m-n)) cout &lt;&lt;cnt-1&lt;&lt;endl ; else cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } J-数据时间？ 大模拟 注意两点： scanf格式化输入很好用，可以忽略中间的间隔符 由于前导零补齐，日期与时间的大小可以用字符串直接比较 由于同一个人在同一时段多次登录视作一次，我们可以把id插入set去重 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n, h, mon; struct node{ string id; int y, m, d; int hour, min, sec; }user[N]; set&lt;string&gt; work,nap,_sleep; // 对同一个人去重 int main() { scanf(\"%d %d %d\",&amp;n,&amp;h,&amp;mon); //printf(\"%d %d %d\",n,h,mon); for (int i =1;i&lt;=n;i++){ cin &gt;&gt; user[i].id; scanf(\"%d-%d-%d %d:%d:%d \",&amp;user[i].y,&amp;user[i].m,&amp;user[i].d,&amp;user[i].hour,&amp;user[i].min,&amp;user[i].sec ); //好用的格式化输入 } for (int i =1;i&lt;=n;i++){ if (user[i].y==h &amp;&amp; user[i].m==mon){ if ((user[i].hour&gt;=7 &amp;&amp; user[i].hour&lt;9)||(user[i].hour==9&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=18 &amp;&amp; user[i].hour&lt;20)||(user[i].hour==20&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=11 &amp;&amp; user[i].hour&lt;13)||(user[i].hour==13&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))nap.insert(user[i].id); else if ((user[i].hour&gt;=22 &amp;&amp; user[i].hour&lt;=23)||(user[i].hour&gt;=0 &amp;&amp; user[i].hour&lt;1)||(user[i].hour==1&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))_sleep.insert(user[i].id); } } printf(\"%d %d %d\",work.size(),nap.size(),_sleep.size()); return 0; } 牛可乐在演奏什么好难猜呢 K-可以分开吗？ 離さないでいて~ 递归找到蓝色地板后bfs或dfs搜索连通块，同时找每个连通块的每个蓝色地板四联通周围的灰色地板 取所有连通块周围灰色地板的最小值 注意TLE或MLE：不要在每次搜连通块时memset vis数组，不然会超时 注意注意：题目输入描述输入的是01字符串，调了一下午最后才发现是这里出了问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 510; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int dx[]={1,0,-1,0}; int dy[]={0,1,0,-1}; int n,m; int re = INF; char floors[N][N]; bool vis[N][N]; void bfs(int x, int y){ queue&lt;PII&gt; q; PII cur, net; cur.first = x,cur.second = y; q.push(cur); bool visl[N][N]={}; // bfs搜索蓝瓷砖周围的灰瓷砖时使用的访问数组 int tot = 0; while(!q.empty()){ cur = q.front(); q.pop(); for (int i = 0;i &lt;4;i++){ net.first = cur.first+dx[i], net.second = cur.second+dy[i]; if (net.first&lt;1 || net.first&gt;n || net.second&lt;1 || net.second &gt;m) continue; // 越界 if (vis[net.first][net.second]) continue; // 访问过 if (floors[net.first][net.second]=='0'){ // 搜到灰瓷砖 if (!visl[net.first][net.second]) tot++; // 未访问，计数 visl[net.first][net.second]=true; // 标记访问 continue; } vis[net.first][net.second]=true; // 标记蓝瓷砖已经访问过 q.push(net); } } re = min(re,tot); } int main() { ios cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { cin&gt;&gt;floors[i][j]; } } // 枚举查找蓝瓷砖连通块 for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { if (floors[i][j]=='1'&amp;&amp;!vis[i][j]) { // 碰到未搜过的连通块就开始搜灰瓷砖 bfs(i,j); } } } cout &lt;&lt; re; return 0; } D-字符串里串 该字符串某一个前缀的最后一个字母在后面能出现第二次即可满足 注意，也可以从后往前看，后缀的第一个字母在前面能出现第二次即可满足 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; string s; int main() { ios cin &gt;&gt; n &gt;&gt; s; s=' '+s; map&lt;char,int&gt; mp1; map&lt;char,int&gt; mp2; int ans1=0,ans2=0; for (int i = 1;i&lt;=n;i++){ mp1[s[i]]++; if (mp1[s[i]]&gt;1){ ans1 = n-i+1; break; } } for (int i = n;i&gt;=1;i--){ mp2[s[i]]++; if (mp2[s[i]]&gt;1){ ans2 = i; break; } } int ans = max(ans1,ans2); ans==1?cout &lt;&lt; 0:cout &lt;&lt; ans; return 0; } H-一起画很大的圆！ 由几何知识可得，当三点连线越发接近直线时，这三点所在的圆半径越大（理论上三点在一条直线上时所在的圆是无限大的） 对于以下一种情况是可以实现的： 即找到一条边上最右侧的一点与次右侧的一点，与另一条边（对侧）上最接近另外两点那条边下面的一点 即 若矩形竖起来，对应的三点为 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ vector&lt;PII&gt; re; int a,b,c,d; cin &gt;&gt;a &gt;&gt;b&gt;&gt;c&gt;&gt;d; if (b-a&gt;d-c){ // 横着的矩形 re.push_back({b,d}); re.push_back({b-1,d}); re.push_back({a,d-1}); } else{ // 竖着的矩形 re.push_back({a,c}); re.push_back({a,c+1}); re.push_back({a+1,d}); } for (auto t:re) cout &lt;&lt; t.first &lt;&lt;' '&lt;&lt;t.second &lt;&lt; endl; } return 0; } C-字符串外串 可以将构造的字符串分为两部分，第一部分为满足可爱度的m个字符，第二部分为剩下的字符 由D可知，若第二部分中出现了重复字符，则可爱度一定会大于m，故不满足条件； 若总长度小于可爱度那一定不可能有满足的字符串 这两种情况可以输出NO 故我们只要保证第一部分的结尾字母与第二部分的结尾字母相同即可 一种可能的构造方法： 先构造第二部分，按字母表顺序填充n-m个字符。 再构造第一部分，让第二部分反复出现即可 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n ,m; cin &gt;&gt; n &gt;&gt; m; if (n&lt;=m || m+26&lt;n) { // 特殊条件 cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } cout &lt;&lt; \"YES\"&lt;&lt;endl; string s; for (int i = 0;i&lt;n;i++){ s.push_back('a'+i%(n-m)); // 循环插入第二部分的字符 } cout &lt;&lt; s &lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【算法】滑动窗口","slug":"滑动窗口","date":"2025-01-23T02:39:01.000Z","updated":"2025-01-23T13:27:35.824Z","comments":true,"path":"2025/01/23/滑动窗口/","permalink":"https://izayoisakuye.github.io/2025/01/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口 定义 在一个数组中框定一段子数组作为窗口 若想让该窗口元素增加，可以考虑让右边界r++，即窗口从右边吸收数字 若想让该窗口元素减少，可以考虑让左边界l++，即窗口从左边弹出数字 一般解决子数组相关问题 例1/模板 给定一个含有个正整数的数组和一个正整数target 找到累加和target的长度最小的子数组并返回长度，如果不存在符合条件的则返回0 我们可以先固定子数组的左端点，让右端点右移，直到数组和大于target，由于数组所有数都为正整数，因此找到第一个累加和大于target后，后面再加一定也大于target 此时循环判断累加和是否target，若成立则剔出左侧数字，记录子数组长度 然后以该子数组为起点，右端点右移，重复上述操作，寻找等于target的子数组，记录数组长度 时间复杂度： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,tar; int a[N]; int main() { ios cin &gt;&gt; n &gt;&gt; tar; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } int ans = 0x3f3f3f3f, sum = 0, l = 0; // 定义记录结果长度，数组元素之和，左端点 for (int r = 1;r&lt;=n;r++){ // 先让右端点右移 sum+=a[r]; // 累加求和 while(sum&gt;=tar){ // 当求和大于等于目标开始移动左端点以寻找更小区间 ans = min(ans,r-l+1); // 更新最小区间 sum-=a[l++]; // 减去滑出窗口的数同时让左端点右移 } } // 找到符合目标的区间 if (ans&lt;=n) cout &lt;&lt; ans; else cout &lt;&lt; 0 ; return 0; } 例2 给定一个字符串，找出不含有重复字符的最长字串长度 即寻找最长无重复字符的窗口 让右边界一直右移，直到遇到重复字符，让左边界移动到max(左边界，重复字符上次位置+1) 因为任何时候窗口情况一定是没有重复数组在内的，若重复字符上次位置比此时左边界小，则若还是移动到重复字符上次位置+1的话，窗口会变长，不保证加长部分会不会又出现重复字符 若右移后无重复字符，可以看作重复字符位置为-1或不存在，用max仍保持原左边界 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s; for (int i = 0;i&lt;s.size();i++) cnt[s[i]]=-1; // 初始化都为第一次出现 int ans = 0; // 记录最长区间 for (int l = 0, r = 0;r&lt;s.size();r++){ l = max(l,cnt[s[r]]+1); // 左边界移动 ans = max(ans,r-l+1); // 记录结果 cnt[s[r]]=r; // 更新上次出现字符位置为当前r位置 } cout &lt;&lt; ans; return 0; } 例3 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 我们可以逆向以一种”debt”思维解决。遍历要查找的字符，发现一个-1，这样需要查找的字符数都为负数，在查找时，每个字符出现后对应加一，则非 要查找字符将始终为正数，而要查找的字符为负数 先让右边界右移，当debt变为0（窗口包含了足够要查找的字串），开始移动左边界，使字串最小，这时debt大于0的都为不需要查找的字符，故可以左移，直到碰到需要查找的不再移动。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s,t; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s &gt;&gt; t; if (s.size()&lt;t.size()){ cout &lt;&lt; \"\"; return 0; } for (int i = 0;i&lt;t.size();i++) cnt[t[i]]--; int len = INF, start = 0; // len用于记录最小字串，start记录字串开头，便于输出 int debt = t.size(); for (int l = 0, r = 0;r&lt;s.size();r++){ if (cnt[s[r]]++&lt;0) debt--; // 字符计数加一后仍是负的，证明是要查找的(debt的)字符，让debt-- if(debt==0){ // 所有字符都查到后 while(cnt[s[l]]&gt;0){ // 寻找最小子区间 cnt[s[l++]]--; // 若是非查找字符，可以让左边界右移拿回 } if (r-l+1&lt;len){ // 记录最小子区间以及开始位置 len = r-l+1; start = l; } } } // 若查不到则输出空字符串，否则截取字符串输出 len == INF ? cout &lt;&lt;\"\" : cout &lt;&lt; s.substr(start,start+len); return 0; } 总结 关键：找到范围和答案指标之间的单调性关系 求解大流程：求子数组在每个位置开头或结尾情况下的答案","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构】优先队列","slug":"优先队列(priority_queue)","date":"2025-01-22T13:35:19.944Z","updated":"2025-01-23T12:54:03.554Z","comments":true,"path":"2025/01/22/优先队列(priority_queue)/","permalink":"https://izayoisakuye.github.io/2025/01/22/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97(priority_queue)/","excerpt":"","text":"优先队列(priority_queue) 优先队列可以用来存储具有优先级的元素，队头的元素都是当前队列中优先级最高(或最低)的元素 STL中的优先队列默认为最大堆，即优先级最高的先出队 结构 优先队列的结构 优先队列仅维护堆顶(top)，其余元素优先级都比堆顶小 初始化 优先队列使用需要引入头文件queue 如下代码可以声明一个优先队列，其中T为数据类型，优先队列中的数据数据类型都相同 注意：使用结构体时，需要重载小于号或声明一个比较类并重载()运算符 123456789101112131415161718192021222324#include &lt;bits\\stdc++.h&gt; using namespace std; struct node{ int x, y; // 使用结构体需要重载小于号 bool operator &lt; (const node &amp;u)const{ return x == u.x? y&lt;u.y : x&lt;u.x; } }; // 或重载()运算符实现比较 struct cmp{ bool operator ()(const int &amp;u, const int &amp;v)const{ return u&gt;v; } }; int main(){ // 声明优先队列，整型，默认大顶堆(最大元素在顶上) // 一般声明一个空优先队列 priority_queue&lt;T&gt; pque; // 声明一个小顶堆,传入仿函数, 第二个参数表示优先队列底层储存容器为vector priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; } 基本操作 1234567891011121314// 取出堆顶 cout &lt;&lt; pque.top() &lt;&lt; endl; // 插入元素到队尾并执行上浮操作 pque.push(1); // 弹出堆顶 pque.pop(); // 返回队列元素个数 cout &lt;&lt; pque.size() &lt;&lt; endl; // 判断队列是否为空 cout &lt;&lt; pque.empty() &lt;&lt; endl; //间接修改堆顶元素 int x = pque.top(); pque.pop(); pque.push(x+1); 注意：priority_queue没有迭代器，不能用begin()，end()，auto等遍历，也不能直接修改队列中的元素","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"}]},{"title":"【题解】2025牛客寒假集训-1","slug":"2025牛客寒假集训-1","date":"2025-01-21T14:15:49.000Z","updated":"2025-01-23T02:30:49.763Z","comments":true,"path":"2025/01/21/2025牛客寒假集训-1/","permalink":"https://izayoisakuye.github.io/2025/01/21/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-1/","excerpt":"","text":"(按官方难度排序) A-茕茕孑立之影 考虑特殊情况：若数组中包含1，则一定是1的倍数，可以直接输出-1 考虑一般情况：质数的因数只有1和他本身，又数组中不含1，因此任意一个比该数组中最大数还大的质数肯定不是数组中的倍数，又因为该数都比数组中的数大，因此也不可能是他的倍数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; bool is_prime(int n){ if (n==1) return 0; if (n==2) return 1; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0) return 0; } return 1; } int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } for (int i = 1;i&lt;=n;i++){ if (a[i]==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; break; } } if (flag) continue; cout &lt;&lt; 1000000007 &lt;&lt; endl; } return 0; } D-双生双宿之决 用map存储出现数字次数后比较即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,cnt=0; map&lt;int,int&gt; a; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; a[tep]++; } if (n&amp;1){ cout &lt;&lt; \"No\" &lt;&lt; endl; continue; } if (a.size()!=2){ // 判断值的个数用size cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } else{ set&lt;int&gt; tep; for (auto &amp;pr:a){ tep.insert(pr.second); } if (tep.size()!=1) { cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } } cout &lt;&lt; \"Yes\"&lt;&lt;endl; } return 0; } B-一气贯通之刃 即判断这些节点能不能连成一条链，若是的话输出头尾，不是的话输出-1 若有两个节点度数为1，其余节点度数都为2则是一条链 故可以用map记录每个节点出现次数并判断 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=(n-1)*2;i++){ int tep; cin &gt;&gt; tep; num[tep]++; } vector&lt;int&gt; p; for (auto &amp;pr:num){ if (pr.second&gt;2){ cout &lt;&lt; -1 &lt;&lt; endl; return 0; } if (pr.second==1)p.push_back(pr.first); } for (auto t:p) cout &lt;&lt; t &lt;&lt;' '; return 0; } G-井然有序之衡 由于同时加一减一对数组总和没有影响，而最后生成的permutation正好为一个的等差数列，故可以实现的条件为数组数值之和等于该等差数列前项和 将数组排序，每一位正好对应permutation从1开始的每一位，计算每位数与对应permutation之差求和即可以得到需要操作多少次加一或减一才能变成对应permutation 注意：一次操作包含一次加一与一次减一，故最后结果要除二 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll n,op; ll a[N]; int main() { ios cin &gt;&gt;n; ll sum=0; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; sum+=a[i]; } if (1ll*n*(n+1)/2!=sum){ cout &lt;&lt; -1; return 0; } sort(a+1,a+1+n); for (int i = 1;i&lt;=n;i++){ op += abs(a[i]-i); } cout &lt;&lt; op/2; return 0; } E-双生双宿之错 中位数定理： 中位数有一个性质：一个数列中所有数与中位数之差的绝对值之和最小，因为中位数是处于中间的数 即若要通过加一减一将一个数组所有数变为相同，最少操作次数即将他们变为中位数 对于这道题，我们要做到的是将数组所有数变为两个数，且出现次数相同，故我们可以按照D题的思路，将数组排序后分为前后两部分，分别求出其中位数后计算两部分各达到各自中位数所需要的操作次数求和 若两侧中位数相同，我们可以选择将前半部分中位数-1或将后半部分中位数+1并计算，取最优 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n,op=0; ll a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); // 排序 ll midl = a[((n/2)+1)/2], midr = a[((n/2)+1)/2+n/2]; // 计算前后两部分中位数 //cout &lt;&lt; midl &lt;&lt; ' ' &lt;&lt; midr &lt;&lt; endl ; if (midl!=midr){ // 正常情况 // 分两部分计算到达中位数所需要的操作次数 for (int i = 1;i&lt;=n/2;i++){ op+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op+=abs(a[i]-midr); } cout &lt;&lt; op &lt;&lt; endl; } else{ // 两侧中位数相等 // 将左侧中位数-1并计算操作次数 ll mid1 = midl-1; ll op1 = 0; for (int i = 1;i&lt;=n/2;i++){ op1+=abs(a[i]-mid1); } for (int i = n/2+1;i&lt;=n;i++){ op1+=abs(a[i]-midr); } // 将右侧中位数+1并计算操作次数 ll mid2 = midr+1; ll op2 = 0; for (int i = 1;i&lt;=n/2;i++){ op2+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op2+=abs(a[i]-mid2); } // 输出更优结果 cout &lt;&lt; min(op1,op2)&lt;&lt;endl; } } return 0; } H-井然有序之窗 对于n个区间选数，区间内数多要尽量放在后面选，因为选择可能性更多 在选第i个数时，我们的重点是右界的大小，不管左边从哪开始都可以看成从i开始，因为其余的已经放完了 e.g. 区间 [1,3] [5,5] [3,5] [2,7] [3,4] [2,4] [4,7] permutation 1 5 4 6 3 2 7 因此我们可以总结如下步骤 按左界排序：决定i能不能放进去（左界相等时右界小的在前） 每次询问i放在哪个区间时，找出对应左界为i的区间，放入右界更小的区间内 因此需要一个容器来存储区间 此时，放入的区间应为当前左界为i的区间与左界为i-1且没被用过的区间，要在这些区间中寻找右界更小的区间 也就是每次往该容器里填入区间，并把容器内所有区间排序，取出右界最小的区间，当前i可以放在该区间内 故我们可以使用priority_queue实现，且为小根堆 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; vector&lt;vector&lt;PII&gt;&gt; a(n+10); // 按左端点分类存入区间右端点与区间位置 for (int i = 1;i&lt;=n;i++){ int l,r; cin &gt;&gt; l &gt;&gt; r; a[l].push_back({r,i}); } int ans[N]; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;&gt;&gt; pq; for (int i = 1;i&lt;=n;i++){ // 询问哪个数就把该数所在的区间左界的区间右界与区间位置添入优先队列 for (auto &amp;pr:a[i]) pq.push(pr); // 判断当前数是否能从区间中取到，若不能就pop换下一个 while(!pq.empty() &amp;&amp; pq.top().first&lt;i) pq.pop(); // 若都不能从当前区间中取到，表明不存在满足的，直接-1 if (pq.empty()) { cout &lt;&lt; -1 ; return 0; } // 记录当前数所在的区间位置 ans[pq.top().second]=i; pq.pop(); } for (int i = 1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【题解】Codeforces Round 998 (Div. 3)","slug":"Codeforces-Round-998-Div-3","date":"2025-01-21T14:15:30.000Z","updated":"2025-01-22T06:08:35.976Z","comments":true,"path":"2025/01/21/Codeforces-Round-998-Div-3/","permalink":"https://izayoisakuye.github.io/2025/01/21/Codeforces-Round-998-Div-3/","excerpt":"","text":"A- Fibonacciness 题意 给予，求满足的 思路 枚举所有可能的取最大值，有以下情况 代码 123456789101112131415161718192021222324252627282930313233// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int a1,a2,a4,a5; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a4 &gt;&gt; a5; int a31 = a1+a2; int a32 = a4-a2; int a33 = a5-a4; if (a31==a32 &amp;&amp; a32 == a33) cout &lt;&lt; 3 &lt;&lt; endl; else if (a31==a32 || a32 == a33 || a31==a33) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; } return 0; } B-Farmer John’s Card Game 题意 个人手里有张牌，每个人每轮出一张牌在牌堆上，需要满足牌上数字大于牌堆顶数字，若某人无法防止满足条件的牌（手里有牌的情况下）游戏便失败 构造一个permutation代表出牌顺序，使得所有人最后都能出完牌 思路 考虑特殊情况：时，它只需要按照数值递增顺序放置卡牌即可胜利，故只需要输出1 一般情况：为了按照递增顺序放置卡牌，每个人需要按照从小到大的数值出牌 又因为一个人一轮只能出一张牌，因此如果一个人手里有两张连续数值的卡牌，他出完更小的一张之后，其他人出的牌肯定会比他更大的一张牌大，这样他手里总会留下那张牌，导致失败 若没有上述情况，只要对每个人手里的牌排序，按照第一张牌的大小从小到大出牌即为正确顺序 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e3 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; //t++; while(t--){ int n, m,tep=0; int a[N]={},ord[N]={},b[N]={}; cin &gt;&gt; n &gt;&gt; m; int flag=0; for(int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ cin &gt;&gt; a[j]; tep++; } sort(a+1,a+1+m); if (n==1 &amp;&amp; flag != 1) { cout &lt;&lt; 1 &lt;&lt; endl; flag = 1; break; } for (int j = 1;j&lt;m;j++){ if (abs(a[j+1]-a[j])==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; for (int i = 1;i&lt;=n*m-tep;i++) { int t; cin &gt;&gt; t; } break; } } if (flag) break; ord[a[1]]=i; } if (flag) continue; for (int i = 0;i&lt;n*m;i++){ if (ord[i]!=0) cout &lt;&lt; ord[i]&lt;&lt;' '; } cout &lt;&lt; endl; } return 0; } C-Game of Mathletes 题意 个数，Alice和Bob轮流每次选择一个数并去除，若两数之和等于则分数加一，求最终分数 思路 对于每组数分数是固定的，因为只要Alice选一个数，Bob就会选择数，因此只要看有几组数满足即可 这里单纯枚举会TLE，可以使用双指针优化 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,k,score=0; int a[N]; cin &gt;&gt; n &gt;&gt; k; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } sort(a+1,a+1+n); // 排序 int l = 1, r = n; // 对撞指针，分别指向头尾 while(l&lt;r){ int sum = a[l]+a[r]; // 计算和 if (sum==k){ // 满足条件 score++; // 分数加一 l++,r--; // 两端指针同时移动，计算下一组数 } else if (sum&lt;k)l++; // 若和比条件小，则让和变大，左指针右移 else r--; // 若和比条件大，则让和变小，右指针左移 } cout &lt;&lt; score &lt;&lt; endl; } return 0; } D-Subtract Min Sort 题意 一个数组，你每次可以让两个相邻的数一起减去他们之中的最小值。问能不能使数组非递减 思路 对于数与，在进行操作后一定会有一个数变为0，若为0，则之后的操作一定会让变为0以保证数组非递减 考虑最右端的与，若为0，则这之前的所有数都为0 因此我们考虑两个元素与，将两者减去最小的那个，其中一个变为0，则该数之前一定都为0，而后面的不变 考虑特殊情况，若想让变为0，那么只能让同时减去而没有其他方法，这导致恒成立 对于一般情况，三个连续的数,与，我们希望先算后面两个数，这样可以让减去更多的值，以确保小于，此时若变为0，连带着也会变为0，若不变为0，则之后一定需要同时减一个让他们保证是非递减的 因此我们可以反过来，先从头对与操作，一步步往后操作。若每一组都操作结束后仍有，则无法实现，否则我们可以通过排序实现非递减数组。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 0;i&lt;n;i++) cin &gt;&gt; a[i]; if (a[0]&gt;a[1]){ // 特判第一个和第二个 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } for (int i = 1;i&lt;n-1;i++){ a[i]-=a[i-1]; // 往前减 if (a[i]&gt;a[i+1]){ // 减后若还是大则不行 cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = 1; break; } } if (!flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"}]},{"title":"【题解】牛客周赛 Round 77","slug":"牛客周赛-Round-77","date":"2025-01-19T13:37:37.000Z","updated":"2025-01-21T14:19:46.159Z","comments":true,"path":"2025/01/19/牛客周赛-Round-77/","permalink":"https://izayoisakuye.github.io/2025/01/19/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-Round-77/","excerpt":"","text":"A-时间表 把时间放到数组中按下标搜索即可 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios int a[]={20250121,20250123,20250126,20250206,20250208,20250211}; cin &gt;&gt; n; cout &lt;&lt; a[n-1]; return 0; } B- 数独数组 形如以下的数组其实都可以： 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 8 9 1 2 3 4 5 6 7 8 9 … 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 … 即每种数字出现次数要不相等，要不相差1，且都必须出现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int a[N]; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=9;i++) num[i]=0; // 初始化map for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; num[tep]++; // 统计数字出现次数 } // 该特判可以不要 for (int i = 1;i&lt;=9;i++) { if (num[i]==0){ cout &lt;&lt; \"NO\"; return 0; } } for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;=9;j++){ if (num[i]!=num[j]) { // 两数不等的情况下 if(abs(num[i]-num[j])!=1){ // 差值只能为1 cout &lt;&lt; \"NO\"; return 0; } } } } cout &lt;&lt; \"YES\"; return 0; } C-小红走网格 将行列分开看，逻辑相同 由于每次移动距离固定，因此问题可以转化为以下条件： 在x方向是否存在整数（向右次数）与（向左次数）使得 在y方向是否存在整数（向右次数）与（向左次数）使得 即同余方程的可解性，可以见逆元部分 故两方程等价于与 由此我们引入裴蜀定理： 设是不全为0的整数，对任意整数，满足，且存在整数使 因此只要满足是的倍数，是的倍数，就有对应的解，即能到达指定位置 123456789101112131415161718192021222324252627282930313233343536373839// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int gcd(int a, int b){ return b?gcd(b,a%b):a; } int main() { ios cin &gt;&gt; t; while(t--){ int x,y,a,b,c,d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (x%gcd(c,d)!=0) { cout &lt;&lt; \"NO\" &lt;&lt; endl; } else if (y%gcd(a,b)!=0){ cout &lt;&lt; \"NO\" &lt;&lt; endl; } else cout &lt;&lt; \"YES\"&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【Python】CS61A——Higher-Order Functions","slug":"CS61A——Higher-order Functions","date":"2025-01-19T01:03:01.170Z","updated":"2025-01-30T09:40:55.863Z","comments":true,"path":"2025/01/19/CS61A——Higher-order Functions/","permalink":"https://izayoisakuye.github.io/2025/01/19/CS61A%E2%80%94%E2%80%94Higher-order%20Functions/","excerpt":"","text":"Higher-Order Functions 函数特征 一个函数的定义域(domain)即为所有可能的输入 一个函数的值域(range)即为所有可能的输出 一个纯函数表现即为建立输入与输出之间的映射 assert语句 格式：assert &lt;bool expression&gt; &lt;output information&gt; 用处：当布尔表达式成立时，语句继续执行；当布尔表达式不成立时，程序跳出并提示指定的报错信息。 函数作为形参 设计一个计算求和、立方项求和的函数，我们可以通过在对求和函数中传入对每一位数的操作对应的函数来简化代码，而非为不同种类求和分别设计函数，如下： 1234567891011121314151617181920212223242526272829from math import pow def identity(k): return k def cube(k): return int(pow(k,3)) def summation(n,term): \"\"\"sum the first N terms of a sequence. &gt;&gt;&gt; summation(5,cube) 225 \"\"\" total,k=0,1 while k&lt;=n: total,k = total + term(k), k+1 return total def sum_naturals(n): \"\"\"sum the first N natural numbers &gt;&gt;&gt; sum_naturals(5) 15 \"\"\" return summation(n,identity) # 传入返回原值函数进行计算 def sum_cubes(n): \"\"\"sum the first N cubes of natural numbers &gt;&gt;&gt; sum_cubes(5) 225 \"\"\" return summation(n,cube) # 传入返回每个值的立方函数进行计算 其中，summation函数中的term参数与传入的函数有关 identity与cube函数作为单个参数传入summation函数，以处理不同情况下的求和 形参term函数在计算total时被回调，回调的是传入的对应函数 函数作为返回值 当一个函数在另一个函数体内定义，该函数的名称绑定在本地作用域中 如下： 123456789def make_adder(n): \"\"\"return a function that takes one argument called k and return k+N &gt;&gt;&gt; add_three = make_adder(3) &gt;&gt;&gt; add_three(4) 7 \"\"\" def adder(k): return k+n # adder函数返回数值k+n return adder # make_adder函数返回adder函数 make_adder函数返回一个函数adder，而函数adder是局部定义的函数，它可以使用make_adder内部的变量（k与n） 对于语句make_adder(1)(2)，实现的效果即为1+2 作用 函数是第一类值(first-class)：函数可以作为参数传递，作为返回值返回 higher-order函数指代以函数作为参数或返回值的函数 它可以表示计算的一般情况 它可以防止程序代码过于重复冗杂 它可以将不同功能分离成多个函数 匿名函数(Lambda Expressions ) 格式：lambda &lt;formal parameter&gt;: &lt;return value&gt; lambda指定义一个匿名函数 lambda后紧跟一个形式参数，冒号后为返回值（无return关键字） 返回值只能是一句表达式 使用时将其赋值给一个变量并按照def函数方式调用或直接按照def函数方式调用 与def不同的一点是：def定义的函数拥有一个内部名称(intrinsic name)，而lambda定义的函数即使赋值给了另一个名字的变量，它的名称仍为lambda 返回语句(Return Statements) 函数中的return语句让程序返回到先前的environment，并给函数一个值 在执行函数体时，遇到return语句函数即结束 看如下例子： 123456789101112131415161718192021def search(f): \"\"\"find a number that one more than the square root of the number put in the positive function &gt;&gt;&gt; search(positive) 11 \"\"\" x=0 while not f(x): # 当positive函数返回为0时进入循环 x+=1 return x def square(x): return x**2 def positive(x): return max(0,square(x)-100) def inverse(f): \"\"\"return g(y) such that g(f(x)) -&gt;x &gt;&gt;&gt; inverse(square)(16) 4 \"\"\" return lambda y: search(lambda x:f(x)==y) # 返回某个完全平方数的平方根 positive函数： ​ 传入search后，寻找的是第一个比positive函数中减数的平方根大的数 ​ 因为若数x的平方比减数小，return值肯定是0，while条件成立，x++继续寻找 inverse函数： inverse用于寻找完全平方数y的平方根 传入square函数用于计算search函数中x的平方，与inverse函数返回的lambda函数中传入的y比较是否相等，若不相等，满足while循环条件，x++继续比较，若相等则找到，跳出循环返回此时x值。 控制语句(Control Statements) 条件语句 执行条件：每一句clause按序执行 判断条件判断语句是否成立（若存在） 若值为true或遇到else的clause，执行语句块并跳过其余clauses 但为何没有一个函数能实现条件判断呢？ 对于调用表达式(call expression)的执行如下： 而在if语句中，只有其中一句会被执行，因此使用函数替代并不合适，如下代码： 12345678910111213def if_(c,t,f): if c: return t else: return f from math import sqrt def real_sqrt(x): return if_(x&gt;0,sqrt(x),0.0) if __name__ == '__main__': print(real_sqrt(-4)) 我们需要实现返回一个实数平方根结果的实部，众所周知，负数开平方后实部为0，因此负数应输出0 但执行后发现却出现了sqrt的 ValueError: math domain error 因为在函数调用时，sqrt(x)同时也会执行，此时x小于0故触发了sqrt的assert 因此没有了控制语句，我们只能在值之间选择而不能在条件之间选择 条件语句的简单形式 &lt;consequent&gt; if &lt;predicate&gt; else &lt;alternative&gt; 执行predicate语句 若为真，则整个表达式的值为consequent的值 若为假，则整个表达式的值为alternative的值 逻辑运算符的短路效应 执行一个语句&lt;left&gt; and &lt;right&gt; 计算left语句 若结果是false，则整个表达式的结果是false 若结果是true，则整个表达式的结果是right语句的结果 执行一个语句&lt;left&gt; or &lt;right&gt; 计算left语句 若结果为true，则整个表达式的结果是true 若结果为false，则整个表达式的结果是right语句的结果 HW Lecture4的作业部分 柯里化(Currying) 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c) 如上文中的makeadder函数，返回的是在内部定义的adder函数，每个函数接受一个参数，等同于makeadder(k,n) 柯里化是函数式编程的一个体现，使得函数代码更简洁 1-Product My solution: 123456x = 1 re = 1 while x&lt;=n: re*=term(x) x+=1 return re product函数有一个term参数用于接收函数，根据不同计算需要可以传入不同计算相关函数(square，identity等) 2- Accumulate My solution: 123456a=1 re=start while a&lt;=n: re = fuse(re,term(a)) a+=1 return re 1return accumulate(add, 0, n, term) 1return accumulate(mul, 1, n, term) 在上一题的基础上添加了选择每个数之间使用加法还是乘法的参数fuse，fuse同时也是接收函数来指定每个term运算之间的运算方式(add,mul 等) 3-Make repeater My solution: 12if n == 0: return lambda x: x return lambda x: f(make_repeater(f,n-1)(x)) 这里需要将传入的数值执行n次指定运算f，即f(f(...f(x)...)) 本人使用了递归实现，即make_repeater(f,n)(x)=f(make_repeater(f,n-1)(x))=f(f(make_repeater(f,n-2)))=...=f(f(...f(x)...)) 每次加一层f()，直到时替换为x","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【题解】牛客小白月赛109-C","slug":"牛客小白月赛109-C","date":"2025-01-17T14:16:39.000Z","updated":"2025-01-17T16:42:49.194Z","comments":true,"path":"2025/01/17/牛客小白月赛109-C/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B109-C/","excerpt":"","text":"题目描述 Tobo 养了 nnn 只猪猪，猪猪们的编号为 。我们规定两种操作： 1. 对于给定的 l,r 表示 Tobo 要和编号为 l 到 r的猪猪按顺序玩耍，但因为 Tobo 喜新厌旧，所以已经玩耍过的猪猪不会再一起玩，会直接跳过它。 2. 对于给定的 x ，表示编号为 x 的猪猪想知道自己是第几个和 Tobo 玩耍的，如果没有玩耍过则输出 0 。 你一共需要处理 q 次操作。 输入描述: 第一行输入两个整数 代表 Tobo 养的猪猪数量、操作次数。 此后 q 行，每行先输入一个整数 表示操作类型，随后： 若 op=1，在同一行上输入两个整数 代表 Tobo 将依次和编号为 l 到 r的猪猪玩耍。 若 op=2，在同一行上输入一个整数 代表一次询问。 输出描述: 对于每一次询问，在单独的一行上输出一个整数，表示询问的猪猪是第几个和 Tobo 玩耍的；若没有玩耍过，则直接输出 0。 输入 123456785 7 1 2 3 2 3 1 3 5 2 4 2 1 1 1 5 2 1 输出 12342 3 0 5 说明 123对于第一次操作，Tobo 将依次和编号为 2,3 的猪猪玩耍； 对于第二次操作，编号为 3 的猪猪想知道自己是第几个和 Tobo 玩的，输出 2 ； 对于第三次操作，Tobo 将依次和编号为 3,4,5的猪猪玩耍，这其中，由于编号为 3 的猪猪已经和 Tobo 玩过，所以 Tobo 会跳过它，直接和编号为 4 的猪猪玩耍。 错解 每次操作1遍历区间，暴力枚举每一只猪，若没有玩过则赋值为当前玩过的第n只猪，若玩过则直接跳过 该方法会TLE（后面又加强数据了优化后的暴力也差一点点ww） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; int play[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; int tep = 0; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (tep&gt;=n) continue; // 全部玩过后直接跳过 if (play[l]==0) { // 遍历区间的左端赋值 tep++; play[l]+=tep; } for(int i = l; i&lt;r;i++){ // 遍历l到r并赋值为第tep只玩过的猪 if (play[i+1]==0) { tep++; play[i+1]=tep; } } } else { // 询问操作 int p; cin &gt;&gt;p; cout &lt;&lt; play[p]&lt;&lt;endl; } } return 0; } 正解 前置知识 lower_bound()函数： 定义：const_iterator lower_bound( const K&amp; x ) const; STL内置函数，用于寻找第一个大于等于key的值，返回值为指向刚好大于等于key的下一个元素，若不存在则返回末尾迭代器（指向最后一个元素） 解析 我们可以使用set来优化 由于每只猪的编号都连续且不相同，我们可以用set来存储 使用lower_bound()函数查找在待查找区间里下一个没有玩过的猪 然后将该猪标记为第n个玩的，从集合中删除 这样可以保证集合里始终都是没有被玩过的猪，每次查找都找到离l最近的一个没有被玩过的猪，直到区间删空，即所有猪都被玩过 询问操作直接输出标记 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; set&lt;int&gt; pig; int tag[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; pig.insert(1e9); // 防止最后全删完后剩下索引0处无法跳出 for (int i = 1;i&lt;=n;i++) pig.insert(i); // 把所有猪存入集合 int cnt = 1; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l,r; cin &gt;&gt; l &gt;&gt; r; while(1){ int tep = (*pig.lower_bound(l)); // 用lower_bound()返回第一个大于l的数，即找到下一个在区间内且没有玩过的猪 if (tep&gt;r) break; // 区间为空，寻找结束 tag[tep]=cnt; // 标记找到的猪是第几个被玩的 cnt++; pig.erase(tep); // 把被玩过的猪从集合中删除 } } else { // 询问猪是第几个玩的 int p; cin &gt;&gt; p; cout &lt;&lt; tag[p]&lt;&lt;endl; } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【C/C++】指针","slug":"指针","date":"2025-01-17T06:53:15.466Z","updated":"2025-01-22T12:16:27.333Z","comments":true,"path":"2025/01/17/指针/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E6%8C%87%E9%92%88/","excerpt":"","text":"指针 数据在内存中的存储 这是一段内存，他被分成了许多段，每段一个byte 当我们声明一个变量int a，计算机会给该变量分配一块空间，分配取决于数据类型与编译器 如：int 与float占4bytes，char占1bytes 当我们给变量a赋值a=5，计算机会去寻找该变量，去到他的地址，以二进制写入数据 指针的基础使用 指针是一种变量，它可以存储变量的地址 使用数据类型* 变量名创建一个指针：int *p char *c 使用取地址符&amp;获取一个变量的地址，并可以将指针指向该变量地址：p=&amp;a print p，print &amp;a，print &amp;p分别对应打印p指向(a)的地址，a的地址，p的地址 将一个*放在指针变量前，可以对指针进行解引用，即获取p指向地址的值 则print *p会返回a的值，*p = 8会更改a的值到8 实例代码： 1234567891011121314151617181920#include&lt;stdio.h&gt; int main(){ int a=5; int* p; // 若该指针p没有被初始化，p会变成一个野指针，会因为指向任意位置而报错 p = &amp;a; // 储存a的地址 // 上两行等同于int* p = &amp;a; printf(\"A:%d\\n\",p); // a的地址 printf(\"V:%d\\n\",*p); // a的值 printf(\"A:%d\\n\",&amp;a); // a的地址 *p = 12; // 更改p指向地址(a)的元素值 printf(\"A:%d\\n\",a); // 更改后的a值 int b = 20; *p = b; // p不会指向b，只会将b的值赋给a printf(\"A:%d\\n\",p); // 还是a的地址 printf(\"V:%d\\n\",*p); // b的值 return 0; } 指针类型 不同的数据类型占据不同的内存： int：4bytes char：1byte float：4bytes void指针： 可以存放任意类型的指针，且无需强制类型转换 需要进行显式转换后才能赋值给其他类型 可以与其他类型指针直接比较地址值 只有强制类型转换后才能操作（解引用、算术运算等） 可以和普通指针一样传入NULL或nullptr表示空指针 作为函数输入输出时，表示可以接受任意类型和输出任意类型的指针 指针类型间的转换 定义一个变量int a=1025： 他在内存中的布局为（从右到左分别为第0 1 2 3个字节，他们的地址也是连续的）： 其中，最左边的一位为符号位，0为整数1为负数 若我们定义一个字符指针c指向a，由于字符只占一个字节，故c只会指向a的第一个字节： 对c进行算术运算(+1)会让他指向下一个字节 以至于得到4 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; int main(){ // 一个整形指针 int a = 1025; // 在二进制中为四字节:00000000 00000000 00000100 00000001 int* p; p = &amp;a; printf(\"size of integer is %d\\n\", sizeof(int)); printf(\"Address = %d, value = %d\\n\",p,*p); // 一个字符指针 char *c; c = (char*)p; // 进行强制类型转换 printf(\"size of integer is %d\\n\", sizeof(char)); // 由于char指针只有一个字节,则机器只看从右边开始的一个字节 即00000001 printf(\"Address = %d, value = %d\\n\",c,*c); // 增加一个字节,则指针指向从右边开始的第一个字节 即00000100 printf(\"Address = %d, value = %d\\n\",c+1,*(c+1)); // 一个void指针 void *p0; p0 = p; // 不需要显式的类型转换 // 当p0没指向任何特定类型时,不能解引用 printf(\"Address = %d, value = %d\\n\",p0,*p0); // 也不要进行算术运算 printf(\"Address = %d %d\\n\",p0,p0+1); } 指针算术运算 对一个指针进行加1操作，相当于将该指针增加一个该指针数据类型所占字节数的字节数 例如对int *p=&amp;a; p++;得到p的值为a的地址加4 123456789101112#include &lt;stdio.h&gt; int main(){ int a = 10; int *p; p = &amp;a; // 指针加法 : +1代表增加一个数据类型的字节数 printf(\"Address p is %d\\n\",p); // p的地址 printf(\"Value at address p is %d\\n\",*p); // p指向的值 printf(\"size of integer is %d bytes\\n\", sizeof(int)); // int类型所占的字节数 printf(\"Address p+1 is %d\\n\",p+1); // p+1指向的地址 printf(\"Value at address p+1 is %d\\n\",*(p+1)); // p+1指向的值(垃圾值) } 指向指针的指针 假设定义了一个数据int x = 5; 我们定义一个指针指向x int *p = &amp;x 此时我们可以再定义一个指针指向指针p int **q = &amp;p 甚至还可以定义一个指针指向指针q int ***r = &amp;q (r是205) 示例代码 123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int x =5; int* p = &amp;x; *p = 6; int** q = &amp;p; int*** r = &amp;q; printf(\"%d\\n\",*p); // p指向x的值 printf(\"%d\\n\",*q); // q指向p的值(x的地址) printf(\"%d\\n\",*(*q)); // q指向p的值指向x的值 printf(\"%d\\n\",*(*r)); // r指向q的值,q指向p的值 printf(\"%d\\n\",*(*(*r))); // r指向q的值,q指向p的值,p指向x的值 // 更改x的值 ***r = 10; print(\"x = %d\\n\", x); // **q与*p都指向x的值,则相当于x自加2 **q = *p +2; print(\"x = %d\\n\", x); } 指针用例—函数传引用 or 传值？ e.g. 局部变量与全局变量： 有以下代码 12345678910#include &lt;stdio.h&gt; void f(int x){ x=x+1; } int main(){ int x=10; f(x); printf(\"%d\\n\",x); return 0; } 该代码中的函数想让变量+1，但输出的结果显然还是10，这是为什么呢？ 看以下代码： 1234567891011#include &lt;stdio.h&gt; void f(int x){ printf(\"Address of x in f is:%d\\n\",&amp;x); x=x+1; } int main(){ int x=10; f(x); printf(\"Address of x in main is:%d\\n\",&amp;x); return 0; } 你会惊奇的发现，f函数中的x与main函数中的x的地址不一样，这也就说明了为什么+1不成立 当程序运行时，计算机会预留一部分内存给程序，他们被分为四个部分：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等）。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧 让一个函数调用另一个函数时，两个函数分别称为主调函数与被调函数，在主调函数中调用其他函数用到的参数称为实际参数，被调函数中的函数称为形式参数，实参会被映射到形参。这个操作即传值 当main函数调用f函数时，一块它的栈帧会被创建，其中的参数会被分配到对应空间，执行+1操作后，这个函数的栈帧中的变量执行了+1，但不影响其他地方的变量。 当f函数执行完毕，程序回到main函数，此时f的栈帧会被清除，main函数会被继续执行，故局部变量的生命周期只是函数执行期间。 接下来进行的函数是printf函数，这是一个库函数，在栈中创建它的栈帧并指型。这一个结构被称为(函数)调用栈，即：是将一个个函数的栈帧，按照调用的顺序依次压入栈中，等最上层的函数执行完了，就弹出相应的栈帧的过程 注意：栈是有大小的，如果因为无限递归等原因导致栈帧一直被创建而不清除，程序会因为栈溢出而终止 那传引用能否实现？ 1234567891011#include &lt;stdio.h&gt; void f(int *p){ *p = (*p)+1; } int main(){ int a; a = 10; f(&amp;a); printf(\"a = %d\", a); return 0; } 该函数传的是地址 当调用main函数，它的栈帧被创建，a=10进入栈。 调用f函数，它的栈帧被创建，则p接收到a的地址，入栈，此时p指向a。 在函数中解引用p，并执行操作，p指向的内存(a)的值就会增加，即a的值增加1 回到main函数，a的值就是11 这就是传引用，它可以节省很多内存空间，也可以处理一些复杂数据类型以节省内存 指针与数组 让我们声明一个数组 int a[5] 即我们创建了五个整型变量，在内存中连续存在(int 占四个字节)，则整个数组占的大小为20bytes，作为一个连续的块 我们定义一个指针int* p，将p指向a的第一个元素，则p解引用后打印的是a[0]的值 回忆之前说的指针算术，若我们将p+1，则p会往前移动四个字节，**此时*(p+1)即a[0]后四个字节的值，即a[1]** 与之前不同，一个值它的地址+1后会移动到一个未知内容的地址，而数组a中+1后p指向的值是已知的 若直接将数组名赋值给p，则p默认接收到的是数组a首元素的地址，称为数组的基地址 若想获得数组某个值的地址，可以使用&amp;a[i]或者a+i 若想获得数组某个值，可以使用a[i]或者*(a+i) 注意：对数组名（常量 ）自加是非法的，可以定义一个指针指向数组名让该指针自加 实例代码： 1234567891011#include &lt;stdio.h&gt; int main(){ int a[]={2,4,5,8,1}; for (int i = 0;i&lt;5;i++){ printf(\"Address = %d\\n\",&amp;a[i]); printf(\"Address = %d\\n\",a+i); printf(\"Value = %d\\n\",a[i]); printf(\"Value = %d\\n\", *(a+i)); } } 指针用例—数组传参 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int suma(int a[],int size){ int sum = 0; for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int sumb(int a[]){ int sum = 0; int size = sizeof(a)/sizeof(a[0]); printf(\"In sumb - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int main(){ int a[]={1,2,3,4,5}; // 计算数组大小 printf(\"In main - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); int size = sizeof(a)/sizeof(a[0]); // 传入数组大小后进行加和 int tot = suma(a,size); // 在函数中计算数组大小并加和 int tot2 = sumb(a); printf(\"tot = %d\\n\", tot); printf(\"tot2 = %d\\n\", tot2); } 以上代码会出现一些问题： 在调用main与sumb函数时，它们的栈帧会被创建 调用sumb函数时，编译器只会创建一个同名的指针在sumb的栈帧中，即它只指向main函数中数组a的首元素地址（即int a[]等同于int *a） 因此函数中的sizeof a是一个8字节的指针。 指针与字符数组 字符数组 C中的字符串存储在数组中，必须以’\\0’结束 字符数组赋值： 可以指定每一位进行赋值， 或者使用字符串字面值（用双引号括起来的字符串）赋值，该方法会隐式地添加一个’\\0’ 或者使用大括号初始化每一位，以逗号间隔并在结尾加上’\\0’ 注意：只能在声明同时用字符串字面值赋值 使用指针 字符数组中数组名代表的是数组首元素的地址，可以用一个指针变量指向它，该变量也可以对字符数组进行操作 12345678910#include &lt;stdio.h&gt; int main(){ char c1[6]=\"Hello\"; char *c2; c2 = c1; c2[0]='A'; // equal to c1[0]='A'; c2++; // 指向下一个元素 c1++; // 非法 } 有等价关系： c2[i]等同于*(c2+i) c1[i]等同于*(c1+i) 函数传参 12345678910111213141516171819#include&lt;stdio.h&gt; void print(char *c){ int i = 0; // while (c[i]!='\\0'){ // *(c+i)也可以 // printf(\"%c\",c[i]); // i++; // } // 由于c是指针，故可以通过自增与解引用来进行访问 while(*c!='\\0'){ printf(\"%c\",*c); c++; } printf(\"\\n\"); } int main(){ char c[20] = \"Hello\"; print(c); return 0; } 指针与二维数组 如果我们要创建一个二维数组b[2][3] 此时，b[0]与b[1]表示三个整数的一维数组，在内存中占用3*4=12个字节，是按行存储的 故int *p=b;指代的是返回一个指向一维数组的指针，此时不能指针运算或解引用，故不能这么用 故应使用int (*p)[3]来创建一个二维指针数组，其中3表示三个指向一维数组的指针 这时print b or &amp;b[0]都指代第一个元素的地址 ​ print *b or b[0] or &amp;b[0][0]都指代第一个元素地址的值 ​ print b+1 or &amp;b[1]会跳到下一个数组的首地址（+12） 使用print *(b+ 1)or b[i]or&amp;b[1][0]指代下一个指向一维数组的并返回 值 解引用时，需要一步步解 例 *(*b+1) *b 为b[0]，一个一维数组的首元素地址，*b+1会让指针移动四个字节带到下一个整型变量， 相当于&amp;b[0][1] 我们解引用后，*(*b+1)就相当于b[0][1] 指针运算：b[i][j]=*(b[i]+j)=*(*(b+i)+j) 指针与多维数组 原理 与二维数组类似 假如我们有一个int数组c[3][2][2]，在内存中的存储如下 简化为三个二维数组线性存储，每个二维数组内两个一维数组线性存储 故我们可以声明一个指针int (*p)[2][2] = c;，指向2*2的二维数组 这时print c，print *c，print c[0]，print &amp;c[0][0]均输出第一个一维数组的地址 指针运算：c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) 可以理解为解引用一次就脱一层[] e.g. print *(c[0][1]+1)指向的是c[0][1][1] print *(c[1]+1)指向的是c[1][1]，即c[1][1][0] 用于函数传参 如一维数组传参，我们可以通过传值或传引用两种方法传参 注意：传值时除了最高维度，其他维度必须要指定偏移量（即形参定义时必须和传入数组长度一样） 123456int two_dim(int a[][3]){ } int three_dim(int a[][2][2]){ } 而根据数组名就是指向第一个元素的指针，我们可以直接传引用来实现降维度 注意：只能降到次一级维度，且其余的必须指定偏移量 123456int two_dim(int (*a)[3]){ } int three_dim(int (*a)[2][2]){ } 指针与动态内存 内存的分配 在一个典型架构中，分配给应用程序的内存分为四个区段：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等），函数调用信息。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 栈 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧，大小在编译期间决定 所有函数从下往上开辟栈帧后，在执行时总是栈顶的函数在执行，其余函数暂停，等待上方函数返回值等。当上方函数返回后，它占用栈的内存也会被清除，下一个函数运行。任何时候正在执行的函数都是栈顶的那个函数 预留给栈的空间在运行期间并不会增长，也不能请求更多内存。如果运行时的栈增长超过了程序预留的栈内存大小，那么会造成栈溢出(stack overflow) 因此栈有两个限制： 在栈上的变量无法操作骑作用域 当声明一个很大的数据类型，可能会造成溢出；且只能在编译时分配他的大小，无法在程序运行时分配它的大小 堆(动态内存) 这时我们需要用到堆来分配或销毁或内存。我们可以任意使用堆上的内存，只要不超过系统内存限制。 堆又称为动态内存，使用堆内存称为动态内存分配 (注意这里的堆并不是数据结构) C风格： 12345678910111213#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; // 分配到栈上 int *p; // 指向堆内存的指针 p = (int*)malloc(sizeof(int)); // 在堆上开辟一块四字节的内存，让指针p指向其地址 *p=10; // 解引用将值存入堆 free(p); // 释放内存 p = (int*)malloc(20*sizeof(int)); // 在堆上再开辟一块20个四字节的内存作为数组，让指针p指向其首元素地址 // 可以用以下两种方式访问 p[0] = 1; *(p+1) = 2; } 定义一个指针变量p，它被存储在栈中，指向堆中分配的内存地址 通过malloc在堆上分配一块四字节的内存，malloc会返回一个指向这块内存起始地址的指针，void类型。故我们需要进行一个强制类型转换，并赋给指针变量p 使用堆上内存的唯一方式是通过引用，自己维护一个指针指向这块内存。我们通过对指针变量p解引用并赋值来使用。 若我们再以同样方式分配一块四字节内存，让p指向它，并赋值为20，p此时指向的便是堆中的另一块内存。而之前那块内存仍在堆上，并不会被自动回收，此时称为内存泄漏，因此我们需要在用完一块内存后，及时调用free()释放内存。 如果要分配一个数组内存，我们只需要传入数组大小字节数即可，返回的是内存的初始地址 若malloc无法在堆上成功分配内存，会返回NULL C++风格： 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; int *p; // 指向堆内存的指针 p = new int; // 在堆上开辟一块int大小的内存(四字节) *p = 10; // 解引用并赋值 delete p; // 释放内存 p = new int[20]; // 在堆上开辟一个20大小的int数组 delete[] p; // 释放数组内存 } c++中使用关键字new与delete开辟与释放内存，不需要类型转换 相关函数 malloc 定义：void* malloc(size_t size)(size_t相当于无符号整数) 用法：int *p = (int*)malloc(分配空间大小) 分配空间大小一般习惯通过sizeof计算，如想要开辟一个存储三个int变量的数组，我们可以用3*sizeof(int)来计算大小，一般不直接写。 由于malloc返回的是void指针，指向其初始地址，而void指针无法解引用，因此我们一般在前面进行强制类型转换来转化成int指针以方便操作 malloc不会将分配的空间初始化，建议使用memset(p,0x00,sizeof(p))初始化 calloc 定义：void* calloc(size_t num, size_t size) 用法：int *p = (int*)calloc(分配元素个数, 每个元素空间大小) calloc可以指定分配的元素个数 calloc在分配空间后会自动将其初始化为0 realloc 定义：void* realloc(void* ptr, size_t size) 用法：realloc(已指向某处内存的指针, 修改空间大小) realloc用于修改分配的内存大小 若需要的新内存块比原来大，程序会创建一块新内存并将内容复制过去 若之前的内存的相邻部分还有可用内存，程序会直接拓展原空间 若需要的新内存块比原来小，则多余部分的内存会被释放掉 注意以下用法： 12int *a = (int*)realloc(a,0); // 相当于free(a) int *b = (int*)realloc(NULL,n*sizeof(int)); // 相当于malloc 内存泄漏 当我们动态申请了内存后，忘记去释放，此时程序占用了一些未使用的内存，称为内存泄露 对于栈：由于栈帧在使用完后会被自动销毁，故不会发生内存泄漏 对于堆：在开辟空间后，堆上的内存必须要被显式地释放掉，否则会一直存在 注意：任何未使用和未引用的堆上内存都是垃圾，程序员要确保不要浪费内存 函数返回指针 我们可以在函数类型处加上*来声明函数返回值是一个指针。 注意以下情况： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int c = (*a)+(*b); return &amp;c; } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 该程序对print的输出正常，而输出sum时出现了异常，从底层原理分析： 执行main函数，开辟栈帧，执行add函数，在main函数上再开辟栈帧，main函数会等待add返回 此时add中a与b存储了main函数中x与y的地址，c存储了*a与*b的和，返回的是c的地址，故main函数中的p指针存储的是c的地址 add执行完毕，占用空间被清除。但注意，此时p指向的内存仍未变化，即此时它指向了被释放掉的内存空间，值是随机的 现在执行print函数，开辟栈帧，原空间被覆盖，因此p存储的地址对应的值已经不是c的值了，因此输出异常。 还有一种情况：若不执行print函数，输出的值可能会正确。因为此时程序还没重写或清除那个空间上的数据（虽然已经释放空间） 而对于main与add函数，由于被调函数的栈空间总是在主调函数之上，因此被调函数执行时主调函数仍在栈内存中，因此add可以访问main函数中的变量。但若我们想要返回被调函数的一个局部变量给主调函数，当被调函数结束后，内存已被释放，因此会出问题。 因此可以从栈底向上传局部变量或局部变量的地址，但不能从栈顶向下传局部变量或局部变量的地址 因此我们可以修改： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int *c = (int*)malloc(sizeof(int)); // 在堆上开辟内存 *c = (*a)+(*b); return c; // 返回的是堆上的指针 } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 我们将c开辟在堆上，此时就不会被清除了，返回c是安全的 函数指针 我们可以用指针指向函数地址，即指向函数的指针。我们可以用这种指针解引用和调用函数。 函数的地址 在内存中，一个函数就是一块连续的内存。 一般程序执行指令会按照地址依次执行，而函数调用可以让程序跳到某一个地址开始执行其中的指令。 此时对应的函数地址可以称为函数的入口点，即函数第一条指令的地址 函数指针的使用 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(char *name){ printf(\"hello\"); } int add(int a, int b){ return a+b; } int main(){ int c; int (*p)(int,int); // 函数指针 p = &amp;add; // 指针指向add函数的地址(不用&amp;也可) c = (*p)(2,3); // 解引用，并传入参数执行函数(不用解引用也行) printf(\"%d\\n\",c); void (*ptr)(char*); ptr = print; // 不用&amp;的情况 ptr(\"mixbp\"); // 不用解引用的情况 } 由于单纯的函数名代表函数入口点，故不用&amp;与解引用也可以 注意：为了指向一个函数，函数指针的类型必须是正确的 回调函数 将函数指针作为函数参数传入，并在函数内部通过该函数指针调用函数，被调用的函数即为回调函数 123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(){ printf(\"hello\"); } void b(void (*ptr)()){ ptr(); // 用ptr回调传进来的函数 } int main(){ void (*p)() = print; // 定义一个指针指向print b(p); // 传入该函数指针 b(print); // 这样也可以传 } 代码中，函数b可以通过函数指针来回调函数print 可以定义一个指向print函数的指针传入，也可以直接传入print，此时指代的是print函数的首地址 应用：排序 设计一个排序函数，并可以按照不同逻辑进行排序 我们可以在普通排序函数中添加一个函数指针参数(比较函数)，通过设计蚂蚁比较逻辑并传入排序函数，可以灵活实现不同情景的比较，而不用每次都根据不同逻辑重新写一遍排序函数 如实现正序、逆序、按绝对值排序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;math.h&gt; int compare(int a,int b){ if (a&gt;b) return 1; else return -1; } int r_compare(int a, int b){ if (a&gt;b) return -1; else return 1; } int abs_compare(int a, int b){ if (abs(a)&gt;abs(b)) return 1; else return -1; } void sort(int *a, int n, int (*cmp)(int,int)){ int tep; for (int i = 0;i&lt;n;i++){ for (int j = 0;j&lt;n-1;j++){ if (cmp(a[j],a[j+1])&gt;0){ tep = a[j]; a[j] = a[j+1]; a[j+1]=tep; } } } } int main(){ int a[]={3,2,1,5,6,4}; int b[]={-2,-3,5,4,1,-6}; sort(a,6,compare); // 正序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(a,6,r_compare); // 逆序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(b,6,abs_compare); // 绝对值排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",b[i]); printf(\"\\n\"); } 同样的逻辑，在c的stdlib.h库中有一个qsort函数，只要给予它排序逻辑并传入就可以对任意数组排序","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"【算法】快速幂","slug":"快速幂","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-17T07:01:52.295Z","comments":true,"path":"2024/12/20/快速幂/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 问题引入 如何计算 朴素算法：让n个a相乘，时间复杂度为，当n特别大的时候，耗时特别长 而快速幂算法可以大大减少时间复杂度 n的分类 n为2的幂次时 如 我们可以用上一次的结果当作下一次的乘数： 快速幂原理 这样只需要进行六次乘法就可以得出结果，时间复杂度为 即使用了倍增原理，将每次a的数量翻倍 n不为2的幂次时 我们可以将不是2的幂的数写成若干个2的幂的数的和，如 可以改写为，再根据以上方法计算 如何将n分解为2的幂次之和？ 答案是位运算 让我们看看这几个数的二进制表示形式 二进制表示分解n的原理 会发现，目标数n的二进制中的1的个数与位置正好对应它分解后的数字 伪代码 12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r 逻辑 行3，7：每次除二，让二进制位从右到左减少一位，相当于右移一位 行6：每次让翻倍（,,,,…） 行2，4，5，8：如果mod2==1，代表该位是1，则将该位代表的与结果相乘，即让幂次相加 位运算改进 n mod 2==1等同于n&amp;1，n/2等同于n&gt;&gt;1 时间复杂度 ，循环次数为n的二进制位数，对于整数n，它的二进制位数为 板子 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } 应用1：幂取模 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } 注： 应用2：斐波那契数列 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } 用矩阵形式表示斐波那契数列，如下图 斐波那契矩阵表示 我们可以发现它可以分为n个矩阵相乘 再乘列向量F1 F0","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数学】逆元","slug":"逆元","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/逆元/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"逆元 前置知识 单位元 在一个集合中，对于某种运算，如果对于任何的集合元素 a，和元素 e 运算，得到还是集合元素 a 本身，则称 e 为这个运算下的单位元。 在加法运算中，对于任意实数，有，则单位元 (可以认作相反数) 在乘法运算中，对于任意实数，有，则单位元 (可以认作倒数) 模乘的单位元是 (证明自己搜) 逆元 在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 模意义下的乘法逆元 若 且(a与p互质)，则称a关于模p的乘法逆元为x 逆元即数论中的广义倒数。 费马小定理 若p为质数，则，则 或对于任意整数a，有 欧拉函数 ，表示小于等于n的正整数中和n互质的数的个数，如 当n是质数时，有 欧拉函数是积性函数，即对任意满足的整数a,b，有 特别地，当n是奇数时 求一个数的欧拉函数值：在质因数分解的同时求解即可 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } 欧拉定理 若，则 则对于费马小定理，有更一般的结论： 应用 求除法的模运算时，经常会因为精度或溢出问题而导致结果产生误差。 故我们可以将求转化为的逆元 将除法转为乘法，精度问题便就解决了 扩展欧几里得定理求逆元 给定正整数a，b，求满足的x的最小正整数解，若无解返回-1 结论 当a与b不互质时，逆元必定不存在 当a与b互质时，有 对应系数可得： 若改为求满足 的最小正整数解，经过变形 原式可以由变为，则和上方一致 模板 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } 费马小定理 给定素数p和正整数a，求满足的最小正整数x，若不存在返回-1 此时模数固定为素数，故直接可以用费马小定理求解 当a为p的倍数时，，所以一定不存在，返回-1 根据费马小定理有，又 则，逆元x满足 代码 12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } 线性求逆元 对于求一连串数字模p的逆元，上两种方法容易超时，用这种方法更快一些 结论 (证明见oi-wiki) 有递推式 代码 123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } 线性求任意逆元 首先我们求出n个数的前缀积，这时我们可以用exgcd或费马小定理求出的乘法逆元 又因为，，故我们可以将，就会和其逆元抵消，以求出 求出所有前缀积的逆元后，我们可以让前缀积的逆元乘i-1的前缀积来消除其他逆元，以得到的逆元，即 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // 也可以用exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【数据结构】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-25T07:36:57.832Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set) 概念 不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1 如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率 查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素， 123find1(x){ return set[x]; } 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素， 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } 实现2 每个集合用一颗有根树表示 定义一个数组set 若set[i]=i, 则i为该树的根节点，i代表本集合 若set[i]=j, 若ji, 则j是i的父节点 效率 查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏，一般 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } 并：只需要将根节点改为另一个集合的根节点即可， 123merge2(a,b){ set[a]=b; } 改进 如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } 此时查找操作的时间复杂度变成了 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 路径压缩示意 代码 1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; } 模板 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 ,表示共有 个元素和 个操作。 接下来 行，每行包含三个整数 。 当 时，将 与 所在的集合合并。 当 时，输出 与 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1234N Y N Y 提示 对于 的数据，，。 对于 的数据，，。 对于 的数据，，，，。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // 并查集 // 查找操作，使用路径压缩 int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // 初始化每一位的根节点是他自己 for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // 进行合并 if (z==1){ merge(x,y); } else { // 如果两者的根节点相同，则属于同一集合 if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-17T07:00:58.279Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 这是一个测试帖子 三级标题 四级标题 五级标题 测试代码 123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ ### じや……一生 ACMしてくれる?","categories":[{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"},{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"},{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"},{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}