{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【图论】最近公共祖先(LCA)","slug":"最近公共祖先(LCA)","date":"2025-05-18T13:51:52.675Z","updated":"2025-05-18T13:52:18.778Z","comments":true,"path":"2025/05/18/最近公共祖先(LCA)/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(LCA)/","excerpt":"","text":"最近公共祖先(LCA) 概念 祖先：从某个节点上溯到根节点的所有节点都是该节点的祖先，如图中节点5的祖先为节点3 1 0 公共祖先：两个节点共有的祖先，如图中节点2和节点5的公共祖先为1 0 最近公共祖先：所有公共祖先中深度最深的祖先，若待求的一个节点本身是另一个节点的祖先，则该节点即为所求最近公共祖先 LCA 朴素算法 思路：将两节点跳至同一深度，让两节点同时上跳至同一节点 方法：DFS 倍增LCA 使用倍增思想，以及st表来寻找祖先。 由倍增思想，我们可以得到某节点级祖先是级祖先的级祖先 故我们只需要每次寻找两节点尽可能相遇的位置，则它们的父节点一定相遇，此时父节点便为LCA 具体来说，同时往上走的时候要保证各自到达的节点不同，走到最后在往上走一步即可 时间复杂度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 5e5 + 10; const int mod = 1e9 + 7; int n, m, s; int st[N][20]; int head[N],depth[N]; int power, cnt; struct node2{ int u, f ,e; }; struct node{ int to, nxt; }edge[2*N]; // 无向图 开两倍 // 链式前向星建图 void add_edge(int from, int to){ edge[++cnt].to = to; edge[cnt].nxt = head[from]; head[from]=cnt; } // 非递归版本 防止爆栈 void dfs_stack(int i, int fat){ stack&lt;node2&gt; stk; stk.push({i,0,-1}); while(!stk.empty()){ node2 cur = stk.top(); stk.pop(); if (cur.e==-1){ depth[cur.u] = depth[cur.f]+1; st[cur.u][0]=cur.f; for (int s=1;(1&lt;&lt;s)&lt;=depth[cur.u];s++){ st[cur.u][s] = st[st[cur.u][s-1]][s-1]; } cur.e = head[cur.u]; } else cur.e = edge[cur.e].nxt; if (cur.e!=0){ stk.push(cur); if (edge[cur.e].to!=cur.f){ stk.push({edge[cur.e].to, cur.u, -1}); } } } } // 递归查找每个节点的深度 void dfs(int i, int fat){ depth[i] = depth[fat]+1; st[i][0]=fat; for (int p = 1;(1&lt;&lt;p)&lt;=depth[i];p++){ st[i][p] = st[st[i][p-1]][p-1]; // 跳 } for (int e = head[i]; e; e = edge[e].nxt){ if (edge[e].to!=fat){ dfs(edge[e].to, i); } } } // 开始向上走寻找 int lca(int a, int b){ // 将深度大的设为a，深度小的设为b if (depth[a]&lt;depth[b]){ int temp = a; a = b; b = temp; } // 让更深的a上跳 for (int p = power; p&gt;=0; p--){ if (depth[st[a][p]]&gt;=depth[b]){ // 保证上跳不超过b a = st[a][p]; } } // 特判来到同一层时两者相同，即b是a的祖先 if (a==b){ return a; } // 到达同一层，开始上跳，保证每次上跳两者不到同一节点 for (int p = power; p&gt;=0; p--){ if (st[a][p]!=st[b][p]){ a = st[a][p]; b = st[b][p]; } } return st[a][0]; } void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1;i&lt;n;i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; add_edge(u,v); add_edge(v,u); } power = log2(n); cnt = 1; //dfs_stack(s,0); dfs(s,0); while(m--){ int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; lca(a,b)&lt;&lt;endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; } Tarjan算法 Tarjan将所有询问存储，并在dfs中离线处理 步骤： 建好每个节点的问题列表，并遍历树，即建立两节点之间的关系，双向 来到当前节点cur，标记vis数组为true，表示当前节点已经访问 遍历cur的所有子树，每棵子树遍历完后和cur节点合并，cur为头节点 ​ 此时cur为该节点子树节点集合的头节点 遍历完所有子树后，处理cur节点的每一条查询(cur, x) 若x已经访问过，则cur与x的最低公共祖先 = x所在集合头节点 若没有访问过，则先不处理，等到x节点时再去处理(x, cur)得到答案 时间复杂度： 只能离线查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 5e5 + 10; const int mod = 1e9 + 7; int n, m, s; int tcnt, qcnt; int headt[N], headq[N]; int vis[N], ans[N], disj[N]; // 储存树 struct node{ int to, nxt; }edge[2*N]; // 储存询问 struct node2{ int to, idx, nxt; }query[2*N]; // 对树加边 void add_tedge(int from, int to){ edge[++tcnt].to = to; edge[tcnt].nxt = headt[from]; headt[from] = tcnt; } // 对询问加边 void add_qedge(int from, int to, int i){ query[++qcnt].to = to; query[qcnt].nxt = headq[from]; query[qcnt].idx = i; headq[from] = qcnt; } // 并查集查找操作 int find(int x){ if (disj[x]!=x) disj[x] = find(disj[x]); return disj[x]; } void tarjan(int u, int f){ vis[u] = 1; // 当前节点已访问 // 遍历该节点的孩子 for (int e = headt[u], v; e; e=edge[e].nxt){ v = edge[e].to; if (v!=f){ // 孩子和父节点不能相同 tarjan(v,u); // 递归，让现在的孩子作为子过程的父亲节点 disj[v] = u; // 子树头节点改为当前节点，即合并 } } // 开始处理问题 for (int e = headq[u], v; e; e=query[e].nxt){ v = query[e].to; if (vis[v]){ // 问题已遍历，可以处理 ans[query[e].idx]=find(v); // 问题编号位置找到v所在集合的头节点，填入ans即为答案 } } } void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1;i&lt;=n;i++){ disj[i]=i; } qcnt = tcnt = 1; for (int i = 1;i&lt;n;i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; add_tedge(u, v); add_tedge(v, u); } for (int i = 1; i&lt;=m;i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; add_qedge(u, v, i); add_qedge(v, u, i); } tarjan(s, 0); for (int i = 1;i&lt;=m;i++){ cout &lt;&lt; ans[i]&lt;&lt;endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://izayoisakuye.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}]},{"title":"【图论】最小生成树","slug":"最小生成树","date":"2025-05-18T13:51:14.363Z","updated":"2025-05-18T13:51:36.988Z","comments":true,"path":"2025/05/18/最小生成树/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"最小生成树 定义 生成树：一个连通图的生成树是一个极小的连通子图，包含图中的n个顶点，但只有构成一棵树的n-1条边 最小生成树：对带权图，它的最小生成树即为原图中边权之和最小的生成树 性质 一个连通图可以有多个生成树 所有生成树都包含相同顶点个数和边数 生成树中不存在环，添加一条鞭会构成环 移除生成树中的任意一条边都会导致图的不连通 对于包含个顶点的无向连通图，，生成树包含个顶点和条边，最多包含棵生成树 Prim算法 有一个无向图G，每条边有对应边权，从A顶点开始，寻找一个权值最小的路径使其生成一个极小连通子图 Prim算法即通过加点来构造最小生成树，可以从任何点开始 从A出发，跟A相连的两条路，选权值最小的A-B 此时待选路径有A-F, B-I, B-C, B-G 选择权值最小的路径，即A-F 此时待选路径有B-I, B-C, B-G, F-G, F-E 选择权值最小的路径，即B-I，以此类推 这里我们依次选择了A-B,A-F, B-I, I-C, B-G 此时权值最小的路径为G-F，但如果连上G-F，则形成了环，不符合极小连通子图 选择G-H 最后我们生成了这样的路径，即最小生成树 Prim算法更适合稠密图 (邻接矩阵) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100; const int MAX = 0x7fffffff; typedef char VertexType ; typedef int EdgeType; struct mat_grph{ VertexType vertex[N]; EdgeType arc[N][N]; int vertex_num; int edge_num; }; void create_graph(mat_grph* G){ G-&gt;vertex_num = 9; G-&gt;edge_num = 15; G-&gt;vertex[0] = 'A'; G-&gt;vertex[1] = 'B'; G-&gt;vertex[2] = 'C'; G-&gt;vertex[3] = 'D'; G-&gt;vertex[4] = 'E'; G-&gt;vertex[5] = 'F'; G-&gt;vertex[6] = 'G'; G-&gt;vertex[7] = 'H'; G-&gt;vertex[8] = 'I'; for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ if(i==j) G-&gt;arc[i][j] = 0; else G-&gt;arc[i][j]=MAX; } } G-&gt;arc[0][1] = 10; G-&gt;arc[0][5] = 11; G-&gt;arc[1][2] = 18; G-&gt;arc[1][6] = 16; G-&gt;arc[1][8] = 12; G-&gt;arc[2][3] = 22; G-&gt;arc[2][8] = 8; G-&gt;arc[3][4] = 20; G-&gt;arc[3][6] = 24; G-&gt;arc[3][7] = 16; G-&gt;arc[3][8] = 21; G-&gt;arc[4][5] = 26; G-&gt;arc[4][7] = 7; G-&gt;arc[5][6] = 17; G-&gt;arc[6][7] = 19; // 无向图，把对称的也复制过去 for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[j][i] = G-&gt;arc[i][j]; } } } void prim(mat_grph* G){ int i, j, k; int minn; int weight[N]; // 侯选边 int vex_index[N]; // 表示下标和对应值分别代表的顶点间存在一条连线 // 从顶点A开始 weight[0]=0; // vex_index某点与下标对应点赋值为0 vex_index[0]=0; for (i = 1;i&lt;G-&gt;vertex_num;i++){ weight[i] = G-&gt;arc[0][i]; // 存放第i个节点的待选权值 vex_index[i] = 0; // 都从0开始连接 } for(int i = 1;i&lt;G-&gt;vertex_num;i++){ minn = MAX; j = 0; k = 0; // 从0到9，寻找最小的与之连接 for(j=0;j&lt;G-&gt;vertex_num;j++){ if (weight[j]!=0 &amp;&amp; weight[j]&lt;minn){ minn = weight[j]; k = j; } } cout &lt;&lt; G-&gt;vertex[vex_index[k]]&lt;&lt;\", \"&lt;&lt;G-&gt;vertex[k]&lt;&lt;endl; weight[k]=0; // 该点已被选完，不能再用 // 找新连接点的待选路径 for (j = 0;j&lt;G-&gt;vertex_num;j++){ if (weight[j]!=0 &amp;&amp; G-&gt;arc[k][j]&lt;weight[j]){ weight[j] = G-&gt;arc[k][j]; // 更新备选项 vex_index[j] = k; // 更新前一个节点的下标为新值 } } } } int main(){ mat_grph G; create_graph(&amp;G); prim(&amp;G); return 0; } (邻接表/链式前向星) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 5005, M = 400005; struct Edge { int to, w, next; } edge[M]; // 无向图 开两倍 int head[N], cnt; int dist[N]; // 到生成树的距离 bool vis[N]; // 是否已加入生成树 int parent[N]; // 记录父节点 int n, m, ans; // 链式前向星加边 void add_edge(int u, int v, int w) { edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++; } void prim() { memset(dist, 0x3f, sizeof dist); memset(parent, -1, sizeof parent); dist[1] = 0; ans = 0; for(int i = 1; i &lt;= n; i++) { int u = 0, minn = 0x3f3f3f3f; // 找到距离生成树最近的点 for(int j = 1; j &lt;= n; j++) { if(!vis[j] &amp;&amp; dist[j] &lt; minn) { minn = dist[j]; u = j; } } if(u == 0) break; // 找不到新的点，说明图不连通 vis[u] = true; ans += minn; if (parent[u]!=-1) cout &lt;&lt;parent[u] &lt;&lt;\" \"&lt;&lt;u&lt;&lt;endl; // 非起点输出 // 更新其他点到生成树的距离 for(int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if(!vis[v] &amp;&amp; edge[i].w &lt; dist[v]) { dist[v] = edge[i].w; parent[v]=u; } } } } int main() { memset(head, -1, sizeof(head)); cnt = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u, v, w); add_edge(v, u, w); // 无向图需要加两条边 } prim(); bool check = true; for(int i = 1; i &lt;= n; i++) { if(!vis[i]) { check = false; break; } } if(check) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"orz\" &lt;&lt; endl; return 0; } Kruskal算法 Kruskal算法是通过加边来构建最小生成树的 按边权从小到大排序，最小的是V1-V3 首先判断加入前这两个端点是否在同一个连通分量中，若可以则添加 按边权顺序依次添加V4-V6， V2-V5 此时有两个相同最小边权的情况，证明有多个最小生成树，且都不在同一连通分量，故随便选一个 此时发现，V3与V6已经位于同一连通分量，故不能加边 直到所有点被连通，此时构建了最小生成树 Kruskal算法更适合稀疏图 代码部分使用了并查集来实现判断是否有环 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 5005, M = 400005; struct Edge { int u,v,w; } edge[M]; // 无向图 开两倍 int parent[N]; int n, m, cnt = 0, ans = 0; // 查找操作 int find(int x){ if (parent[x]!=x)parent[x]=find(parent[x]); return parent[x]; } // 合并操作 void merge(int a, int b){ if (find(a)&gt;find(b)) parent[find(a)]=find(b); else parent[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt; m; // 建图，不需要链式前向星 for (int i = 1;i&lt;=m;i++){ int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edge[i] = {x,y,w}; } // 按权值排序 sort(edge+1,edge+m+1, [&amp;](Edge a, Edge b){return a.w&lt;b.w;}); for (int i = 1;i&lt;=n;i++) parent[i]=i; // 自己是自己的 int temp = 0; for (int i = 1;i&lt;=m;i++){ if (find(edge[i].u)==find(edge[i].v)) continue; // 若两者是连通分量则跳过 else{ merge(edge[i].u,edge[i].v); // 建边 temp++; // 记录建的边数 ans+=edge[i].w; // 累加权值 } } if (temp!=n-1) cout &lt;&lt;\"orz\"; // 若建边数不是n-1，则没有生成最小生成树 else cout &lt;&lt; ans ; return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【图论】最短路径","slug":"最短路径","date":"2025-05-18T13:49:50.991Z","updated":"2025-05-18T13:50:57.782Z","comments":true,"path":"2025/05/18/最短路径/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"最短路径 Dijkstra 思路 基本步骤： 选定一个点，满足： 未被选过 距离最短 对这个点的所有邻接点尝试松弛(如下图，从a到c权值为5，而从a到b到c权值为3，我们用后者代替前者成为最短路，此之为成功的松弛) 从a开始，依次寻找下一个节点，使得从a到当前节点的路径最短，直到找到结尾 遍历时，我们依次寻找a到当前节点的最短路径以及最近节点 当我们得到了最短权值，我们可以反推回a从而获取最短路径 用矩阵表示如下 代码 邻接矩阵 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const int mod = 1e9 + 7; vector&lt;vector&lt;int&gt;&gt; G; vector&lt;int&gt; path; vector&lt;int&gt; dijkstra(vector&lt;vector&lt;int&gt;&gt; &amp;G, int s){ int n = G.size(); vector&lt;int&gt; dis(n,0x3f3f3f3f); vector&lt;int&gt; vis(n,0); dis[s] = 0; for (int i = 0;i&lt;n-1;i++){ int node = -1; for (int j = 0;j&lt;n;j++){ if (!vis[j]&amp;&amp;(node==-1||dis[j]&lt;dis[node])){ node = j; } } for (int j = 0;j&lt;n;j++){ if (dis[node]+G[node][j]&lt;dis[j]){ dis[j] = dis[node]+G[node][j]; path[j] = node; } } vis[node] = true; } return dis; } // 路径获取 void get_path(int x, vector&lt;int&gt; &amp;P){ if (!x){ P.push_back(0); return ; } // 若该节点前有节点，则先获取前面节点的内容 if (path[x]!=-1)get_path(path[x], P); P.push_back(x); } void solve() { int n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; path = vector&lt;int&gt;(n,-1); G = vector&lt;vector&lt;int&gt;&gt; (n,vector&lt;int&gt;(n, 0x3f3f3f3f)); for (int i = 0;i&lt;m;i++){ int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u--,v--; if (!G[u][v])G[u][v]=w; else G[u][v]=min(G[u][v],w); } auto dis = dijkstra(G, s-1); for (auto it: dis)cout &lt;&lt; it &lt;&lt;' '; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; } 最小堆优化 上述朴素算法的问题： 寻找最小点时，通过遍历n个点来获得最小点 对该点邻接点进行松弛时，我们也是通过遍历去寻找邻接点 对于以上问题，我们可以选用小根堆与邻接表直接获取，可以实现代码的优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt; using namespace std; #define endl '\\n' vector&lt;int&gt; edge, weight, Next, head; int n, m, s; int idx=0; vector&lt;int&gt; dijkstra(int s){ vector&lt;int&gt; dis(n,0x3f3f3f3f); vector&lt;int&gt; vis(n,0); dis[s]=0; // 最小堆，first记录dis， second记录node priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt;&gt; mh; mh.push({dis[s],0}); while(!mh.empty()){ int node = mh.top().second; mh.pop(); if(vis[node]) continue; for(int i = head[node];~i;i=Next[i]){ if (dis[edge[i]]&gt;dis[node]+weight[i]){ dis[edge[i]]=dis[node]+weight[i]; mh.push({dis[edge[i]],edge[i]}); } } vis[node]=true; } return dis; } void add_edge(int u, int v, int w){ edge[idx] = v; weight[idx] = w; Next[idx] = head[u]; head[u]=idx++; } int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; head = vector&lt;int&gt; (n,-1); edge = weight = Next = vector&lt;int&gt; (m,0); while(m--){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u--,v--; add_edge(u,v,w); } auto dis = dijkstra(s-1); for(auto it:dis) cout &lt;&lt; it &lt;&lt;' '; return 0; } Floyd 思路 Floyd与Dijkstra都是看节点间的值，但是前者看的是每两点间最短距离 Dis数组，记录两点距离： 这里矩阵中每个位置表示两点间的距离，而D上的下标表示从何处中转得到的距离（-1表示不进行中转） 如此时为从进行中转得到的两点间距离，且距离可以根据红色式子表示，即经过中转点后的距离 Path数组，记录经过点 Path数组记录了两点间经过的中转点是哪个点，若为直达则记录终点，如指的是没有中转，其中记录的都是终点，指经过中转，故对应的值为0，表示中转点为 代码 (邻接矩阵) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100; const int M = 200; const int MAX = 0x10000; typedef char VertexType ; typedef int EdgeType; struct mat_grph{ VertexType vertex[N]; EdgeType arc[N][N]; int vertex_num; int edge_num; }; void createGraph(mat_grph* G){ G-&gt;vertex_num = 9; G-&gt;edge_num = 15; for (int i = 0; i&lt;G-&gt;vertex_num;i++){ G-&gt;vertex[i] = i; } for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ if(i==j) G-&gt;arc[i][j] = 0; else G-&gt;arc[i][j]=MAX; } } G-&gt;arc[0][1] = 1; G-&gt;arc[0][2] = 5; G-&gt;arc[1][2] = 3; G-&gt;arc[1][3] = 7; G-&gt;arc[1][4] = 5; G-&gt;arc[2][4] = 1; G-&gt;arc[2][5] = 7; G-&gt;arc[3][4] = 2; G-&gt;arc[3][6] = 3; G-&gt;arc[4][5] = 3; G-&gt;arc[4][6] = 6; G-&gt;arc[4][7] = 9; G-&gt;arc[5][7] = 5; G-&gt;arc[6][7] = 2; G-&gt;arc[6][8] = 7; G-&gt;arc[7][8] = 4; for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0; j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[j][i] = G-&gt;arc[i][j]; } } } void floyd(mat_grph G){ int path[N][N]; int dis[N][N]; for (int i = 0;i&lt;G.vertex_num;i++){ for (int j = 0;j&lt;G.vertex_num;j++){ dis[i][j] = G.arc[i][j]; // 最初的dis数组 path[i][j] = j; // 最初的path数组 } } for (int i = 0;i&lt;G.vertex_num;i++){ for (int j = 0;j&lt;G.vertex_num;j++){ for (int k = 0;k&lt;G.vertex_num;k++){ if(dis[j][k]&gt;dis[j][i]+dis[i][k]){ dis[j][k] = dis[j][i]+dis[i][k]; path[j][k] = path[j][i]; } } } } int k; for (int i = 0; i&lt;G.vertex_num;i++){ for (int j = i+1; j&lt;G.vertex_num;j++){ printf(\"v%d-&gt;v%d weight:%d \", i, j, dis[i][j]); k = path[i][j]; printf(\"path:v%d\", i); while(k!=j){ printf(\"-&gt;v%d\", k); k = path[k][j]; } printf(\"-&gt;v%d\\n\", j); } printf(\"\\n\"); } } int main(){ mat_grph G; createGraph(&amp;G); floyd(G); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【图论】图上BFS/DFS","slug":"图上BFS与DFS","date":"2025-05-18T13:49:15.367Z","updated":"2025-05-18T13:49:40.531Z","comments":true,"path":"2025/05/18/图上BFS与DFS/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E5%9B%BE%E4%B8%8ABFS%E4%B8%8EDFS/","excerpt":"","text":"图上BFS 将BFS扩展到图，从顶点0开始访问，逐层访问其邻居顶点，持续到访问完毕 最后获得序列：按照访问距离离起始顶点最近的所有顶点 按照该序列，访问到每个顶点后，就找到了达到该顶点的最短路径（适用于权值相等） 对相同距离邻居顶点，访问顺序不重要 同样可以使用队列实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100; bool vis[N]; // 访问标记数组 typedef char VertexType ; typedef int EdgeType; queue&lt;int&gt; q; struct mat_grph{ VertexType vertex[N]; EdgeType arc[N][N]; int vertex_num; int edge_num; }; void create_graph(mat_grph* G){ G-&gt;vertex_num = 9; G-&gt;edge_num = 15; G-&gt;vertex[0] = 'A'; G-&gt;vertex[1] = 'B'; G-&gt;vertex[2] = 'C'; G-&gt;vertex[3] = 'D'; G-&gt;vertex[4] = 'E'; G-&gt;vertex[5] = 'F'; G-&gt;vertex[6] = 'G'; G-&gt;vertex[7] = 'H'; G-&gt;vertex[8] = 'I'; for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[i][j] = 0; } } G-&gt;arc[0][1] = 1; G-&gt;arc[0][5] = 1; G-&gt;arc[1][2] = 1; G-&gt;arc[1][6] = 1; G-&gt;arc[1][8] = 1; G-&gt;arc[2][3] = 1; G-&gt;arc[2][8] = 1; G-&gt;arc[3][4] = 1; G-&gt;arc[3][6] = 1; G-&gt;arc[3][7] = 1; G-&gt;arc[3][8] = 1; G-&gt;arc[4][5] = 1; G-&gt;arc[4][7] = 1; G-&gt;arc[5][6] = 1; G-&gt;arc[6][7] = 1; // 无向图，把对称的也复制过去 for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[j][i] = G-&gt;arc[i][j]; } } } void bfs(mat_grph &amp;G){ int i = 0; vis[i]=1; cout &lt;&lt; G.vertex[i]&lt;&lt;endl; q.push(i); while(!q.empty()){ i = q.front(); q.pop(); for (int j = 0;j&lt;G.vertex_num;j++){ if (!(vis[j])&amp;&amp;G.arc[i][j]==1){ vis[j] = 1; cout &lt;&lt; G.vertex[j]&lt;&lt;endl; q.push(j); } } } } int main(){ mat_grph G; create_graph(&amp;G); memset(vis, 0, sizeof vis); bfs(G); return 0; } 图上DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100; bool vis[N]; // 访问标记数组 typedef char VertexType ; typedef int EdgeType; struct mat_grph{ VertexType vertex[N]; EdgeType arc[N][N]; int vertex_num; int edge_num; }; void create_graph(mat_grph* G){ G-&gt;vertex_num = 9; G-&gt;edge_num = 15; G-&gt;vertex[0] = 'A'; G-&gt;vertex[1] = 'B'; G-&gt;vertex[2] = 'C'; G-&gt;vertex[3] = 'D'; G-&gt;vertex[4] = 'E'; G-&gt;vertex[5] = 'F'; G-&gt;vertex[6] = 'G'; G-&gt;vertex[7] = 'H'; G-&gt;vertex[8] = 'I'; for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[i][j] = 0; } } G-&gt;arc[0][1] = 1; G-&gt;arc[0][5] = 1; G-&gt;arc[1][2] = 1; G-&gt;arc[1][6] = 1; G-&gt;arc[1][8] = 1; G-&gt;arc[2][3] = 1; G-&gt;arc[2][8] = 1; G-&gt;arc[3][4] = 1; G-&gt;arc[3][6] = 1; G-&gt;arc[3][7] = 1; G-&gt;arc[3][8] = 1; G-&gt;arc[4][5] = 1; G-&gt;arc[4][7] = 1; G-&gt;arc[5][6] = 1; G-&gt;arc[6][7] = 1; // 无向图，把对称的也复制过去 for (int i = 0;i&lt;G-&gt;vertex_num;i++){ for (int j = 0;j&lt;G-&gt;vertex_num;j++){ G-&gt;arc[j][i] = G-&gt;arc[i][j]; } } } void dfs(mat_grph &amp;G, int i){ vis[i] = 1; cout &lt;&lt; G.vertex[i]&lt;&lt;endl; for (int j = 0;j&lt;G.vertex_num;j++){ // 寻找邻接矩阵中和第i个顶点间有边的顶点 if ((!vis[j]) &amp;&amp; G.arc[i][j]==1){ // 如果没被访问过且存在边，则从其对应的顶点开始搜索与其有边的顶点 dfs(G, j); } } } int main(){ mat_grph G; create_graph(&amp;G); memset(vis, 0, sizeof vis); dfs(G, 0); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【图论】图","slug":"图","date":"2025-05-18T13:48:42.547Z","updated":"2025-05-18T13:49:03.725Z","comments":true,"path":"2025/05/18/图/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E5%9B%BE/","excerpt":"","text":"图 定义 由顶点的有穷非空集合和顶点间的边的集合组成的 通常记为G(v,e)，G表示一个图，v是G中顶点集合，e是边的集合 即V(G)和E(G)分别成为G的点集和边集 必须有顶点，但可以没有边 无向图与有向图 有向图用有序对表示，视为集合上的一个二元关系 无向图用无序对表示，视为集合上的对称二元关系，即必有 简单图与多重图 简单图： 图中不能有顶点到自身的边 同一条便在途中不能出现两次及以上 不满足上述条件的成为多重图 完全图 具有最多边数的图 对于一个具有n个顶点的无向完全图，边数量的最大值为 对于一个具有n个顶点的有向完全图，边数量的最大值为 路径与路径长度 路径：从一个顶点开始，经过一系列的边到达另一个顶点形成的顶点序列 路径长度：路径上边的条数 回路（环）：起点与终点相同的路径 简单路径：如果路径中不出现相同顶点，则成为简单路径 简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路 度 对于无向图，顶点的度指的是与顶点相关联边的数目 入度：有向图中，箭头指向顶点v的边的数目 出度：有向图中，从该顶点出发的边的数目 与边的关系： 图中所有顶点度之和等于边数的两倍 对于有向图，所有顶点的出度与入度之和相等，弧数量也相等 子图 图G的子图H，满足是子集且是子集 连通图 连通图：在无向图中，如果顶点v到顶点w有路径，则称顶点v到顶点w是连通的。如果对于图中任意两个顶点都是连通的，则称此图为连通图 极大连通子图：在这个子图中任意两个顶点都是连通的，而且不能通过添加更多顶点或边来扩大这种连通性 连通分量：无向图中的极大连通子图称为连通分量 强连通图：在有向图中，对于每一对顶点v和w，从v到w和从w到v都有路径，则称该有向图是强连通图。 强连通分量：有向图中的极大强连通子图称为有向图的强连通分量 生成树 含有图中全部顶点的极小联通子树 包含所有顶点n，但只有足以构成一棵树的n-1条边 边权和网 权：在一个图中，每条边可以标注上一个代表某种含义的数值，该数值称为这个边的权值 网：边上带权值的图，也称为带权图 例 若无向图中含有七个顶点，要保证图G在任何情况下连通，则需要边数最少是 即6个顶点的最多边数+1即为7个顶点最少边数 用公式","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【图论】拓扑排序","slug":"拓扑排序","date":"2025-05-18T13:47:51.501Z","updated":"2025-05-18T13:48:15.409Z","comments":true,"path":"2025/05/18/拓扑排序/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"拓扑排序 节点的度 度：与节点相连的边的条数 入度：有向图中，指向当前节点的边的条数 出度：有向图中，从当前节点发出的边的条数 AOV网 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先级，这样的有向图为顶点表示活动的网，称为AOV(Activity On Vertex Network)网 定义 将一个有向无环图G的所有顶点排成一个线性序列，使得有向无环图G的边集中的任意一条边&lt;u,v&gt;，始终满足u出现在v的前面 构造 在有向无环图中找到一个没有前驱（入度为0）的节点入栈 将栈顶节点出栈，然后从图中将此节点删除，并删除以该节点为尾的弧 重复操作 如果所有节点都已经输出，则结束，否则重复1 实现(邻接矩阵) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 1000; const int mod = 1e9 + 7; int g[N][N], indgr[N], res[N]; void topsort(int n){ int k =0; for (int i =1;i&lt;=n;i++){ for (int j = 1;j&lt;=n;j++){ // 寻找入度为0的点 if(!indgr[j]){ res[i]=j; // 记录已经处理的点 indgr[j]--; // 删除入读为0的点 k=j; break; } } for (int j = 1;j&lt;=n;j++){ if (g[k][j]==1){ g[k][j]=0; // 删除对应边 可省略，因为拓扑排序只看入度 indgr[j]--; // 入读-1 } } } } void solve() { // 视频中第一个例题 int n, m; while(~scanf(\"%d %d\", &amp;n, &amp;m)){ int x, y; memset(indgr, 0, sizeof indgr); memset(g, 0, sizeof g); for (int i = 1;i&lt;=m;i++){ scanf(\"%d %d\",&amp;x,&amp;y); if (!g[x][y]) { g[x][y]=1; indgr[y]++; } topsort(n); for (int i = 1;i&lt;=n;i++){ if (i&lt;n) printf(\"%d \", res[i]); else printf(\"%d\\n\", res[i]); } } } } int main() { //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; } 注意： 编号大的节点优先输出：寻找入度0的点时倒序遍历 如何判断有环：不存在入度为0的点 实现(邻接表) 对于稀疏图，使用邻接矩阵会浪费大量空间，我们可以使用邻接表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt; using namespace std; // 邻接表节点结构 struct node{ int x; // 节点编号 int w; // 权值 node* next; node(int x_, int w_){ this-&gt;x = x_; this-&gt;w = w_; next = nullptr; } }; vector&lt;node*&gt; head; // 邻接表头节点数组 vector&lt;int&gt; in_degree; // 记录每个节点的入度 // 添加有向边 void add_edge(int u, int v, int w){ node* a = head[u]; node* b = new node(v,w); b-&gt;next = a-&gt;next; a-&gt;next = b; in_degree[v]++; // 目标节点入度加1 } // 拓扑排序 vector&lt;int&gt; topological_sort(int n) { vector&lt;int&gt; result; // 存储拓扑序列结果 queue&lt;int&gt; q; // 存储入度为0的节点 // 将所有入度为0的节点入队 for(int i = 1; i &lt;= n; i++) { if(in_degree[i] == 0) { q.push(i); } } // 不断取出入度为0的节点，更新其邻接点的入度 while(!q.empty()) { int cur = q.front(); q.pop(); result.push_back(cur); // 将当前节点加入结果序列 // 遍历当前节点的所有邻接点 node* p = head[cur]-&gt;next; while(p) { in_degree[p-&gt;x]--; // 将邻接点的入度减1 // 如果入度减为0，则入队 if(in_degree[p-&gt;x] == 0) { q.push(p-&gt;x); } p = p-&gt;next; } } return result; } int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; // 输入节点数和边数 // 初始化 head.resize(n+1); in_degree.resize(n+1, 0); for(int i = 0; i &lt;= n; i++){ head[i] = new node(i,0); } // 输入边的信息 for (int i = 0; i &lt; m; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u,v,w); } // 执行拓扑排序 vector&lt;int&gt; topo = topological_sort(n); // 判断是否存在环并输出结果 if(topo.size() &lt; n) { cout &lt;&lt; \"图中存在环，无法进行拓扑排序\" &lt;&lt; endl; } else { for(int x : topo) { cout &lt;&lt; x &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0; } 关键路径 AOE网 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动持续时间，这种有向图的边表示活动的网，称为AOE（Activity On Edge Network）网 ETV与LTV ETV：表示事件最早发生的时间(earliest time of vertex) 注意：考虑到多线程操作，事件最早发生时间应该是多个同步事件完成时间的最大值 LTV：表示事件最晚发生的时间(latest time of vertex) 注意：同理，事件最晚发生时间应该是减去多个同步事件完成时间后的最小值","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【算法】倍增","slug":"倍增","date":"2025-05-18T13:45:21.571Z","updated":"2025-05-18T13:45:42.235Z","comments":true,"path":"2025/05/18/倍增/","permalink":"https://izayoisakuye.github.io/2025/05/18/%E5%80%8D%E5%A2%9E/","excerpt":"","text":"倍增 问题引入 Q1: 给定一个正数x，已知x一定可用m个二进制位表示，从高位到低位打印x每一位的状态 从数二进制位左往右第i位计算1&lt;&lt;i，让原数与其相减，若结果小于0则不减，并将该位状态标记为0，若大于0则减去，并将该位状态标记为1 如数101，二进制为0001100101， 1&lt;&lt;9为512&gt;101，不减，第九位状态为0 1&lt;&lt;8为256&gt;101，不减，第八位状态为0 1&lt;&lt;7为128&gt;101，不减，第七位状态为0 1&lt;&lt;6为64&lt;101，减成37，第六位状态为1 1&lt;&lt;5为25&lt;32，减成5，第五位状态为1 以此类推 Q2: 给定一个正数x，打印&lt;=x的最大的2的幂是2的几次方，注意防溢出 若x=13，则最接近13，输出3 若x=16，则最接近16，输出4 溢出：若x非常接近INT_MAX，则每次从时很有可能溢出 解决方案：当时就让p++ 1234567int q2(int x){ int power = 0; while(1&lt;&lt;power)&lt;=(x&gt;&gt;1){ power++; } return power; } 倍增算法 线段上有n个点，给定每个点i往右边跳1步能最远覆盖的点jump[i] 已知从任意点出发都能到达最后的点，并且在i&lt;j时，必定有jump[i]&lt;=jump[j] 如何构建一张表可以查询从任意点i出发，任意跳步，最远能到达的点 如何快速计算任意两点之间，最少跳几步能到达 如该表，行代表p，表示次方内对应点是否能到达，列代表点i 初始jump[i]填入第一列，即st[i][0]=jump[i]，后面列的填充满足转移方程st[i][p]=st[st[i][p-1]][p-1]，即跳内能到达的可以转化为从跳内能到达 该表列最多列 这就是ST表，我们利用ST表从x到y跳跃的过程中，先从最大步长开始，每次减少一半尝试，最后得到答案 假设计算17到77至少要多少步 我们知道至多需要60步，而60可以用六个二进制位表示 从左往右，让17往右跳步，看对应数值大于还是小于77，大于则该位标0，小于则标1，且将步数转为49 最后需要的是逼近77的结果，如最后到达了73，再加一步就能到达77 例-倍增跳跃 P4155 [SCOI2015] 国旗计划 题意：给定m个点，编号1-m，所有点围城一个环，i号点顺时针到达i+1号点，最终m号点顺时针回到1号点 给定n条线段，每条线段(a,b)表示线段顺时针从a到b 保证所有线段可以把整个环覆盖，且线段间可能重合但一定互不包含 返回长度为n的结果数组ans，ans[x]表示一定选x号线段下，至少选几条线段能覆盖整个环 我们将环展开成条进行计算，即每次寻找包含在内且尽量靠右的线段跳跃，寻找离转一圈后的起始点所在的最近的线段 如从A开始，需要经过A-&gt;B-&gt;D才能到达10(2)点，故需要三条线段覆盖 构建时只需要看第i个点所在线段的末尾是哪个即可，表示一步内从i可以跳到末尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const int mod = 1e9 + 7; struct node{ int idx; int s,e; }line[2*N]; int n, m, power; vector&lt;vector&lt;int&gt;&gt; st; vector&lt;int&gt; ans; // 将环状展开为线性 int lgp(int n){ int ans = 0; while((1&lt;&lt;ans)&lt;=(n&gt;&gt;1)){ ans++; } return ans; } void build(){ /*如C(6,1),m=8 * 有1 2 3 4 5 6 7 8 9 10 11 ... 1 2 3... 故转化后的C是(6,9) */ for (int i = 1;i&lt;=n;i++){ if (line[i].s&gt;line[i].e){ line[i].e+=m; } } // 按起始点排序 sort(line+1,line+1+n,[&amp;](const node a, const node b){return a.s&lt;b.s;}); // 对点在线性上进行复制即 A B C D A' B' C' D' for(int i =1;i&lt;=n;i++){ line[i+n].idx = line[i].idx; line[i+n].s = line[i].s+m; line[i+n].e = line[i].e+m; } // 新线段数量 int e = n&lt;&lt;1; // 寻找跳一步的最大值, 应满足下一条线段开头&lt;=当前线段结尾 /*如线段开头如下 3 34 56 89 102 到102就超过了结尾，故选择到89 */ for (int i =1, j = 1;i&lt;=e;i++){ while(j+1&lt;=e&amp;&amp;line[j+1].s&lt;=line[i].e){ j++; } st[i][0]=j; } // 倍增 for (int p = 1; p&lt;=power; p++){ for (int i = 1;i&lt;=e;i++){ st[i][p]=st[st[i][p-1]][p-1]; } } } int jump(int i){ // i号线段的目标点是line[i].s+m int tar = line[i].s+m,cur = i, next, ans = 1; for(int p = power; p&gt;=0;p--){ next = st[cur][p]; if (next!=0&amp;&amp;line[next].e&lt;tar){ ans+=1&lt;&lt;p; cur = next; } } return ans+1; // 计算的是小于目标点，+1即为到达 } void solve() { cin &gt;&gt; n &gt;&gt; m; for(int i =1;i&lt;=n;i++){ line[i].idx = i; cin &gt;&gt; line[i].s &gt;&gt; line[i].e; } power = lgp(n); st = vector&lt;vector&lt;int&gt;&gt;(2*n+1, vector&lt;int&gt;(power+1,0)); ans = vector&lt;int&gt;(n+1,0); build(); for (int i = 1;i&lt;=n;i++){ ans[line[i].idx] = jump(i); } for (int i = 1;i&lt;=n;i++) cout &lt;&lt; ans[i]&lt;&lt;' '; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; } 例-RMQ问题 P2880 [USACO07JAN] Balanced Lineup G 仍然构造一个st表，表示覆盖范围内对应的最大值 对于状态转移，每次的最大值一定在前一个区间()与当前区间() 对于查询，寻找最接近区间长度的一个2的p次幂，取从起点往后跳长度与从终点往前跳长度两者最大值的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,m; vector&lt;vector&lt;int&gt;&gt; dp1; vector&lt;vector&lt;int&gt;&gt; dp2; int query1(int l, int r){ int j = (int)log2(r-l+1); return max(dp1[l][j],dp1[r-(1&lt;&lt;j)+1][j]); } int query2(int l, int r){ int j = (int)log2(r-l+1); return min(dp2[l][j],dp2[r-(1&lt;&lt;j)+1][j]); } int main() { ios cin &gt;&gt; n &gt;&gt; m; dp1 = vector&lt;vector&lt;int&gt;&gt; (n,vector&lt;int&gt;(log2(n)+5,0)); dp2 = vector&lt;vector&lt;int&gt;&gt; (n,vector&lt;int&gt;(log2(n)+5,0)); vector&lt;int&gt; arr(n); for (int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; for (int i = 0;i&lt;n;i++) { dp1[i][0] = arr[i]; dp2[i][0] = arr[i]; } for (int j = 1;j&lt;=log2(n);j++){ for (int i = 0; i+(1&lt;&lt;j)-1&lt;n;i++){ dp1[i][j] = max(dp1[i][j-1],dp1[i+(1&lt;&lt;(j-1))][j-1]); dp2[i][j] = min(dp2[i][j-1],dp2[i+(1&lt;&lt;(j-1))][j-1]); } } int l,r ; while (m--){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query1(l-1,r-1)-query2(l-1,r-1)&lt;&lt;endl; } return 0; } 树上倍增 在树结构中也可以实现倍增查找某节点任意层祖先 建立每个节点的深度表 使用st[i][p]指代节点i往上走步来到哪个祖先，其中st[i][0]是i的父节点 则倍增思想可得st[i][p]=st[st[i][p-1]][p-1] 此时给定任意节点，就可以快速查询i节点的祖先中位于第s层的祖先节点编号 适用范围 适用于可重复贡献问题 即若A与B区间有可能重叠的部分，但不影响A+B区间的答案 如RMQ，gcd，按位与，按位或等都可以使用st表高效解决 优势：构建过程复杂度，单次查询 劣势：静态维护，需要空间大，维护信息有限","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【Python】CS61A——Efficiency","slug":"CS61A——Efficiency","date":"2025-05-18T13:40:12.513Z","updated":"2025-05-18T13:46:48.385Z","comments":true,"path":"2025/05/18/CS61A——Efficiency/","permalink":"https://izayoisakuye.github.io/2025/05/18/CS61A%E2%80%94%E2%80%94Efficiency/","excerpt":"","text":"Efficiency Memorization 使用记忆化优化斐波那契数组 memo函数用来记录已经计算过的数，当有相同计算需求时直接赋值 count函数记录调用函数次数（包括递归） 123456789101112131415161718192021222324def fib(n): if n==0 or n==1: return n else: return fib(n-2)+fib(n-1) def count(f): def counted(n): counted.call_count +=1 return f(n) counted.call_count = 0 return counted def memo(f): cache={} def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized fib = count(fib) counted_fib =fib fib = memo(fib) fib = count(fib) print(fib(30)) print(\"origin:\", fib.call_count, \"memorized:\", counted_fib.call_count) 832040 origin: 59 memorized: 31 Exponentiation 优化指数运算至 以下显示了进行优化后的算法在不同数据量下的运行时间图，呈现对数曲线趋势 12345678910111213141516171819202122%matplotlib inline import matplotlib.pyplot as plt plt.style.use('ggplot') plt.rc('font', size = 16) from timeit import repeat from numpy import median, percentile def plot_times(name, xs, n=15): f = lambda x: name+'('+str(x)+')' g = globals() samples = [] for _ in range(n): times = lambda x: repeat(f(x), globals = g, number = 1, repeat = n) samples.append([median(times(x)) for x in xs]) ys = [10e3*median(sample) for sample in zip(*samples)] plt.figure(figsize=(8, 8)) plt.plot(xs, ys) plt.xlabel('n') plt.ylabel('ms') 12345678910def exp_fast(b,n): if n==0: return 1 elif n%2==0: return square(exp_fast(b,n//2)) else: return b*exp_fast(b, n-1) def square(x): return x*x 12exp_2_fast = lambda n: exp_fast(2.0, n) plot_times('exp_2_fast', range(20, 1600, 10)) Order of Growth Notation 时间复杂度常用大O与大表示法表示 - 大O描述了运行时间上限 - 大则对同时表示了上限与下限 常见的时间复杂度表示（大O与大自行替换符号）： - 指数增长： - 二次增长： - 线性增长： - 对数增长： - 常数增长： Space Active environment: - 正在被调用的函数的环境 - 函数的父函数在活动环境中（即嵌套函数内层调用时） python会自动检测非活动环境并将其回收","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Composition","slug":"CS61A——Composition","date":"2025-05-18T13:40:12.511Z","updated":"2025-05-18T13:42:37.082Z","comments":true,"path":"2025/05/18/CS61A——Composition/","permalink":"https://izayoisakuye.github.io/2025/05/18/CS61A%E2%80%94%E2%80%94Composition/","excerpt":"","text":"Composition Linked List 用Python实现链表 - 每个节点由first与rest组成，前者表示值，后者表示链接的剩余链表 - 将每个节点当作一堆二元组看待 - 最后一个节点指向空链表Link.empty，使用类属性表示 - 构造方式：Link(3, Link(4, Link(5, Link.empty))) ### 创建链表 123456789101112131415class Link: # 使用空元组实现空节点，类属性 empty = () def __init__(self, first, rest=empty): # 判断rest是否是空节点或是一个Link类 assert rest is Link.empty or isinstance(rest, Link) self.first = first self.rest = rest s = Link(3, Link(4, Link(5))) print(s.first) print(s.rest.first) print(s.rest.rest.first) print(s.rest.rest.rest is Link.empty) 操作列表 实现如下行为：range, map, filter 我们使用递归实现 12345678910111213141516171819202122232425262728class Link: # 使用空元组实现空节点，类属性 empty = () def __init__(self, first, rest=empty): # 判断rest是否是空节点或是一个Link类 assert rest is Link.empty or isinstance(rest, Link) self.first = first self.rest = rest def range_link(start, end): if start&gt;=end: return Link.empty else: return Link(start, range_link(start+1, end)) def map_link(f, s): if s is Link.empty: return s else: return Link(f(s.first), map_link(f, s.rest)) def filter_link(f, s): if s is Link.empty: return s filter_rest = filter(f, s.rest) if f(s.first): return Link(s.first, filter_rest) else: return filter_rest 链表的改变 可以通过对属性赋值来改变链表的first和rest属性 12345678&gt;&gt;&gt; s = Link(1, Link(2, Link(3))) &gt;&gt;&gt; s.first = 5 &gt;&gt;&gt; t = s.rest &gt;&gt;&gt; t.rest = s; &gt;&gt;&gt; s.first 5 &gt;&gt;&gt; s.rest.rest.rest.rest.rest.first 2 此赋值将s的后段与前段相接，创建了一个循环链表 插入节点 向一个有序链表中添加节点，保证链表仍有序 123456789def add(s, v): assert s is not Link.empty if s.first &gt; v: s.first, s.rest = v, Link(s.first, s.rest) elif s.first &lt; v and s.rest is Link.empty: s.rest = Link(v) elif s.first &lt; v: add(s.rest, v) return s Tree Class 使用类实现树 ### 创建树 1234567891011121314151617181920212223class Tree: def __init__(self, label, branches = []): self.label = label for branch in branches: assert isinstance(branch, Tree) self.branches = list(branches) def __repr__(self): if self.branches: branches_str = ', '+ repr(self.branches) else: branch_str = '' return 'Tree({0}{1})'.format(repr(self.label), branch_str) def __str__(self): return '\\n'.join(self.indented()) def indented(self): lines = [] for b in self.branches: for line in b.indented(): lines.append(' '+line) return [str(self.label)] + lines def is_leaf(self): return not self.branches 实现一些操作 如下代码实现了创建斐波那契树以及输出叶子节点 1234567891011121314151617def fib_tree(n): if n==0 or n==1: return Tree(n) else: left = fib_tree(n-2) right = fib_tree(n-1) fib_n = left.label + right.label return Tree(fib_n, [left, right]) def leaves(t): if t.is_leaf(): return [t.label] else: all_leaves = [] for b in t.branches: all_leaves.extend(leaves(b)) return all_leaves 剪枝 12345# 通过每次重新构建branches列表，将等于n的值排除在列表外以实现 def prune(t, n): t.branches = [b for b in t.branches if b.label!=n] for b in t.branches: prune(b, n)","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Representations","slug":"CS61A——Representations","date":"2025-05-18T13:40:12.509Z","updated":"2025-05-18T13:42:24.851Z","comments":true,"path":"2025/05/18/CS61A——Representations/","permalink":"https://izayoisakuye.github.io/2025/05/18/CS61A%E2%80%94%E2%80%94Representations/","excerpt":"","text":"Representations String Representations 字符串用来表达语言与程序 Python中，有两种字符串表达 - str：对人类可读 - repr：对解释器刻可读 这两种一般相同，但也有不同之处 ### repr String for an Object repr函数返回一个python表达式(字符串)，该表达式会评估为一个等同的对象 对一个对象的repr调用eval会给你一个与原始对象等价的对象 调用repr的结果与在python交互界面输出的结果相同 str String for an Object str函数接受任何对象，返回一个字符串，字符串是原始对象的人类可以解释的表示 对表达式调用str的结果与调用print时输出的结果相同 F-strings String Interpolation 字符串插值包括对一些含有表达式的字符串字面量求值 - 可以使用+进行字符串连接实现 'pi starts with'+str(pi)+'...' - 也可以使用f-string功能实现字符串插值 f'pi starts with {pi}' 花括号中的将会作为表达式看待并给出计算结果 f-string的计算结果包括str string和子表达式的值 Polymorphic Functions 多态函数是一种适用于多种数据类型的函数 如str和repr函数都是多态函数，它们接受任何类型的对象 原理：repr调用了一个零参数方法__repr__以便在参数上获取他返回的repr字符串 str同样调用一个 零参数方法__str__ 对于repr函数： - repr函数内部只调用了一个名为repr的类属性，而实例属性__repr__被忽略了 - 实现如下： 12def repr(x): return type(x).__repr__(x) 对于str函数： - 实例属性__str__被忽略了 - 若类上根本没有__str__属性，则调用str只会返回repr返回的内容 Interface 对象传递信息的方式：通过互相查找属性或方法 属性的查找规则允许不同数据类型通过具有相同属性名称来响应相同信息 共享信息：在许多不同类上引起相似行为的属性名称 接口：一组共享信息与一些规范（表示其含义） 如实现__repr__与__str__的类实现了一个接口，一下是用类来展示该接口的代码 123456789class Ratio: def __init__(self, n, d): self.numer = n self.denom = d def __repr__(self): return 'Ratio({0}, {1})'.format(self.numer, self.denom) def __str__(self): return '{0}/{1}'.format(self.numer, self.denom) 当我们令half = Ratio(1,2)，直接打印half，输出为可读版本，而直接在解释器展示half，就会输出python表达式 Special Method Names python中，以两个下划线包围的名字表示它们具有某种内置行为 - __init__：构造对象时会自动调用的方法 - __repr__：将对象以python表达式的方式输出，在交互式python界面时用于显示值的方法 - __add__：用于将一个对象加入另一个对象 - __bool__：用于将一个对象转换为布尔值 - __float__：用于将一个对象转换为实数 同时，以下代码实现了将两个对象相加 1234567891011121314151617181920212223242526272829class Ratio: def __init__(self, n, d): self.numer = n self.denom = d def __repr__(self): return 'Ratio({0}, {1})'.format(self.numer, self.denom) def __str__(self): return '{0}/{1}'.format(self.numer, self.denom) def __add__(self, other): if isinstance(other, int): n = self.numer+self.denom*other d = self.denom elif isinstance(other, Ratio): n = self.numer*other.denom +self.denom*other.numer d = self.denom*other.denom elif isinstance(other, float): return float(self)+other g = gcd(n,d) return Ratio(n//g, d//g) __radd__ = __add__ def __float__(self): return self.numer/self.denom def gcd(n, d): while n!=d: n, d = min(n, d), abs(n-d) return n","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Inheritance","slug":"CS61A——Inheritance","date":"2025-05-18T13:40:12.507Z","updated":"2025-05-18T13:42:09.258Z","comments":true,"path":"2025/05/18/CS61A——Inheritance/","permalink":"https://izayoisakuye.github.io/2025/05/18/CS61A%E2%80%94%E2%80%94Inheritance/","excerpt":"","text":"Inheritance 继承是将多个类关联起来的一种方法 当两个类相似时，可以使用继承，相似的类可能具有与通用类相同的所有属性，外加自带的特殊属性 语法： 12class &lt;name&gt;(&lt;base class&gt;): &lt;suite&gt; 通过该语句创建的子类与其基类共享所有属性，子类可能会覆盖某些继承的属性，但未更改的保持不变 当编写子类是，只需要指出其与基类不同之处即可 ## 例 创建一个支票账户(CheckingAccount)类，作为账户(Account)类的子类 12345678910111213# 类的继承 class CheckingAccount(Account): \"\"\"A bank account that charges for withdrawals\"\"\" withdraw_fee = 1 interest = 0.01 def withdraw(self, amount): return Account.withdraw(self, amount + self.withdraw_fee) ch = CheckingAccount('Tom') print(ch.interest) ch.deposit(20) ch.withdraw(5) print(ch.balance) 此处我们在Account类的基础上修改了interest属性与withdraw方法，而其余属性与方法可以继续使用 在类上寻找属性名称 基类属性不会复制到子类中，确保了未经修改的属性与基类保持一致，在类中寻找名称遵循如下规则 - 如果名称为类中的属性，则返回属性值 - 若不在，在其基类中寻找该名称 面向对象设计 在进行面向对象编程时，建议遵循如下原则 - 不要重复复制粘贴已经存在的，而是利用已经存在的实现 - 已被覆盖的属性仍需要通过类来访问 如以上代码，在计算提款时最佳方式是查找实例本身上的withdraw_fee 这样，如果当前实例有一个特定的withdraw_fee，我们就使用它，否则使用Account类中的 继承与组合 继承最适合is-a关系，如支票账户是(is a)账户的特定类型，故适合使用继承 组合最适合has-a关系，如一个银行具有(has a)有一组他管理的账户，该组账户是它的一个属性，而不会继承 12345678910111213141516171819202122class Bank: \"\"\"a bank has accounts\"\"\" def __init__(self): self.accounts=[] # 账户列表 def open_account(self, holder, amount, kind = Account): account = kind(holder) # 创建某种类型的账户 account.deposit(amount) # 存入amount的钱 self.accounts.append(account) # 将创建的账户加入当前银行的账户列表 return account def pay_interest(self): # 计算列表中的利息 for a in self.accounts: a.deposit(a.balance*a.interest) bank = Bank() john = bank.open_account('john', 10) jack = bank.open_account('jack', 5, CheckingAccount) bank.pay_interest() print(jack.balance) print(john.balance) 多重继承 一个子类可以有多个基类 其中，这里直接调用父类account_holder时，使用super()实现了超类调用，防止破坏多重继承的调用逻辑 12345678910# 类的多重继承 class SavingsAccount(Account): deposit_fee = 2 def deposit(self, amount): return Account.deposit(self, amount-self.deposit_fee) class GoodAccount(CheckingAccount, SavingsAccount): def __init__(self, account_holder): super().__init__(account_holder) self.holder = account_holder self.balance = 1","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Decomposition","slug":"CS61A——Decomposition","date":"2025-05-18T13:40:12.503Z","updated":"2025-05-18T13:41:45.505Z","comments":true,"path":"2025/05/18/CS61A——Decomposition/","permalink":"https://izayoisakuye.github.io/2025/05/18/CS61A%E2%80%94%E2%80%94Decomposition/","excerpt":"","text":"Decomposition Modular Design 程序的设计原则：将程序的不同部分分离开来，使得每个模块可以独立开发与测试 以以下餐厅搜索代码为例，实现从文件中读取评分与评论（使用similarity评估相似性）搜索对应评分前k个餐厅去过的其他餐厅的功能： 12345678910111213141516171819202122232425262728293031323334353637383940def search(query, ranking = lambda r: -r.stars): results =[r for r in Restaurant.all if query in r.name] return sorted(results, key= ranking) def reviewed_both(r, s): return len([x for x in r.reviewers if x in s.reviewers]) class Restaurant: all = [] def __init__(self, name, star, reviewer): self.name = name self.star = star self.reviewer = reviewer Restaurant.all.append(self) def similar(self, k, similarity=reviewed_both): \"\"\"Return the k most similar restaurants to self\"\"\" others = Restaurant.all others.remove(self) different = lambda r: -similarity(r, self) return sorted(others, key=different)[:k] def __repr__(self): return '&lt;'+self.name+'&gt;' import json reviewers_for_restaurant = {} for line in open('reviews.json'): r = json.loads(line) biz = r['business_id'] if biz not in reviewers_for_restaurant: reviewers_for_restaurant[biz] = [r['user_id']] else: reviewers_for_restaurant[biz].append(r['user_id']) for line in open('restaurant.json'): r = json.loads(line) reviewers = reviewers_for_restaurant[r['business_id']] Restaurant(r['name'], r['stars'], reviewers) results = search('Thai') for r in results: print(r,'share reviewer with', r.similar(3)) 优化时间复杂度 12345678910111213def reviewed_both(r, s): return fast_overlap(r.reviewers, s.reviewers) def fast_overlap(s, t): count, i, j = 0, 0, 0 while i&lt;len(s) and j&lt;len(t): if s[i]==t[j]: count, i, j = count+1, i+1, j+1; elif s[i]&lt;t[i]: i+=1 else: j+=1 return count","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【图论】邻接表","slug":"邻接表","date":"2025-04-13T14:13:48.711Z","updated":"2025-05-18T13:47:34.428Z","comments":true,"path":"2025/04/13/邻接表/","permalink":"https://izayoisakuye.github.io/2025/04/13/%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"邻接表 邻接矩阵 给如下一个有向图： 该图有四个节点，五条边。右侧表示了有向图的起点，终点以及边权 根据该图建立邻接矩阵： 可以发现，邻接矩阵中许多位置并没有使用，故浪费了空间与时间 邻接表 让起点与终点直接相连，而不考虑先后顺序 将终点和边权作为一个节点，按头插法插入每个起点位置，就构建了一个邻接表 链表实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt; using namespace std; struct node{ int x; // 节点编号 int w; // 某个顶点到x的权值 node* next; node(int x_, int w_){ this-&gt;x = x_; this-&gt;w = w_; next = nullptr; } }; vector&lt;node*&gt; head; void add_edge(int u, int v, int w){ node* a = head[u]; // 现在的头 node* b = new node(v,w); // 建立新的节点 // 头插法 b-&gt;next = a-&gt;next; a-&gt;next = b; } int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; head.resize(n+1); for(int i = 0;i&lt;=n;i++){ head[i] = new node(i,0); } for (int i = 0; i&lt;=m;i++){ int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u,v,w); } // 遍历 for (int i = 1;i&lt;=n;i++){ node* p = head[i]-&gt;next; // 从某个节点开始，指向其相邻节点并输出 while(p){ // 起点总是i，而i连接的所有节点均为其兄弟 printf(\"(%d, %d, %d)\",i,p-&gt;x,p-&gt;w); p = p-&gt;next; } cout &lt;&lt; endl; } return 0; } 数组实现 建立四个数组 edge[i]：表示索引为i的边的终点，大小为m next[i]：表示索引为i的边的下一条兄 弟边的索引，大小为m head[i]：表示i的第一条边的索引，大小为n weigh[i]：表示索引为i的权重，大小为m 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; head, edge, Next, weight; int idx = 0; // 表示边的索引 void add_edge(int u, int v, int w){ edge[idx] = v; weight[idx]= w; Next[idx] = head[u]; head[u]=idx++; } int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; head.resize(n+1,-1); edge.resize(m+1); Next.resize(m+1); weight.resize(m+1); for (int i = 0; i&lt;=m;i++){ int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u,v,w); } // 遍历 for (int i = 1;i&lt;=n;i++){ for (int j = head[i]; ~j; j=Next[j]){ int u = i; int v = edge[j]; int w = weight[j]; printf(\"(%d, %d, %d)\", u, v, w); } cout &lt;&lt; endl; } return 0; } 链式前向星 图的多种表示 输入数据模式 1234564 5 1 4 9 4 3 8 1 2 5 2 4 6 1 3 7 平面图 邻接矩阵 邻接表 数组实现 用一个数组与一个结构体： head数组，大小为顶点个数，保存边的下标，初始化为-1，表示从i出发没有边 edge结构体，大小为边个数，元素表示终点、距离与下一条边的位置 如输入1 4 9，表示从1出发，终点为4，距离为9 检查是否有从1出发的边，没有(-1)，next改为-1，此时第一条边从1出发，将head[1]=1 再输入4 3 8 检查是否有从4出发的边，没有(-1)，next改为-1，此时第二条边从4出发，将head[4]=2 再输入1 2 5 检查是否有从1出发的边，head[1]=1，next改为1，此时第三条边也从1出发，将head[1]=3 再输入2 4 6 检查是否有从2出发的边，没有(-1)，next改为-1，此时第四条边从2出发，将head[2]=4 再输入1 3 7 检查是否有从1出发的边，head[1]=3，next改为3，此时第五条边也从1出发，将head[1]=5 最终为 即实现了头插法 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const int mod = 1e9 + 7; int n, m, s, u, v, w, cnt; int head[100005]; struct edge{ int to, dis, nxt; }edge[200005]; void Add_edge(int from, int to, int w){ edge[++cnt].to = to; edge[cnt].dis = w; edge[cnt].nxt = head[from]; head[from]=cnt; } void solve() { cin &gt;&gt; n &gt;&gt; m; fill(head, head+n+1,-1); for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; Add_edge(u,v,w); } // 遍历 for (int i = 1;i&lt;=n;i++){ for (int k = head[i];~k;k = edge[k].nxt){ /*具体处理*/ } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; } 十字链表 十字链表分为两部分： 顶点节点存储权值、入度(firstIn)与出度(firstOut)；弧节点存储弧尾顶点在顶点数组中的位置(tailVex)，弧头顶点在顶点数组中的位置(headVex)，指向弧头相同的下一条弧(hLink)，指向弧尾相同的下一条弧(tLink)与边权(Info) 每个节点组成了两个链表：以当前节点为弧头的弧组成的链表、以当前节点为弧尾的弧组成的链表 在寻找时自己找自己，即若为弧头组成链表，则依次寻找弧头相同的组成链表(firstIn-&gt;headVex)；若为弧尾组成链表，则依次寻找弧尾相同的组成链表(firstOut-&gt;tailVex) 邻接多重表 邻接多重表分为两部分： 顶点节点存储权值与指向的第一条跟该顶点有关系的边 表节点： mark：标志域，标记某节点是否已经被操作过，例如遍历各节点时，为0表示还未遍历，为1表示遍历过 ivex与jvex：表示节点表示的边两端的顶点在数组中的位置下标 ilink与jlink：表示指向下一条与ivex，jvex相关的边 info：边的权值 邻接多重表也遵循自己找自己，但比起十字链表更加灵活（两节点位置可互换），思路与十字链表类似","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"【Python】CS61A——Homework5","slug":"CS61A——Homework5","date":"2025-04-04T02:35:57.153Z","updated":"2025-04-04T02:36:54.077Z","comments":true,"path":"2025/04/04/CS61A——Homework5/","permalink":"https://izayoisakuye.github.io/2025/04/04/CS61A%E2%80%94%E2%80%94Homework5/","excerpt":"","text":"Homework 5 Q1: Infinite Hailstone 写一个生成器函数来生成从n开始的冰雹猜想序列，当到达序列尾后，生成器会一直声称1 123456789101112131415161718def hailstone(n): \"\"\"Q1: Yields the elements of the hailstone sequence starting at n. At the end of the sequence, yield 1 infinitely. &gt;&gt;&gt; hail_gen = hailstone(10) &gt;&gt;&gt; [next(hail_gen) for _ in range(10)] [10, 5, 16, 8, 4, 2, 1, 1, 1, 1] &gt;&gt;&gt; next(hail_gen) 1 \"\"\" yield n if n==1: n=1 elif n%2==0: n=int(n/2) else: n=3*n+1 yield from hailstone(n) 使用递归，结合yield from生成迭代器 Q2: Merge 写一个merge函数，传入两个无限生成器a,b按照给定起始位置与步长生成非重复上升序列，返回一个生成器包含两个生成器中的所有元素，且去重 12345678910111213141516171819202122232425def merge(a, b): \"\"\"Q2: &gt;&gt;&gt; def sequence(start, step): ... while True: ... yield start ... start += step &gt;&gt;&gt; a = sequence(2, 3) # 2, 5, 8, 11, 14, ... &gt;&gt;&gt; b = sequence(3, 2) # 3, 5, 7, 9, 11, 13, 15, ... &gt;&gt;&gt; result = merge(a, b) # 2, 3, 5, 7, 8, 9, 11, 13, 14, 15 &gt;&gt;&gt; [next(result) for _ in range(10)] [2, 3, 5, 7, 8, 9, 11, 13, 14, 15] \"\"\" gene_a = next(a) gene_b = next(b) while True: if gene_a == gene_b: yield gene_a gene_a = next(a) gene_b = next(b) elif gene_a&gt; gene_b: yield gene_b gene_b = next(b) else: yield gene_a gene_a = next(a) Q3: Yield Paths 定义一个生成器函数，传入一棵树与一个值v，返回生成器从树的根到含有v的节点的每一条路径 123456789101112131415161718192021222324252627282930313233343536373839def yield_paths(t, value): \"\"\"Q4: Yields all possible paths from the root of t to a node with the label value as a list. &gt;&gt;&gt; t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)]) &gt;&gt;&gt; print_tree(t1) 1 2 3 4 6 5 5 &gt;&gt;&gt; next(yield_paths(t1, 6)) [1, 2, 4, 6] &gt;&gt;&gt; path_to_5 = yield_paths(t1, 5) &gt;&gt;&gt; sorted(list(path_to_5)) [[1, 2, 5], [1, 5]] &gt;&gt;&gt; t2 = tree(0, [tree(2, [t1])]) &gt;&gt;&gt; print_tree(t2) 0 2 1 2 3 4 6 5 5 &gt;&gt;&gt; path_to_2 = yield_paths(t2, 2) &gt;&gt;&gt; sorted(list(path_to_2)) [[0, 2], [0, 2, 1, 2]] \"\"\" if label(t) == value: yield [value] for b in branches(t): for p in yield_paths(b, value): yield [label(t)]+p If our current label is equal to value, we’ve found a path from the root to a node containing value containing only our current label, so we should yield that. From there, we’ll see if there are any paths starting from one of our branches that ends at a node containing value. If we find these “partial paths” we can simply add our current label to the beginning of a path to obtain a path starting from the root. In order to do this, we’ll create a generator for each of the branches which yields these “partial paths”. By calling yield_paths on each of the branches, we’ll create exactly this generator! Then, since a generator is also an iterable, we can iterate over the paths in this generator and yield the result of concatenating it with our current label.","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab5","slug":"CS61A——Lab5","date":"2025-04-04T02:35:24.045Z","updated":"2025-04-04T02:36:23.471Z","comments":true,"path":"2025/04/04/CS61A——Lab5/","permalink":"https://izayoisakuye.github.io/2025/04/04/CS61A%E2%80%94%E2%80%94Lab5/","excerpt":"","text":"WWPD部分省略 Q2: Insert Items 实现一个函数，传入列表，一个值before，一个值after，在列表中每个等于before的之后插入after 1234567891011121314151617181920212223242526272829303132def insert_items(s, before, after): \"\"\"Insert after into s after each occurrence of before and then return s. &gt;&gt;&gt; test_s = [1, 5, 8, 5, 2, 3] &gt;&gt;&gt; new_s = insert_items(test_s, 5, 7) &gt;&gt;&gt; new_s [1, 5, 7, 8, 5, 7, 2, 3] &gt;&gt;&gt; test_s [1, 5, 7, 8, 5, 7, 2, 3] &gt;&gt;&gt; new_s is test_s True &gt;&gt;&gt; double_s = [1, 2, 1, 2, 3, 3] &gt;&gt;&gt; double_s = insert_items(double_s, 3, 4) &gt;&gt;&gt; double_s [1, 2, 1, 2, 3, 4, 3, 4] &gt;&gt;&gt; large_s = [1, 4, 8] &gt;&gt;&gt; large_s2 = insert_items(large_s, 4, 4) &gt;&gt;&gt; large_s2 [1, 4, 4, 8] &gt;&gt;&gt; large_s3 = insert_items(large_s2, 4, 6) &gt;&gt;&gt; large_s3 [1, 4, 6, 4, 6, 8] &gt;&gt;&gt; large_s3 is large_s True \"\"\" idx = 0 while idx&lt;len(s): if s[idx]==before: s.insert(idx+1,after) idx+=1 idx+=1 return s 注意： 在before==after时，可能会一直在相同元素后添加相同元素，导致死循环 需要在每次相等时手动让idx向后移动一位 且需要判断长度防止死循环 Q3: Group By 实现函数，传入列表s与函数fn，返回一个字典 字典的值为s的元素，键为fn(e)，且对相同fn(e)的的元素在同一个列表中 123456789101112131415161718def group_by(s, fn): \"\"\"Return a dictionary of lists that together contain the elements of s. The key for each list is the value that fn returns when called on any of the values of that list. &gt;&gt;&gt; group_by([12, 23, 14, 45], lambda p: p // 10) {1: [12, 14], 2: [23], 4: [45]} &gt;&gt;&gt; group_by(range(-3, 4), lambda x: x * x) {9: [-3, 3], 4: [-2, 2], 1: [-1, 1], 0: [0]} \"\"\" grouped = {} for val in s: key = fn(val) if key in grouped: grouped[key].append(val) else: grouped[key] = [val] return grouped 遍历s，计算key值，若存在则直接添加到key对应val的列表中，若无则创建列表并填入该值 Q5: Count Occurrences 实现一个函数，传入一个迭代器t，整数n和值x，返回前n个t中和x相等的的数值的个数 注意：在t上调用next n次，确保至少在t中有n个元素 12345678910111213141516171819202122232425262728def count_occurrences(t, n, x): \"\"\"Return the number of times that x is equal to one of the first n elements of iterator t. &gt;&gt;&gt; s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; count_occurrences(s, 10, 9) 3 &gt;&gt;&gt; t = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; count_occurrences(t, 3, 10) 2 &gt;&gt;&gt; u = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5]) &gt;&gt;&gt; count_occurrences(u, 1, 3) # Only iterate over 3 1 &gt;&gt;&gt; count_occurrences(u, 3, 2) # Only iterate over 2, 2, 2 3 &gt;&gt;&gt; list(u) # Ensure that the iterator has advanced the right amount [1, 2, 1, 4, 4, 5, 5, 5] &gt;&gt;&gt; v = iter([4, 1, 6, 6, 7, 7, 6, 6, 2, 2, 2, 5]) &gt;&gt;&gt; count_occurrences(v, 6, 6) 2 \"\"\" cnt = 0 times = 0 while cnt&lt;n: if next(t)== x: times+=1 cnt+=1 return times 注意提前跳出循环一次，防止迭代器到尾后返回traceback Q6: Repeated 实现函数，传入迭代器t与一个大于1的整数k，返回t中第一个连续出现k次的元素 12345678910111213141516171819202122232425262728293031def repeated(t, k): \"\"\"Return the first value in iterator t that appears k times in a row, calling next on t as few times as possible. &gt;&gt;&gt; s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; repeated(s, 2) 9 &gt;&gt;&gt; t = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; repeated(t, 3) 8 &gt;&gt;&gt; u = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5]) &gt;&gt;&gt; repeated(u, 3) 2 &gt;&gt;&gt; repeated(u, 3) 5 &gt;&gt;&gt; v = iter([4, 1, 6, 6, 7, 7, 8, 8, 2, 2, 2, 5]) &gt;&gt;&gt; repeated(v, 3) 2 \"\"\" assert k &gt; 1 pre = 0 cnt = 0 while True: cur = next(t) if cur == pre: cnt+=1 else: cnt=1 pre = cur if cnt == k: return cur 一开始想用两个迭代器，但是不会复制 每次调用迭代器的next值，并保存前一个值，每次比较 若前后相同，则计数重复+1，否则还原为1（自身重复一次） Q7: Sprout Leaves 传入一颗树，与新的叶子节点，使该树延伸出对应叶子节点，通过print_tree输出 如t = tree(1, [tree(2), tree(3, [tree(4)])]) 12345 1 / \\ 2 3 | 4 调用sprout_leaves(t, [5, 6])后打印出树如下 1234567 1 / \\ 2 3 / \\ | 5 6 4 / \\ 5 6 123456789101112131415161718192021222324252627282930313233343536def sprout_leaves(t, leaves): \"\"\"Sprout new leaves containing the labels in leaves at each leaf of the original tree t and return the resulting tree. &gt;&gt;&gt; t1 = tree(1, [tree(2), tree(3)]) &gt;&gt;&gt; print_tree(t1) 1 2 3 &gt;&gt;&gt; new1 = sprout_leaves(t1, [4, 5]) &gt;&gt;&gt; print_tree(new1) 1 2 4 5 3 4 5 &gt;&gt;&gt; t2 = tree(1, [tree(2, [tree(3)])]) &gt;&gt;&gt; print_tree(t2) 1 2 3 &gt;&gt;&gt; new2 = sprout_leaves(t2, [6, 1, 2]) &gt;&gt;&gt; print_tree(new2) 1 2 3 6 1 2 \"\"\" if is_leaf(t): return tree(label(t), [tree(leaf) for leaf in leaves]) return tree(label(t), [sprout_leaves(s, leaves) for s in branches(t)]) Q8: Partial Reverse 实现函数，传入列表s与起始元素start，将start到列表末尾的元素反转 1234567891011121314151617def partial_reverse(s, start): \"\"\"Reverse part of a list in-place, starting with start up to the end of the list. &gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7] &gt;&gt;&gt; partial_reverse(a, 2) &gt;&gt;&gt; a [1, 2, 7, 6, 5, 4, 3] &gt;&gt;&gt; partial_reverse(a, 5) &gt;&gt;&gt; a [1, 2, 7, 6, 5, 3, 4] \"\"\" end = len(s)-1 while start &lt; end: s[start], s[end] = s[end], s[start] start+=1 end-=1 使用序列解包，交换两个元素可以通过a,b=b,a实现","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab6","slug":"CS61A——Lab6","date":"2025-04-04T02:35:08.303Z","updated":"2025-04-04T02:36:31.842Z","comments":true,"path":"2025/04/04/CS61A——Lab6/","permalink":"https://izayoisakuye.github.io/2025/04/04/CS61A%E2%80%94%E2%80%94Lab6/","excerpt":"","text":"Lab 6 Q1: Bank Account 扩充Account类，添加属性transaction，即一个transaction列表实例，每一次调用都会创建一个该实例，记录每次调用deposit和withdraw前后的余额。另外，每个transaction有一个id属性，记录之前账户对deposit或withdraw的调用次数。id对于每个账户内是唯一的，而不是在所有transaction中的全局标识符 transaction有两个方法： changed：若在调用前后balance发生变化则返回True，否则返回False report：返回一个字符串用来描述该次transaction，以id开始，之后返回消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class Transaction: def __init__(self, id, before, after): self.id = id self.before = before self.after = after def changed(self): \"\"\"Return whether the transaction resulted in a changed balance.\"\"\" if self.before == self.after: return False else : return True def report(self): \"\"\"Return a string describing the transaction. &gt;&gt;&gt; Transaction(3, 20, 10).report() '3: decreased 20-&gt;10' &gt;&gt;&gt; Transaction(4, 20, 50).report() '4: increased 20-&gt;50' &gt;&gt;&gt; Transaction(5, 50, 50).report() '5: no change' \"\"\" msg = 'no change' if self.changed(): if self.before &gt; self.after: msg = 'decreased ' + str(self.before)+'-&gt;'+str(self.after) else : msg = 'increased ' + str(self.before) + '-&gt;' + str(self.after) return str(self.id) + ': ' + msg class Account: \"\"\"A bank account that tracks its transaction history. &gt;&gt;&gt; a = Account('Eric') &gt;&gt;&gt; a.deposit(100) # Transaction 0 for a 100 &gt;&gt;&gt; b = Account('Erica') &gt;&gt;&gt; a.withdraw(30) # Transaction 1 for a 70 &gt;&gt;&gt; a.deposit(10) # Transaction 2 for a 80 &gt;&gt;&gt; b.deposit(50) # Transaction 0 for b 50 &gt;&gt;&gt; b.withdraw(10) # Transaction 1 for b 40 &gt;&gt;&gt; a.withdraw(100) # Transaction 3 for a 'Insufficient funds' &gt;&gt;&gt; len(a.transactions) 4 &gt;&gt;&gt; len([t for t in a.transactions if t.changed()]) 3 &gt;&gt;&gt; for t in a.transactions: ... print(t.report()) 0: increased 0-&gt;100 1: decreased 100-&gt;70 2: increased 70-&gt;80 3: no change &gt;&gt;&gt; b.withdraw(100) # Transaction 2 for b 'Insufficient funds' &gt;&gt;&gt; b.withdraw(30) # Transaction 3 for b 10 &gt;&gt;&gt; for t in b.transactions: ... print(t.report()) 0: increased 0-&gt;50 1: decreased 50-&gt;40 2: no change 3: decreased 40-&gt;10 \"\"\" # *** YOU NEED TO MAKE CHANGES IN SEVERAL PLACES IN THIS CLASS *** def __init__(self, account_holder): self.balance = 0 self.holder = account_holder self.counter = -1 self.transactions = [] def id_gene(self): self.counter+=1 yield self.counter def deposit(self, amount): \"\"\"Increase the account balance by amount, add the deposit to the transaction history, and return the new balance. \"\"\" pre = self.balance self.balance = self.balance + amount self.transactions.append(Transaction(next(self.id_gene()),pre, self.balance)) return self.balance def withdraw(self, amount): \"\"\"Decrease the account balance by amount, add the withdraw to the transaction history, and return the new balance. \"\"\" if amount &gt; self.balance: self.transactions.append(Transaction(next(self.id_gene()), self.balance, self.balance)) return 'Insufficient funds' pre = self.balance self.balance = self.balance - amount self.transactions.append(Transaction(next(self.id_gene()), pre, self.balance)) return self.balance Q2: Email 一个邮箱系统包括三个类：Email, Server, Client Client类可以compose邮件，该邮件会被send到Server类中 Server类会把该邮件运到对应Client的inbox中，为了实现这个，一个Server类拥有一个字典clients，将Email中的recipient_name与拥有该名称的Client对象绑定 注意：client永远不会更改其使用的server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Email: \"\"\"An email has the following instance attributes: msg (str): the contents of the message sender (Client): the client that sent the email recipient_name (str): the name of the recipient (another client) \"\"\" def __init__(self, msg, sender, recipient_name): self.msg = msg self.sender = sender self.recipient_name = recipient_name class Server: \"\"\"Each Server has one instance attribute called clients that is a dictionary from client names to client objects. \"\"\" def __init__(self): self.clients = {} def send(self, email): \"\"\"Append the email to the inbox of the client it is addressed to.\"\"\" self.clients[email.recipient_name].inbox.append(email) def register_client(self, client): \"\"\"Add a client to the dictionary of clients.\"\"\" self.clients[client.name] = client class Client: \"\"\"A client has a server, a name (str), and an inbox (list). &gt;&gt;&gt; s = Server() &gt;&gt;&gt; a = Client(s, 'Alice') &gt;&gt;&gt; b = Client(s, 'Bob') &gt;&gt;&gt; a.compose('Hello, World!', 'Bob') &gt;&gt;&gt; b.inbox[0].msg 'Hello, World!' &gt;&gt;&gt; a.compose('CS 61A Rocks!', 'Bob') &gt;&gt;&gt; len(b.inbox) 2 &gt;&gt;&gt; b.inbox[1].msg 'CS 61A Rocks!' &gt;&gt;&gt; b.inbox[1].sender.name 'Alice' \"\"\" def __init__(self, server, name): self.inbox = [] self.server = server self.name = name server.register_client(self) def compose(self, message, recipient_name): \"\"\"Send an email with the given message to the recipient.\"\"\" email = Email(message, self, recipient_name) self.server.send(email) 这里的inbox存储的是每一个email实例，故传参时应传入self Q3: Make Change 实现make_change函数，输入amount和coins字典 coins字典的键是一个正整数，表示面额；值也是一个正整数，表示硬币数量，如{1:4, 5:2}表示四个便士和两个五分 函数返回列表，其中元素是求和能达到amount数量的硬币列表，其中每种面额k最多使用coins[k]次 1234567891011121314151617181920212223242526272829303132333435363738394041def make_change(amount, coins): \"\"\"Return a list of coins that sum to amount, preferring the smallest coins available and placing the smallest coins first in the returned list. The coins argument is a dictionary with keys that are positive integer denominations and values that are positive integer coin counts. &gt;&gt;&gt; make_change(2, {2: 1}) [2] &gt;&gt;&gt; make_change(2, {1: 2, 2: 1}) [1, 1] &gt;&gt;&gt; make_change(4, {1: 2, 2: 1}) [1, 1, 2] &gt;&gt;&gt; make_change(4, {2: 1}) == None True &gt;&gt;&gt; coins = {2: 2, 3: 2, 4: 3, 5: 1} &gt;&gt;&gt; make_change(4, coins) [2, 2] &gt;&gt;&gt; make_change(8, coins) [2, 2, 4] &gt;&gt;&gt; make_change(25, coins) [2, 3, 3, 4, 4, 4, 5] &gt;&gt;&gt; coins[8] = 1 &gt;&gt;&gt; make_change(25, coins) [2, 2, 4, 4, 5, 8] \"\"\" if not coins: return None smallest = min(coins) rest = remove_one(coins, smallest) if amount &lt; smallest: return None elif amount == smallest: return [smallest] else: temp = make_change(amount-smallest, rest) if not temp: return make_change(amount, rest) else : return [smallest]+temp 首先尝试使用最小面额的coin，但若无法实现则尝试使用更大面额 具体步骤： 进入函数默认使用一个最小面额硬币 若amount==samllest：最小面额硬币即可满足需求，返回包含该值的列表 否则，递归调用make_change(amount-smallest, rest)，减去一次最小面额 若返回一个列表，则将该最小面额放入列表，并继续递归调用，将其返回的列表接在后面 若返回None，则表明使用最小面额无法实现，故递归调用make_change(amount, rest)，让函数把最小面额硬币去除后使用更大面额尝试 Q4: Change Machine 完成ChangeMachine类中的change方法，每个该类的实例包含了一些coins，一开始都是便士。change方法传入正整数coin，把他添加到coins中，并返回列表，其中的硬币面额之和要达到cin 该类倾向于使用尽可能多的最小面额硬币 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class ChangeMachine: \"\"\"A change machine holds a certain number of coins, initially all pennies. The change method adds a single coin of some denomination X and returns a list of coins that sums to X. The machine prefers to return the smallest coins available. The total value in the machine never changes, and it can always make change for any coin (perhaps by returning the coin passed in). The coins attribute is a dictionary with keys that are positive integer denominations and values that are positive integer coin counts. &gt;&gt;&gt; m = ChangeMachine(2) &gt;&gt;&gt; m.coins == {1: 2} True &gt;&gt;&gt; m.change(2) [1, 1] &gt;&gt;&gt; m.coins == {2: 1} True &gt;&gt;&gt; m.change(2) [2] &gt;&gt;&gt; m.coins == {2: 1} True &gt;&gt;&gt; m.change(3) [3] &gt;&gt;&gt; m.coins == {2: 1} True &gt;&gt;&gt; m = ChangeMachine(10) # 10 pennies &gt;&gt;&gt; m.coins == {1: 10} True &gt;&gt;&gt; m.change(5) # takes a nickel &amp; returns 5 pennies [1, 1, 1, 1, 1] &gt;&gt;&gt; m.coins == {1: 5, 5: 1} # 5 pennies &amp; a nickel remain True &gt;&gt;&gt; m.change(3) [1, 1, 1] &gt;&gt;&gt; m.coins == {1: 2, 3: 1, 5: 1} True &gt;&gt;&gt; m.change(2) [1, 1] &gt;&gt;&gt; m.change(2) # not enough 1's remaining; return a 2 [2] &gt;&gt;&gt; m.coins == {2: 1, 3: 1, 5: 1} True &gt;&gt;&gt; m.change(8) # cannot use the 2 to make 8, so use 3 &amp; 5 [3, 5] &gt;&gt;&gt; m.coins == {2: 1, 8: 1} True &gt;&gt;&gt; m.change(1) # return the penny passed in (it's the smallest) [1] &gt;&gt;&gt; m.change(9) # return the 9 passed in (no change possible) [9] &gt;&gt;&gt; m.coins == {2: 1, 8: 1} True &gt;&gt;&gt; m.change(10) [2, 8] &gt;&gt;&gt; m.coins == {10: 1} True &gt;&gt;&gt; m = ChangeMachine(9) &gt;&gt;&gt; [m.change(k) for k in [2, 2, 3]] [[1, 1], [1, 1], [1, 1, 1]] &gt;&gt;&gt; m.coins == {1: 2, 2: 2, 3: 1} True &gt;&gt;&gt; m.change(5) # Prefers [1, 1, 3] to [1, 2, 2] (more pennies) [1, 1, 3] &gt;&gt;&gt; m.change(7) [2, 5] &gt;&gt;&gt; m.coins == {2: 1, 7: 1} True \"\"\" def __init__(self, pennies): self.coins = {1: pennies} def change(self, coin): \"\"\"Return change for coin, removing the result from self.coins.\"\"\" self.coins[coin] = self.coins.get(coin, 0)+1 result = make_change(coin, self.coins) for c in result: self.coins = remove_one(self.coins, c) return result 将加入的coin放入coins字典，注意，这里的键为面额对应数量，而值为面额，故我们用get方法获取传入coin的键，并在此基础上+1（我们可以在第二个参数设置默认值，当没有对应面额时，get会返回设定值而非None） 之后调用make_change方法，获得最小面额能实现达到coin数的硬币列表 使用remove_one将类中已经用过的硬币移除 返回列表","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Attributes","slug":"CS61A——Attributes","date":"2025-03-30T09:21:41.234Z","updated":"2025-03-30T09:22:16.435Z","comments":true,"path":"2025/03/30/CS61A——Attributes/","permalink":"https://izayoisakuye.github.io/2025/03/30/CS61A%E2%80%94%E2%80%94Attributes/","excerpt":"","text":"Attributes Class Attributes 语法： 12class &lt;name&gt;: &lt;suite&gt; class声明将会创建一个新类并将其绑定到&lt;name&gt;上，作为当前环境的第一个作用域 类语句内部，赋值语句和def语句创建类属性，此时它们作为类属性放入类中，而非在作用域中 当class声明执行时，内部语句才会执行 类属性在类的所有实例之间共享 这样我们不必在每个创建的实例中存储此值，而只需要在类中存储一次 123456789101112131415class Account: interest = 0.02 # 类属性 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): self.balance = self.balance + amount return self.balance tom = Account('Tom') jim = Account('Jim') print(tom.interest) print(jim.interest) 0.02 0.02 Attribute Lookup By Name 表达式提供对象，名称提供要查找的属性名称 但通过name查找将会查找多个位置，这取决于点表达式： - 首先执行点左侧表达式，生成该对象 - &lt;name&gt;与该对象的实例属性匹配，如果存在该名称的属性，则返回值 - 如果没有找到，则在该对象的类中查找（类属性） - 返回的值是整个表达式的值，除非是一个函数，函数将会返回一个绑定的方法，对象填充为self By Function 使用getatter函数，可以用属性名的字符串来查找对应属性 使用hasatter函数，可以判断是否具有该属性 getatter函数与点表达式查询方式相同 在对象中查询属性可能会返回实例属性或类属性之一 Attribute Assignment 左侧有点表达式的赋值语句会影响点表达式对应对象的属性 - 如果对象是一个实例，则赋值将设置一个实例属性 - 如果对象是一个类，则赋值将设置一个类属性 12tom.interest = 0.08 Account.interest = 0.04 第一个语句将会在tom实例中寻找interest属性，没有找到，则在其中添加该属性 第二个语句将会在Account类中寻找interest属性，找到后将值修改为对应值 Method Calls 方法可使用点表达式调用 其中表达式可以是任何有效的python表达式 表达式的值是通过该表达式值对象中查找&lt;name&gt;而计算的属性值 1tom.deposit(10) Bound Methods Terminlology 所有对象都有属性，均为name-value二元组 类是对象的一种， 故类也有属性 实例属性：一个实例的属性 类属性：类本身的属性，但仍可以从实例访问 python中函数也是对象 绑定方法也是对象，即第一个参数为self的函数，该参数已经绑定到了一个实例 点表达式执行那些类属性是函数的绑定方法 Methods and Functions python区分方法与函数 - 函数是从一开始就定义的 - 绑定方法在方法被调用时将一个函数和其对象绑定起来， 即Object+Function = Bound Method 12print(type(Account.deposit)) print(type(tom.deposit)) &lt;class 'function'&gt; &lt;class 'method'&gt; 此时我们有两种方法调用 1. 作为函数调用，此时需要传递self和amount两个参数 2. 作为绑定方法调用，此时只需要传递amount参数 12Account.deposit(tom, 1001) tom.deposit(1007) 2008","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Objects","slug":"CS61A——Objects","date":"2025-03-30T09:21:41.231Z","updated":"2025-03-30T09:22:04.003Z","comments":true,"path":"2025/03/30/CS61A——Objects/","permalink":"https://izayoisakuye.github.io/2025/03/30/CS61A%E2%80%94%E2%80%94Objects/","excerpt":"","text":"Objects OOP(Object-Oriented Programming) 类(class) 定义了某种类型的多个对象该如何表现 ### 对象(object) 类的一个实例，决定该类的类型 ### 方法(method) 在对象上调用的函数，使用点(.)调用 注意 方法不同于函数在于方法特定于对应对象 ### 蕴含理念 将复杂的大型程序组织成小的模块化组件 - 使用数据抽象 - 捆绑多个信息与相关行为 使用分散状态的计算 - 每个对象有自己的本地状态 - 每个对象也知道如何管理自己的本地状态 - 使用方法与对象交互 - 几个对象可能属于一个共同类的实例 - 不同的类可以相互关联 例：Lists 内置的list函数其实是一个类 在可迭代对象上调用list可以创建一个list类的新实例 list类定义了有关list的各种用法： - 方法：append, extend, insert ,etc. - 加法与乘法运算 - 元素查找与赋值 123print(list) s = list(range(3)) print(type(s)) &lt;class 'list'&gt; &lt;class 'list'&gt; Class Statement 一个类描述了其实例的行为 例如，我们定义一个银行账户类，实现的功能如下： 12345678910111213141516171819202122232425class Account: # 一个类以class开头，并给他命名 def __init__(self, account_holder): ''' 定义创建类的新实例时会发生什么，即给予对象属性 一般使用方法名__init__来构造一个类的实例，调用时自动执行, 该方法有时也被称为构造方法 将新实例称为self，并给它分配属性，其中，account_holder是调用时传入的内容 ''' self.balance = 0 self.holder = account_holder def deposit(self, amount): ''' deposit方法调用两个参数 self： self是该方法被调用时的类的实例 amount：添加的余额 ''' self.balance = self.balance + amount return self.balance # 出现输出时的情况，若没有return则返回None def withdraw(self, amount): if amount &gt; self.balance: # 引用balance时要加.,因为其是对象的一个属性 return 'Insufficient funds' self.balance = self.balance - amount return self.balance Creating Instances Object Construction 当一个类被调用时: - 创建一个该类的新的实例 - __init__方法被调用，其中以新对象作为其中的第一个元素, 一般命名为self, 并带有在调用表达式中的任何额外参数 123a = Account('Alan') print(a.holder) print(a.balance) Alan 0 Instance Attributes 对象的属性可以通过点号表达式(.)来访问与更改 若属性之前不存在, 也可以为其赋值, 可以在任何时候增加新的属性 12345a.balance = 12 # 已存在的属性可以被更改 b = Account('Ada') b.balance = 20 a.backup = b # 新属性可以在任何时候添加 print(a.backup.balance) 20 Object Identity 每个用户定义类的对象都有一个唯一的标识 标识运算符is与is not可以判断两个表达式是否是相同的对象 使用赋值将一个对象绑定到一个新名称时不会创建一个新对象 1234print(a is a) print(a is not b) c = a print(a is c) True True True Methods Invoking Methods 调用方法意味着用点表达式定义类中定义的一个方法 所有调用方法都通过self变量访问对象,所以他们可以访问与操作对象的属性 如deposit方法中定义了两个参数, 但点表达式会自动为方法提供第一个参数 12tom = Account('Tom') print(tom.deposit(100)) # 调用时只需要一个参数, 方法会自动绑定到self(这里是tom) 100","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Homework4","slug":"CS61A——Homework4","date":"2025-03-28T13:47:43.737Z","updated":"2025-04-04T02:36:49.208Z","comments":true,"path":"2025/03/28/CS61A——Homework4/","permalink":"https://izayoisakuye.github.io/2025/03/28/CS61A%E2%80%94%E2%80%94Homework4/","excerpt":"","text":"Homework 4 Sequence Q1: Deep Map 写一个函数deep_map，使得传入的列表s（s可能是嵌套列表）中的每一个元素替换为该元素传入函数f后的返回值 每一个元素包括嵌套列表中的每一个元素 提示：type(a)==list会返回True如果a是列表 12345678910111213141516171819202122232425262728def deep_map(f, s): \"\"\"Replace all non-list elements x with f(x) in the nested list s. &gt;&gt;&gt; six = [1, 2, [3, [4], 5], 6] &gt;&gt;&gt; deep_map(lambda x: x * x, six) &gt;&gt;&gt; six [1, 4, [9, [16], 25], 36] &gt;&gt;&gt; # Check that you're not making new lists &gt;&gt;&gt; s = [3, [1, [4, [1]]]] &gt;&gt;&gt; s1 = s[1] &gt;&gt;&gt; s2 = s1[1] &gt;&gt;&gt; s3 = s2[1] &gt;&gt;&gt; deep_map(lambda x: x + 1, s) &gt;&gt;&gt; s [4, [2, [5, [2]]]] &gt;&gt;&gt; s1 is s[1] True &gt;&gt;&gt; s2 is s1[1] True &gt;&gt;&gt; s3 is s2[1] True \"\"\" for i in range(len(s)): if type(s[i])==list: deep_map(f,s[i]) else: s[i]=f(s[i]) 遍历列表下标i，如果发现内部有嵌套列表，就递归进入遍历嵌套列表，若当前位置为一般元素，则调用函数并将结果替换 Data Abstraction 要用到的ADT Mobile：一种悬挂雕像 一个mobile一定有一个左arm和一个右arm 一个arm有一个正数大小的长度，且尾端一定挂着一个mobile或一个planet 一个planet有一个正数大小的质量，且没有东西挂在上面 Q2: Mass 补充完成构造器planet与选择器mass 使得每一格planet用一个二元列表表示：['planet', mass] 其中total_mass函数可以用来计算一个planet或一个mobile的质量 123456789def planet(mass): \"\"\"Construct a planet of some mass.\"\"\" assert mass &gt; 0 return ['planet', mass] def mass(p): \"\"\"Select the mass of a planet.\"\"\" assert is_planet(p), 'must call mass on a planet' return p[1] 按照提示构造即可 Q3: Balanced 实现balanced函数，判断m是否是一个”balanced mobile” “balanced mobile”的定义如下： 左arm的扭矩等于右arm的扭矩，其中扭矩为左arm的长度与挂在左arm上的质量之积 挂在arm尾端的mobile自身为balanced mobile，planet自身也是balanced的 提示：使用total_mass函数，选择器函数，不要逾越ADT的屏障 1234567891011121314151617181920212223242526def balanced(m): \"\"\"Return whether m is balanced. &gt;&gt;&gt; t, u, v = examples() &gt;&gt;&gt; balanced(t) True &gt;&gt;&gt; balanced(v) True &gt;&gt;&gt; p = mobile(arm(3, t), arm(2, u)) &gt;&gt;&gt; balanced(p) False &gt;&gt;&gt; balanced(mobile(arm(1, v), arm(1, p))) False &gt;&gt;&gt; balanced(mobile(arm(1, p), arm(1, v))) False &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # checking for abstraction barrier violations by banning indexing &gt;&gt;&gt; check(HW_SOURCE_FILE, 'balanced', ['Index']) True \"\"\" if is_planet(m): return True else: torque_left = length(left(m))*total_mass(end(left(m))) torque_right = length(right(m))*total_mass(end(right(m))) return torque_left == torque_right and balanced(end(left(m))) and balanced(end(right(m))) 这个结构类似树，我们可以递归的求解这个问题 Base case：若传入的是一个planet，则返回True，因为planet在这个结构中类似叶子节点，是整个mobile的终点 递归：每次需要比较mobile的左右扭矩是否相等，同时递归比较左右arm下的左右扭矩是否相等，直到递归到planet直接返回True Trees Q4: Maximum Path Sum 写一个函数，返回树上从根节点到叶子节点的所有路径中节点权值总和最大值 1234567891011121314151617def max_path_sum(t): \"\"\"Return the maximum root-to-leaf path sum of a tree. &gt;&gt;&gt; t = tree(1, [tree(5, [tree(1), tree(3)]), tree(10)]) &gt;&gt;&gt; max_path_sum(t) # 1, 10 11 &gt;&gt;&gt; t2 = tree(5, [tree(4, [tree(1), tree(3)]), tree(2, [tree(10), tree(3)])]) &gt;&gt;&gt; max_path_sum(t2) # 5, 2, 10 17 \"\"\" max_n = -1 if is_leaf(t): return label(t) for b in branches(t): max_n=max(max_path_sum(b),max_n) return max_n+label(t) 使用递归遍历 先直接深入到叶子节点，发现叶子节点则返回节点权值，再往前返回，每上一个节点返回已经求和的值+当前节点权值，且每次遍历取当前不同路径的最大值","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Generators","slug":"CS61A——Generators","date":"2025-03-27T01:28:07.554Z","updated":"2025-03-27T01:28:49.839Z","comments":true,"path":"2025/03/27/CS61A——Generators/","permalink":"https://izayoisakuye.github.io/2025/03/27/CS61A%E2%80%94%E2%80%94Generators/","excerpt":"","text":"Generators Generator Functions 生成器函数是用来生成(yields)值而非返回值的函数 生成器函数使用yield关键字返回生成的值 生成器可以多次生成值，而普通函数只能返回一次值 生成器是调用生成器函数时自动创建的迭代器 调用生成器函数，它会返回一个生成器来迭代该函数生成的值 当函数执行到yield时，生成的值将会作为下次迭代器的数值，而此时执行在yield处执行，但会记住当前环境，以便下次继续执行 e.g. 12345678910def evens(start, end): even = start + (start%2) while even&lt;end: yield even even+=2 if __name__ == \"__main__\": t = evens(2,10) for i in t: print(i) 2 4 6 8 Generators &amp; Iterators yield from语句 yield from语句允许从一个迭代器或可迭代变量中生成所有值 两个例子： 123456789101112131415def countdown(k): if k&gt;0: yield k yield from countdown(k-1) ''' 等价于 for i in countdown(k-1): yield i ''' else: yield 'Blast off' if __name__ == \"__main__\": t = countdown(3) for i in t: print(i) 3 2 1 Blast of 1234567891011def prefixes(s): if s: yield from prefixes(s[:-1]) yield s def substrings(s): if s: yield from prefixes(s) yield from substrings(s[1:]) if __name__ == \"__main__\": print(list(prefixes(\"both\"))) print(list(substrings(\"top\"))) ['b', 'bo', 'bot', 'both'] ['t', 'to', 'top', 'o', 'op', 'p'] Example: Partitions 详见递归时的数字分割例子 使用列表： 12345678910111213def partitions(n,m): if n&lt;0 or m==0: return [] else: exact_match = [] if n==m: exact_match = [str(m)] with_m = [p+'+'+str(m) for p in partitions(n-m,m)] without_m = partitions(n,m-1) return exact_match+with_m+without_m if __name__ == \"__main__\": for p in partitions(6,4): print(p) 2+4 1+1+4 3+3 1+2+3 1+1+1+3 2+2+2 1+1+2+2 1+1+1+1+2 1+1+1+1+1+1 使用生成器： 使代码更优雅，而且可以输出指定个数的可能结果 1234567891011def partitions(n,m): if n&gt;0 and m&gt;0: if n==m: yield str(m) for p in partitions(n-m,m): yield p+'+'+str(m) yield from partitions(n,m-1) if __name__ == \"__main__\": t = partitions(6,4) for p in range(5): print(next(t)) 2+4 1+1+4 3+3 1+2+3 1+1+1+3","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【数据结构】队列","slug":"队列","date":"2025-03-25T23:14:37.969Z","updated":"2025-04-06T09:09:52.968Z","comments":true,"path":"2025/03/26/队列/","permalink":"https://izayoisakuye.github.io/2025/03/26/%E9%98%9F%E5%88%97/","excerpt":"","text":"队列 特点 只允许在表的一端插入，而在另一端删除 允许插入的一端被称为队尾（rear），允许删除的一端被称为队头（front） 队列遵循先进先出（FIFO）的原则 顺序表实现 建表 123456typedef int ElemType; typedef struct { ElemType data[MAXSIZE]; int front; int rear; }Queue; 初始化 1234void initQueue(Queue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; } 判空 判断首尾相遇即为空（并非为0） 12345678910// 判空 int isEmpty(Queue *Q){ if (Q-&gt;front == Q-&gt;rear){ printf(\"Empty\"); return 1; } else { return 0; } } 出队 12345678910// 出队 ElemType dequeue(Queue *Q){ if (isEmpty(Q)){ printf(\"Empty\"); return 0; } ElemType e = Q-&gt;data[Q-&gt;front]; Q-&gt;front++; return e; } 入队 队列不满时才能入队，但有一种特殊情况： 此时队尾在最后，但队头在中间，意味着已经有数据出队，此时队列里仍有位置 这时我们需要将数据移到队头，使队尾向前以便插入元素 1234567891011121314151617181920212223242526// 判断队列是否满 int queueFull(Queue *Q){ if (Q-&gt;front &gt;0){ //说明front在中间，前面还有位置 int step = Q-&gt;front; // 取front的位置 for (int i = Q-&gt;front; i&lt;=Q-&gt;rear; i++){ // 遍历已经有元素的位置 Q-&gt;data[i-step] = Q-&gt;data[i]; // 向前移动到头 } Q-&gt;front = 0; // 让front指向0 Q-&gt;rear = Q-&gt;rear - step; // rear往前调整 return 1; } else { return 0; } } // 入队 int enqueue(Queue *Q, ElemType e){ if (Q-&gt;rear &gt;=MAXSIZE){ if (!queueFull(Q)){ return 0; } } Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear++; return 1; } 注意，该方法时间复杂度较大，对于大量数据可能效率会很低 获取队头元素 123456789// 获取队头元素 int getHead(Queue *Q, ElemType *e){ if (isEmpty(Q)){ printf(\"Empty\"); return 0; } *e = Q-&gt;data[Q-&gt;front]; return 1; } 动态分配内存 123456789101112131415typedef int ElemType; typedef struct { ElemType *data; int front; int rear; }Queue; // 初始化队列 Queue* initQueue(Queue *Q){ Queue *q = (Queue*)malloc(sizeof(Queue)); q-&gt;data = (ElemType)malloc(sizeof(ElemType)*MAXSIZE); Q-&gt;front = 0; Q-&gt;rear = 0; return q; } 循环队列 循环队列可以避免整体移动位置的情况 即让front指向队头的前一个元素，rear指向队尾元素 入队 12345678910// 入队 int enqueue(Queue *Q, ElemType e){ if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front){ // 循环队列判满 printf(\"Full\"); return 0; } Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear+1)%MAXSIZE; // 循环在队尾加1 return 1; } 取余保证在0到MAXSIZE-1的范围内循环下标 填不满的循环队列 有这么一种情况： 在上次入队后，rear+1，队尾到达0位置 此时若再进行入队操作，首先判断(Q-&gt;rear+1)%MAXSIZE，结果为1，此时正好满足rear==front意为堆满 但实际上还留有一个位置，用于判断堆满（与队空区分），若不留空则队满与队空的判断条件一样，无法判断 计算元素个数 rear&gt;front 此时元素个数=rear-front rear&gt;front 分两块计算：0到rear与front到maxsize 即元素个数=rear+1+MAXSIZE-front-1=rear-front+MAXSIZE 综上，计算公式可以写作(rear-front+MAXSIZE)%MAXSIZE 另两种循环队列 此时front指向当前队头元素，rear指向队尾元素的后一个元素 队空：front==rear 队满：front=(rear+1)%MAXSIZE，也要空出一个位置 元素个数：与上一种一样 此时front指向队头元素，rear指向队尾元素 队空：front=(rear+1)%MAXSIZE 入队情况有两种： 第一种是先入队再判满 可以发现当rear==front时，队中有一个元素 为了留一个空位判断队空队满，所以当front==(rear+2)%MAXSIZE时有队满 元素个数： rear&gt;front 此时元素个数=rear-front+1 rear&lt;front ​ 分两块讨论，0到rear与front到maxsize ​ 即元素个数=rear+1+MAXSIZE-front 综上，元素个数=(rear-front+1+MAXSIZE)%MAXSIZE 链表实现 构建队列 1234567891011typedef int ElemType; typedef struct QueueNode{ ElemType data; struct QueueNode *next; }QueueNode; typedef struct Queue { QueueNode *front; QueueNode *rear; }Queue; 这里多定义了一个结构体Queue，记录队头与队尾指针，而QueueNode为存储数据的链表 初始化 12345678910// 初始化 Queue* initQueue(){ Queue* q = (Queue*)malloc(sizeof(Queue)); QueueNode* node = (QueueNode*)malloc(sizeof(QueueNode)); // 定义一个头节点 node-&gt;data = 0; // 头节点的data为0 node-&gt;next = NULL; // 空队列 q-&gt;front = node; // 队头指向头节点 q-&gt;rear = node; // 队尾指向头节点 return q; } 入队 使用尾插法，此时认为队头为首节点，队尾为尾节点 创建新节点 让头节点的next指向该节点 尾指针后移一位 12345678// 入队 void enqueue(Queue *q, ElemType e){ QueueNode* node = (QueueNode*)malloc(sizeof(QueueNode)); node-&gt;data = e; node-&gt;next = NULL; q-&gt;rear-&gt;next = node; // 原来队尾指针指向节点的next指向新节点 q-&gt;rear = node; // 队尾指针移到新节点 } 出队 12345678910// 出队 void dequeue(Queue *q, ElemType *e){ QueueNode* node = q-&gt;front-&gt;next; // 要删除的节点是头节点的后一个节点（对头结点） *e = node-&gt;data; // 取出要删除的元素 q-&gt;front-&gt;next = node-&gt;next; // 让头节点的下一个元素指向要删除节点的下一个元素 if (q-&gt;rear == node){ // 若只有一个节点（删除的是尾节点） q-&gt;rear == q-&gt;front; // 讲队列设为空 } free(node); } 单调队列 假设有一个数组(如[5,2,6,3,7,2,5,3])，使用滑动窗口，通过对l++, r++实现让数字进入进出窗口 单调队列可以实现在滑动窗口每一时刻获得窗口中的 最大最小值，以低成本 单调队列通过双端队列实现，假设要求最大值，则双端队列从头到尾依次是从大到小，存储的是元素下标 右侧拓展： 队列为空时，第一个元素的下标进入(0-&gt;5) 若下一个元素进入满足严格从大到小，则进入，否则将最尾端元素弹出，直到满足从大到小 左侧收缩： 滑动窗口滑动，则不在指定范围内的下标从队头弹出 由此可以发现，每时最大值应为队头下标对应元素 How？ 单调队列维持了每次最值的可能性 满足严格从大到小的顺序的队列保证了在前一个元素从队头弹出的情况下，下一个元素成为最大值 由于窗口不回退，当更大的数进入时，前面比它小的数便没有机会成为某时刻的最大值了，故可以弹出 时间复杂度：最坏","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"【Python】CS61A——Iterators","slug":"CS61A——Iterators","date":"2025-03-22T02:51:32.715Z","updated":"2025-03-22T02:51:55.128Z","comments":true,"path":"2025/03/22/CS61A——Iterators/","permalink":"https://izayoisakuye.github.io/2025/03/22/CS61A%E2%80%94%E2%80%94Iterators/","excerpt":"","text":"Iterators Iterators 迭代器是一种常见的接口，python中常用作一种访问不同容器元素的方式 - 容器可以提供一个迭代器，以按照某种顺序访问容器内元素 - iter(iterable)：创建迭代器，接受任何可迭代的东西，返回可迭代元素的迭代器 - next(iterator)：推进迭代器，返回迭代器的下一个元素 - 不同迭代器可以迭代相同值，但它们彼此之间是独立的 - 使用list，tuple或sorted函数可以查看一个迭代器的剩余元素 - 当迭代器到达末尾，Python会返回一个StopIteration的异常 - 所有迭代器都是可变对象 12345678s = [[1,2],3,4,5] t = iter(s) u = iter(s) print(\"t:\",next(t)) print(\"u:\",next(u)) print(\"t:\",next(t)) list(t) print(next(t)) t: [1, 2] u: [1, 2] t: 3 --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) Cell In[4], line 8 6 print(\"t:\",next(t)) 7 list(t) ----&gt; 8 print(next(t)) StopIteration: Dictionary Itertion 字典的键，值以及键值对都是可遍历的 ，可以生成迭代器 字典中的键值对顺序取决于它们的添加顺序（Python3.6+） 迭代各项目的方法如下 1234567891011d = {'one':1, 'two':2, 'three':3} d['zero'] = 0 # 遍历键 k = iter(d.keys()) # iter(d) print(next(k)) # 遍历值 v = iter(d.values()) print(next(v)) # 遍历键值对 i = iter(d.items()) # 以元组形式迭代 print(next(i)) one 1 ('one', 1) 注意：若在迭代器创建后，字典发生了结构上的改变（增加，减少元素等），迭代器会失效。若只是改变键对应的值则不会。 For Statement for循环可以遍历迭代器本身，可以从迭代器当前位置遍历到迭代器末尾，但这会推进迭代器，故不能重复使用 而可迭代对象可以从头到尾遍历多次 123456r = range(3,6) ri = iter(r) for i in ri: print(i) for i in ri: print(i) 3 4 5 Built-in Function for Iteration 许多python内置的序列操作使用迭代器作为返回值，以惰性方式计算 惰性计算意味着只有被请求时才计算结果 e.g. map(func, iterable)：接受一个函数与一个可迭代对象，将该函数应用于可迭代对象中的每一个元素，返回一个迭代器遍历可迭代对象中所有x在func下的值 filter(func, iterable)：接受一个断言函数与一个可迭代对象，返回一个迭代器遍历可迭代对象中所有在func下为真的x zip(first_iter, second_iter)：接受两个可迭代对象，返回迭代器遍历相同索引的(x,y)对 reversed(sequence)：接受一个序列，返回迭代器反向遍历该序列 12345bcd = ['b', 'c', 'd'] m = map(lambda x: x.upper(), bcd) # 返回一个迭代器 print(next(m)) print(next(m)) print(next(m)) B C D 1234567def double(x): print(x, '=&gt;',2*x) return 2*x m = map(double, range(3,7)) f = lambda y: y&gt;=10 t = filter(f,m) # 仅遍历满足f函数下的返回值 list(filter(f,m)) # 将所有可能的返回值存入列表 3 =&gt; 6 4 =&gt; 8 5 =&gt; 10 6 =&gt; 12 [10, 12] Zip zip函数返回迭代器，遍历相同索引的值组成的元组 若一个可迭代对象比另一个长，zip会跳过多余的 zip可以接受多个可迭代对象 12345print(list(zip([1,2],[3,4]))) print(list(zip([1,2],[3,4,5]))) print(list(zip([1,2],[3,4,5], [6,7]))) [(1, 3), (2, 4)] [(1, 3), (2, 4)] [(1, 3, 6), (2, 4, 7)] e.g. 检测任意一个序列是否为回文序列，使用zip 1234567891011def palindrome(s): # &gt;&gt;&gt; palindrome([3,1,4,1,5]) # False # &gt;&gt;&gt; palindrome([3,1,4,1,3]) # True # &gt;&gt;&gt; palindrome('seveneves') # True return all([a==b for a,b in zip(s,reversed(s))]) if __name__ == '__main__': print(palindrome([3,1,4,1,3])) print(palindrome('seveneves')) True True Using Iterators 使用迭代器的代码对数据本身更改不大 - 当数据表示形式改变时，使用迭代器可以不必重写代码 - 其他人更可能在他们的数据上使用你的代码 迭代器将序列中的元素与所在位置绑定 - 将对象传递给其他函数时始终保留着位置 - 可以确保序列中的每个元素只执行一次 - 传递迭代器限制了对序列执行的操作，即只能请求下一个值","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【数据结构】栈","slug":"栈","date":"2025-03-21T14:21:59.923Z","updated":"2025-04-02T14:42:08.293Z","comments":true,"path":"2025/03/21/栈/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E6%A0%88/","excerpt":"","text":"栈 特点 仅可在表尾操作 表尾称为栈顶(top)，表头称为栈底 不含元素的空表为空栈 栈遵循后进先出（LIFO）的原则 基本操作包括push，pop 顺序表实现 初始化 123456789typedef struct{ ElemType data[MAXSIZE]; int top; }Stack; // 栈的初始化 void initStack(Stack *s){ s-&gt;top = -1; // 表示空栈 } 判断空栈 123456789int isEmpty(Stack *s){ if (s-&gt;top==-1){ printf(\"Empty\"); return 1; } else { return 0; } } 压栈 12345678910// 压栈 int push(Stack *s, ElemType e){ if (s-&gt;top&gt;=MAXSIZE-1){ printf(\"Full\"); return 0; } s-&gt;top++; // 栈顶上移一位 s-&gt;data[s-&gt;top]= e; // 压入数据 return 1; } 出栈 12345678910// 出栈 int pop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; // 弹出栈顶元素 s-&gt;top--; // 栈顶下移一位 return 1; } 获取栈顶元素 123456789// 获取栈顶元素 int getTop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; return 1; } 动态分配内存 123456789101112typedef struct{ ElemType *data; int top; }Stack; // 栈的初始化 Stack* initStack(){; Stack *s = (Stack*)malloc(sizeof(Stack)); s-&gt;data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); s-&gt;top = -1; // 表示空栈 return s; } 链表实现 使用单向链表来实现栈 尾节点为栈底，首节点为栈顶 压栈：链表头插法 出栈：删除头节点后的首节点 判空：只有头节点（head-&gt;next == NULL） 获取栈顶数据：找头节点的next的data（head-&gt;next-&gt;data） 初始化 12345typedef int ElemType; typedef struct stack{ ElemType data; struct stack *next; }Stack; 判空 12345678910// 判空 int isEmpty(Stack *s){ if (s-&gt;next == NULL){ // 头节点的next指向NULL printf(\"Empty\"); return 1; } else { return 0; } } 压栈 123456789// 压栈 int push(Stack *s, ElemType e){ Stack* p = (Stack*)malloc(sizeof(Stack)); p-&gt;data = e; p-&gt;next = s-&gt;next; s-&gt;next = p; return 1; } 出栈 123456789101112// 出栈 int pop(Stack *s, ElemType *e){ if (s-&gt;next==NULL){ printf(\"Empty\"); return 0; } Stack *q = s-&gt;next; *e = q-&gt;data; s-&gt;next = q-&gt;next; free(q); return 1; } 获取栈顶元素 123456789// 获取栈顶元素 int getTop(Stack *s,ElemType *e){ if (s-&gt;next == NULL){ printf(\"Empty\"); return 0; } *e = s-&gt;next-&gt;data; return 1; } 单调栈 单调栈常用于寻找元素： 寻找元素的下一个更大/更小元素 寻找元素左侧第一个更大/更小元素 进一步，单调栈可以应用于优化DP等问题 无重复值 对给定数组(如[2, 5, 6, 7, 3, 4, 1, 8])，寻找每个位置的左边与右边离自己最近比自己小的位置在哪 暴力遍历会有的时间复杂度，我们可以用栈来优化 创建一个空栈（存下标），该栈要求大压小： 没东西直接放入对应下标 若满足大压小则放入，当不满足时弹出栈顶 此时弹出后的栈顶就是弹出元素左边最近且比它小的数 使得该元素弹出的元素就是弹出元素右边最近且比它小的数 如依次放入2, 5, 6, 7，当压入3时，发现元素小于栈顶元素，故无法压入 此时弹出栈顶元素7，则7左边最近且比它小的数为6，右边最近且比它小的数3 继续压入3，发现元素小于栈顶元素，无法压入 此时弹出栈顶元素6，则6左边最近且比它小的数为5，右边最近且比它小的数为3 …… 直到可以压入时再压入，继续往后压入元素下标 遍历结束，开始清算栈中剩下的数字 若此时没有数字让当前位置弹出，则右边最近且比它小的数不存在 若此时底下已经没有元素压着了，则左边最近且比它小的数不存在 同理，使用小压大的单调栈可以寻找离自己最近比自己大的位置 有重复值 对给定数组(如[2, 3, 4, 3, 2, 1, 3, 5, 6, 3, 4, 3, 2])，寻找每个位置的左边与右边离自己最近比自己小的位置在哪 创建一个大压小的空栈 整体逻辑与无重复值相同，但当压入下一个数时发现与当前数相同时 不压入该数，而是弹出当前值，作为当前数右侧离自己最近比自己小的值（此时是错误的） 当遍历阶段与清算阶段结束后，各个元素关系如下，其中框住的是错误的位置 左侧无需修正，右侧倒序遍历每个位置的右侧元素，若发现与遍历元素相等，则将右侧元素对应的右侧离它最近比它小的元素作为当前遍历元素的右侧元素 如发现9位置为3，而其右侧元素为11位置的3，则我们看11位置的3的右侧元素，是12位置的2，那我们将9位置右侧元素改为12位置的2 我们可以发现，需要此种操作时，两数之间总会有大于两数的数 模板 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; //#include &lt;stack&gt; using namespace std; const int N = 3e6+10; //stack&lt;int&gt; st; int arr[N]; int stack[N]; // 数组实现栈, 内部存的是下标 int ans[N][2]; // 二维的0位置为左侧答案，1位置为右侧答案 int n, r; int main(){ cin &gt;&gt; n; for (int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; r = 0; int cur; // 遍历阶段 for (int i = 0;i&lt;n;i++){ while(r&gt;0 &amp;&amp; arr[stack[r-1]]&lt;=arr[i]){ // 小于等于时看大于当前位置，大于等于反之 cur = stack[--r]; // 当前弹出位置 ans[cur][0] = r&gt;0 ? stack[r-1]:-1; // 左侧最近答案 ans[cur][1] = i; // 右侧最近答案 } stack[r++]=i; } // 清算阶段 while (r&gt;0){ cur = stack[--r]; ans[cur][0] = r&gt;0? stack[r-1]:-1; ans[cur][1] = -1; } // 修正阶段 // 只需要修正右侧答案，从右往左修正，n-1右侧的一定是-1，不需要修正 for(int i = n-2; i&gt;=0; i--){ if(ans[i][1]!=-1 &amp;&amp; arr[ans[i][1]]==arr[i]){ ans[i][1] = ans[ans[i][1]][1]; // 现在右侧答案的右侧的答案作为现在右侧的答案 } } for (int i = 0;i&lt;n;i++){ cout &lt;&lt;ans[i][0]+1&lt;&lt;' '&lt;&lt;ans[i][1]+1&lt;&lt;endl; } } 根据具体题目，若只让求右侧等条件，相等时也可以进栈","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"【数据结构】表","slug":"表","date":"2025-03-21T14:21:27.493Z","updated":"2025-03-21T14:21:50.714Z","comments":true,"path":"2025/03/21/表/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E8%A1%A8/","excerpt":"","text":"表 线性表 n个数据类型相同的元素构成的有限序列 空表：大小为0的表 首节点：存在唯一一个被称为第一个的元素 尾节点：存在唯一一个被称为最后一个的元素 前驱：前驱 后继：后继 对于除了首尾节点的元素，它只会有一个前驱、一个后继 顺序表实现 顺序表：一组连续内存单元存储线性表的各个元素 对于静态表，main函数调用时，应传入列表的地址(&amp;) 建表 123456789#define MAXSIZE 100 typedef int ElemType; // 方便存储不同类型数据的情况下修改数据类型 // 建表 typedef struct SeqList { ElemType data[MAXSIZE]; int length; // 顺序表数据个数 }; 初始化 1234// 初始化 void initList(SeqList *L){ L-&gt;length = 0; } 尾插元素 12345678910// 尾插元素 int appendElem(SeqList *L, ElemType e){ if (L-&gt;length&gt;=MAXSIZE){ // 判满 printf(\"已满\\n\"); return 0; } L-&gt;data[L-&gt;length] = e; // 在末尾添加元素 L-&gt;length++; // 将顺序表长度加一 return 1; } 插入元素 123456789101112131415161718// 插入元素 int insertElem(SeqList *L, ElemType e, int pos){ if (L-&gt;length&gt;=MAXSIZE){ // 判满 printf(\"已满\\n\"); return 0; } if (pos&lt;1 || pos&gt; L-&gt;length){ printf(\"位置错误\\n\"); return 0; } for (int i = L-&gt;length-1; i&gt;=pos-1;i--){ // 倒序让插入元素后面的元素后移一位 L-&gt;data[i+1] = L-&gt;data[i]; // 向后移动元素 } L-&gt;data[pos-1] = e; // 插入元素 L-&gt;length++; // 将顺序表长度加一 return 1; } 最坏时间复杂度 需要将插入位置后的元素都后移一位 遍历列表 1234567// 遍历元素 void listElem(SeqList *L){ for (int i = 0; i &lt; L-&gt;length; i++){ printf(\"%d \", L-&gt;data[i]); } printf(\"\\n\"); } 删除元素 1234567891011// 删除元素并返回删除的元素 int delElem(SeqList *L, int pos, ElemType *e){ *e = L-&gt;data[pos-1]; // 取出删除元素 if (pos &lt; L-&gt;length){ for (int i = pos; i&lt;L-&gt;length; i++){ L-&gt;data[i-1] = L-&gt;data[i]; // 从pos开始向后，将后面一位覆盖到前一位实现删除 } } L-&gt;length--; // 表长度减一，这样最后一个元素不用覆盖也可以 return 1; } 该删除可以返回删除掉的元素，用e变量存储 查找元素 123456789// 查找元素 int findElem(SeqList *L, ElemType e){ for (int i = 0; i&lt;L-&gt;length; i++){ if (e==L-&gt;data[i]){ // 找到元素 return i+1; // 返回位置 } } return -1; // 找不到返回-1 } 使用动态顺序表实现 通过malloc函数在堆中动态分配内存建表 不同的地方只是在建表与初始化上 12345678910111213// 建表 typedef struct { ElemType *data; int length; }SeqList; // 初始化 分配内存 SeqList* initList(){ SeqList *L = (SeqList*)malloc(sizeof(SeqList)); L -&gt; data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); L -&gt; length = 0; return L; } 此时在main函数建表时只需要调用initList函数初始化并将返回的结构体指针存入一个对应变量即可 由于此时获得的直接是地址，故对应操作时便不需要取地址了 链表实现 链表存储的特点是用一组任意的存储单元存储数据（可连续可不连续） 对每一个存储单元，除了要存储当前数据，还需要存储一个指示其直接后继的信息（地址），这两部分信息组成了一个节点，n个节点链接成了一个链表，即为线性表 节点包括两个域： 数据域：存储数据元素信息 指针域：存储直接后继存储位置 单链表 next中存储了下一个节点的地址，其中尾节点中的next指向NULL，表示到达链表尾部 初始化 123456789101112// 单链表初始化-建立头节点 Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // 分配一个节点大小的空间 head-&gt;data = 0; // 数据设为0 head-&gt;next = NULL; // 下一个地址设为NULL return head; } int main(){ Node* test = initList(); return 0; } 建立一个头节点，作为线性表的开始，其数据为0，地址默认为NULL 创建链表时，只需要调用initList函数并将返回的结构体指针赋给对应变量即可 头插元素 头插元素实现了在头节点后插入数据 先让新节点的next指向原头节点指向的下一个节点 再让头节点指向的节点更改为新的节点 顺序很重要 123456int insertHead(Node* L, ElemType e){ Node *p = (Node*)malloc(sizeof(Node)); // 分配存储数据的节点的空间 p-&gt;data = e; // 将插入元素赋值给该节点 p-&gt;next = L-&gt;next; // 将该节点的next指向原头节点指向的节点 L-&gt;next = p; // 将原头节点的next指向该新节点 } 尾插元素 头插元素实现了在尾节点后插入数据，我们需要先寻找尾节点 找到某节点的next==NULL时便找到了尾节点 12345678// 获得尾节点地址 Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // 当节点不为空时 p = p-&gt;next; // 顺着寻找下一个节点 } return p; } 先让先前的尾节点指向新节点 再让新节点指向NULL 12345678// 尾插法插入元素 Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; tail-&gt;next = p; p-&gt;next = NULL; return p; } 注意，尾插法每次返回尾节点，这样下次插入时就可以接着上一次的插入了，不需要再get 指定位置插入元素 首先要找到待插入位置的前一个元素，然后让新节点指向该元素的下一个元素 然后让前一个节点指向新节点的位置 1234567891011121314151617// 指定位置插入元素 int insertNode(Node* L, int pos, ElemType e){ Node* p = L; // 让指针指向需要插入位置的前驱节点 for(int i = 0; i&lt;pos-1;i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); // 要插入的新节点 q-&gt;data = e; // 输入数据 q-&gt;next = p-&gt;next; // 新节点下一个位置赋值为前驱节点指向的后一个节点 p-&gt;next = q; // 前驱节点指向插入的新节点 return 1; } 删除节点 找到删除节点的前驱节点p 用指针q指向要删除的节点 通过改变p的后继节点实现删除 并释放删除节点的空间 1234567891011121314151617181920// 删除节点 int delNode(Node* L, int pos){ Node* p = L; // 让指针指向需要删除位置的前驱节点 for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p == NULL) { return 0; } } if (p-&gt;next == NULL){ printf(\"位置错误\\n\"); } Node* q = p-&gt;next; // q指向要删除的节点 p-&gt;next = q-&gt;next; // 要删除节点的前驱节点指向其后继节点 free(q); return 1; } 获取链表长度 12345678910// 获取链表长度 int listLength(Node* L){ Node* p = L; int cnt = 0; while(p!=NULL){ p = p-&gt;next; cnt++; } return cnt; } 释放链表 把头结点后的节点都释放掉 让指针p指向头节点后的第一个节点 若p不为NULL，让q指向p的后继节点，并释放p指向的节点 让p, q指向同一个节点，循环以上操作 12345678910111213// 释放链表 void freeList(Node* L){ Node* p = L-&gt;next; // p指针指向头节点后的第一个节点 Node* q; while(p!=NULL){ // 判断p指向是否是空节点 q = p-&gt;next; // q指向p的后继 free(p); // 释放p p = q; // p指向其后继（q指向的节点） } L-&gt;next = NULL; //释放后原链表头节点指向NULL } 注意 时间复杂度：读取数据–顺序表&gt;链表 修改数据–链表&gt;顺序表 不要忘记初始化指针变量，防止其变为野指针 何时使用malloc？ 声明指向一个结构的指针不会创建该结构，而是给出足够空间容纳结构可能会使用的地址 使用malloc可以使系统创建一个新的结构并返回指向该结构的指针 故若想使用指针变量沿着一个表行进，就没必要创建新的结构，不宜使用malloc free的结果：指针指向的地址没变，但该位置处的数据已经无定义了（野指针） 若未对链表进行过删除操作，则调用malloc的次数应该等于表的大小，含表头再+1 单项循环链表 特点：表中最后一个节点的指针域指向头节点，形成一个环 终止条件：p!=L或p-&gt;next!=L 判断是否有环 快慢指针 让快指针一次走两步，慢指针一次走一步 当遇不到NULL时，若有环，则两者会一直追赶，根据概率一定会有一个时候相遇 若能相遇则说明有环，否则若碰到NULL证明没有环 注意特判只有一个元素或没有元素时，不然当前节点的指针域会赋值给空指针而报RE 1234567891011121314class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return false; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow) return true; } return false; } }; 找到环的入口 设起点到入口距离为，入口到相遇距离为，相遇再到入口距离为，则快慢指针走的路程如下： 其中n为圈数，由于快指针的速度为慢指针的两倍，故慢指针一定会在一圈内与快指针相遇 有 化简得$ = n(y+z)-y，由于快指针先入环，且速度快于慢指针，故快指针至少转一圈才能与慢指针相遇，即n$至少为1 多拿出一圈来将y约掉，则 当时，即快指针转一圈与慢指针相遇的情况下，，即两者会在环的入口处相遇 当时，由于是一整圈的路程，即走完若干圈后快指针还会再走距离，最后与慢指针在环的入口处相遇 故我们可以在相遇位置设置一个指针，在起始位置设置一个指针，两者相遇处即为入口 12345678910111213141516171819202122232425262728struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; class Solution { public: ListNode* detectCycle(ListNode *head) { int cnt[10005]; ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return nullptr; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow){ ListNode* index1 = fast; ListNode* index2 = head; while(index1!=index2){ index1 = index1-&gt;next; index2 = index2-&gt;next; } return index1; } } return nullptr; } }; 双向链表 特点：双向链表的节点中有两个指针域：一个指向直接后继，另一个指向直接前驱 建表 12345typedef int ElemType; typedef struct node{ ElemType data; struct node *prev, *next; }Node; 初始化 与单链表相同 1234567// 初始化建立头节点 Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // 分配一个节点大小的空间 head-&gt;data = 0; // 数据设为0 head-&gt;next = NULL; // 下一个地址设为NULL return head; } 头插法 让新节点的prev指向头节点 让新节点的next指向头节点的next 让头节点的next节点的prev指向新节点，让头节点的next指向新节点 123456789101112// 头插法 int insertHead(Node* L, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = L; // 新节点的prev指向头节点 p-&gt;next = L-&gt;next; // 新节点的next指向头节点后的第一个节点 if (L-&gt;next!=NULL){ // 保证并非只有一个头节点 L-&gt;next-&gt;prev = p; // 新节点的next节点的prev指向新节点 } L-&gt;next = p; // 头节点的next节点指向新节点 return 1; } 尾插法 让新节点的prev指向尾节点 让尾节点的next指向新节点 将NULL值赋给新节点的next 123456789101112131415161718// 获得尾节点地址 Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // 当节点不为空时 p = p-&gt;next; // 顺着寻找下一个节点 } return p; } // 尾插法 Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = tail; tail-&gt;next = p; p-&gt;next = NULL; return p; } 指定位置插入 寻找前置节点，让新节点prev指向前置节点 让新节点的next指向后置节点 让前置节点的next的prev指向新节点 前置节点的next指向新节点 1234567891011121314151617// 指定位置插入数据 int insertNode(Node* L, int pos, ElemType e){ Node* p = L; for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); q-&gt;data = e; q-&gt;prev = p; q-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = q; p-&gt;next = q; return 1; } 删除元素 找到要删除节点的前驱节点，用指针记录要删除的节点 改变p的后继节点以及删除节点的后继节点的前驱来删除节点 12345678910111213141516171819// 删除元素 int delNode(Node* L, int pos){ Node *p = L; for (int i = 0;i&lt;pos-1;i++){ // 找到前驱节点 p = p-&gt;next; if (p==NULL){ return 0; } } if (p-&gt;next==NULL){ // 判断删除位置是否超出了表长度 printf(\"要删除的位置错误\"); return 0; } Node* q = p-&gt;next; // q指向要删除的节点 p-&gt;next = q-&gt;next; // p的next指向q的后继节点 q-&gt;next-&gt;prev = p; // q的后继节点的prev指向p free(q); // 删除q return 1; } 顺序表与链表","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"【计算机网络】Web应用的请求与响应机制","slug":"Web应用的请求与响应机制","date":"2025-03-21T14:20:01.860Z","updated":"2025-03-21T14:26:06.491Z","comments":true,"path":"2025/03/21/Web应用的请求与响应机制/","permalink":"https://izayoisakuye.github.io/2025/03/21/Web%E5%BA%94%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Web应用的请求与响应机制 HTTP协议 HTTP是web通信的基础协议，是客户端与服务器进行交互的标准，所有www文件必须遵守这个标准，其端口号为80 HTTPS是HTTP的安全版，在HTTP下加入SSL层 SSL是主要用于web的安全传输协议，在传输层对网络连接进行加密，其端口号为443 工作原理 HTTP通信由两部分组成：客户端请求信息、服务器响应信息 - 当用户在地址栏输入一个URL并回车后，客户端向web服务器发送HTTP请求，建立一个到服务器指定端口的TCP连接 - 服务器在那个端口监听客户端发送过来的请求，收到请求后，服务器根据内容与类型进行处理，并生成HTTP响应，包括一个状态行与相应的信息 - 客户端接受服务器返回的响应，并根据内容呈现给用户 URL 统一资源定位符（Uniform / Universal Resource Locator），是用于完整描述网页和其他资源的地址的一种标识方法 基本格式： scheme://host[:port#]/path/…/[?query-string][#anchor] - scheme：协议（如http与https） - host：服务器ip地址或域名 - port：服务器端口（如果走协议默认端口，缺省端口80） - path：访问资源的路径 - query-string：参数，发送给http服务器的数据 - anchor：锚，跳转到网页的指定锚点位置 HTTP请求 HTTP用来提交和获取资源，客户端发送一个HTTP请求请求到服务器的请求信息，包括：请求行、请求头部、空行、请求数据四个部分，格式如下 HTTP请求 一些常用的请求报头： - Host：对应URL中的web名称与端口号，用于指定被请求资源的Internet主机与端口号 - Connection：表示客户端与服务器连接类型 Client 发起一个包含 Connection:keep-alive 的请求， HTTP/1.1 使用 keep-alive 为默认值。 Server 收到请求后：如果 Server 支持 keep-alive（长连接）， 回复一个包含 Connection:keep-alive 的响应， 不关闭连接；如果 Server 不支持 keep-alive， 回复一个包含 Connection:close 的响应， 关闭连接。如果 client 收到包含 Connection:keep-alive 的响应， 向同一个连接发送下一个请求， 直到一方主动关闭连接。 keep-alive 在很多情况下能够重用连接， 减少资源消耗， 缩短响应时间， 比如当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)， 不需要每次都去请求建立连接。 - Upgrade-Insecure-Requests：升级不安全的请求， 意思是会在加载 http 资源时自动替换成 https 请求， 让浏览器不再显示 https 页面中的 http 请求警报。 - User-Agent：客户浏览器的详细信息，服务器根据这条信息来判断来访用户是否为真实用户 - Accept：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions）文件类型，服务器根据其判断并返回适当文件格式 - Accept: /： 表示什么都可以接收。 - Accept: text/html, application/xhtml+xml;q=0.9, image/;q=0.8： 表示浏览器支持的 MIME 类型分别是html文本、xhtml和xml文档、 所有的图像格式资源。 q是权重系数， 范围 ，q值越大，请求越倾向于获得其“;”之前的类型表示的内容。若没有指定 q 值， 则默认为1，按从左到右排序顺序；若被赋值为 0，则用于表示浏览器不接受此内容类型。 Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Application：用于传输应用程序数据或者二进制数据。 - Referer：表明产生请求的网页来自于哪个URL，用户是从该referer页面访问到当前请求的页面，可以用来跟踪web请求来自哪个页面，哪个网站 - Accept-Encoding：指出浏览器可以接受的编码方式。 编码方式不同于文件格式， 它是为了压缩文件并加速文件传递速度。 浏览器在接收到 Web 响应之后先解码， 然后再检查文件格式， 许多情形下这可以减少大量的下载时间。 如Accept-Encoding:gzip;q=1.0, identity; q=0.5, ;q=0 如果有多个 Encoding 同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码， 支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 - Accept-Language：指语言可以接受的语言种类，如zh或zh-cn指中文 - Accept-Charset：指浏览器可以接受的字符编码，缺省为任何字符集 - Cookie：浏览器用这个属性向服务器发送 Cookie。 - Content-Type：POST请求里用来表示的内容类型。 示例： HTTP请求示例 常见HTTP方法 GET：请求指定资源，通常附加在URL中，不适合传递大量数据与隐私数据 POST：向服务器提交数据，通常用于提交表单与上传文件 PUT：更新指定资源内容 HEAD：只返回响应头，不返回响应体 OPTIONS：查询服务器支持的HTTP方法 HTTP响应 由四部分组成，分别为状态行、消息报头、空行、响应正文，格式如下： HTTP响应 理论上所有响应头信息都是回应请求头的，但还会添加对应的响应头信息 示例： HTTP响应示例 HTTP状态码 web服务器对HTTP请求的回应，表示请求是否成功处理 1xx：服务器成功接受部分请求 2xx：成功（200 OK） 3xx：重定向（301 Moved Permanently） 4xx：客户端错误（404 Not Found） 5xx：服务器错误（500 Internal Server Error） Cookie与Session： 服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的链接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。 - Cookie：通过在 客户端 记录的信息确定用户的身份。 - Session：通过在 服务器端 记录的信息确定用户的身份 请求参数的获取与处理 HTTP携带多种数据，这里通过python，使用urllib与requests库来处理这些数据 处理URL路径与查询参数 ​ URL 查询参数是指在 URL 中通过键值对的形式传递的参数，用于在 URL 中增加额外的信息，如查询条件、排序方式、页码等。查询参数通常使用键值对的形式定义，键和值之间用 = 符号分隔，多个参数之间用 &amp; 符号分隔。例如，定义一个查询参数 page 的值为 2，可以写成 page=2 ​ 查询参数的主要用途是通过 URL 传递信息，实现搜索查询、过滤器等功能。例如，用户在输入框输入 abc，按下回车之后，会返回一条地址为 https://www.example.com/?keyword=abc 的 URL。在用户访问时，服务器会通过 URL 参数 keyword 检索相关内容，然后返回给用户 ​ 在python中，可以使用urllib库中urllib.parse模块中的parse_qs函数来解析查询字符串，以下为示例程序，程序返回字典，键值对分别为等号左右的内容 123456789101112131415from urllib.parse import urlparse, parse_qs # 示例URL url = 'http://example.com/path/to/resource?name=John&amp;age=30' # 解析URL parsed_url = urlparse(url) # 获取路径 path = parsed_url.path print(\"Path:\", path) # 解析查询参数 query_params = parse_qs(parsed_url.query) print(\"Query Parameters:\", query_params) Path: /path/to/resource Query Parameters: {'name': ['John'], 'age': ['30']} 处理表单数据 表单数据是通过网页上的表单收集并提交给服务器的信息，用户可以填写表单来提供各种信息。当用户点击表单上的提交按钮时，表单数据会被发送到服务器，服务器则根据接收到的数据执行相应操作 表单的基本结构如下 123456789&lt;form action=\"/submit\" method=\"post\"&gt; &lt;label for=\"username\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt;&lt;br&gt;&lt;br&gt; &lt;label for=\"password\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;form&gt;标签定义了一个表单，action属性指定了表单数据提交的目标url，method属性制定了提交数据时使用的HTTP方法 - GET：当method属性被设置为GET时，表单数据会被附加在url后面作为查询参数提交。这种方法适合提交少量的非敏感数据 - POST：当method属性被设置为POST时，表单数据会在请求体中发送，不会出现在url中。这种方法适合提交敏感与大量数据 &lt;input&gt;标签用于创建输入控件，type属性定义了输入控件的类型，name属性为提交属性时的键名，id用于关联&lt;label&gt;标签 &lt;label&gt;标签用于描述每个输入控件的用途 表单数据的编码： - application/x-www-form-urlencoded：这是默认的编码方式，表单数据被编码成键值对的形式，如 username=John&amp;password=Doe。 - multipart/form-data：当表单中包含文件上传字段时，必须使用此编码方式。它允许将文件和其他数据一起发送。 我们可以在python中通过request库发送POST请求来获取表单数据并处理，返回的是html类型的表单数据 1234567891011121314import requests # 示例表单数据 form_data = { 'username': 'john_doe', 'password': 'securepassword' } # 发送POST请求 response = requests.post('https://www.baidu.com/', data=form_data) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text) 处理JSON数据 python中可以使用request库来处理json数据 123456789101112131415import requests import json # 示例JSON数据 json_data = { 'name': 'John', 'age': 30 } # 发送POST请求 response = requests.post('https://www.baidu.com/', json=json_data) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response JSON:\", response.json()) 处理文件上传 HTTP文件上传是通过HTTP协议将文件从客户端传输到服务器的一种方式。通常使用POST方法，并且数据格式为multipart/form-data。这种格式允许在同一个请求中传输多个字段和文件。 HTTP文件上传中，请求头需要包含Content-Type，其值为multipart/form-data，并指定一个边界（boundary），用于分隔不同的字段和文件。例如 12345678910POST /upload HTTP/1.1 Host: www.example.com Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycz5DOEJKqu7XXB7k ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name=\"file\"; filename=\"example.png\" Content-Type: image/png &lt;文件内容&gt; ------WebKitFormBoundarycz5DOEJKqu7XXB7k-- 我们可以使用python的request库来处理文件上传响应 1234567891011import requests # 打开文件 files = {'file': open('example.txt', 'rb')} # 发送POST请求 response = requests.post('http://example.com/upload', files=files) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【Python】CS61A——Mutablity","slug":"CS61A——Mutablity","date":"2025-03-19T11:10:30.067Z","updated":"2025-03-19T11:11:00.592Z","comments":true,"path":"2025/03/19/CS61A——Mutablity/","permalink":"https://izayoisakuye.github.io/2025/03/19/CS61A%E2%80%94%E2%80%94Mutablity/","excerpt":"","text":"Mutablity Objects 对象用于表达信息，是一种包含了数据与行为的数据抽象 有属性的东西都可以作为对象，python中一切皆对象 Python中，优先级最高的对象被称为类（class） 面向对象编程（OOP）： 对象是OOP的核心 OOP使用一种暗喻来组织大型程序 使用一种特殊语法可以提高程序的可读性与组织 很多数据操作都是通过对象实现的 对象可以做许多相关的事情，而函数只能做一件事 e.g. String 字符串是一种表达文本的数据抽象 ### 字符串的表示 目前常见的表示方法是用ASCII与Unicode字符集表示字符 前者包含了控制字符、数字、字母与标点，后者则包含了不同语言中的更多字符 1234from unicodedata import name, lookup print(name('A')) # 查询字符集中的字符名称 print(lookup('BABY')) # 根据字符名称输出对应字符 print(lookup('BABY').encode()) # 查看该字符的字节编码 LATIN CAPITAL LETTER A 👶 b'\\xf0\\x9f\\x91\\xb6' Mutation Operations 一些对象是可以改变的 1234567891011suits = ['coin', 'string', 'myriad'] original_suits = suits print(suits.pop()) # 弹出一个元素（默认最后一个） suits.remove('string') # 移除指定元素 print(suits) suits.append('cup') # 在尾部增加一个元素 suits.extend(['sword', 'club']) # 添加序列中的多个元素来拓展列表 print(suits) suits[2] = 'spade' suits[0:2] = ['heart', 'diamond'] print(original_suits) myriad ['coin'] ['coin', 'cup', 'sword', 'club'] ['heart', 'diamond', 'spade', 'club'] 根据以上代码发现，我们可以对一个对象（suits）进行若干操作来变化其值 而我们在最初将suits与original_suits进行绑定，故变化也会在original_suits中体现 综上，所有指向相同对象的names都会受到Mutation的影响，其中这里的mutation指对象发生的变化 只有可变类型的对象才能更改，如列表与字典 函数调用时发生的Mutation 函数可以更改其作用域中任何可变对象的值 12345def mystery(s): s.pop() s.pop() four = [1,2,3,4] mystery(four) mystery函数实现了对列表对象值的更改，甚至mystery不需要传入参数，直接更改其所在作用域（全局作用域）中four列表的内容 表达式的Mutation 表达式的值会随着names绑定值或对象的改变而改变 1234x = [1,2] print(x+x) x.append(3) print(x+x) [1, 2, 1, 2] [1, 2, 3, 1, 2, 3] Tuples 元组是一种不可变的序列，使用圆括号包裹起来 实际上，任何以逗号隔开的元素都会被解释成元组，非必须加圆括号 使用tuple()创建元组或将其他序列转化为元组 在单个元素后加一个逗号可以将单个元素转化成元组 元组可以相加，也可以使用成员运算符in来判断元素是否存在 由于元组不可变，可以将其作为字典的键使用 若元组中包含了可变对象，则该对象可以被更改 123s = ([1,2],3) s[0][0]=4 print(s) ([4, 2], 3) Mutation 相同与改变 12345a = [10] b = a print(a==b) a.append(20) print(a==b) True True 在这个例子中，我们可以说a与b是相同的，因为b与a绑定到了同一个对象，当对其中一个发生变化，另一个也会同时改变 12345a = [10] b = [10] print(a==b) b.append(20) print(a==b) 在这个例子中，a与b是不同的，尽管它们曾有过相同的内容，但对b进行改变后，a会随之改变，因此这时二者便不同了 Identity Operators Identity： &lt;exp0&gt; is &lt;exp1&gt; 当两个表达式指向相同对象时返回True Equality &lt;exp0&gt; == &lt;exp1&gt; 当两个表达式拥有相同值时返回True 相同对象始终拥有相等的值，但反之不一定成立 12345a = [10] b = [10] c = b print(a is b) print(b is c) False True 可变对象在函数中的默认值 函数中声明的默认值是函数值的一部分，而不是每次调用时才生成 这导致了若该对象是可变的，而且在函数中间进行了修改，则该修改会在下次调用函数时保留 如下面的代码，每次调用增加的值会保留在默认值中 12345def f(s=[]): s.append(3) return len(s) for i in range(3): print(f()) 1 2 3 Mutable Fuctions 在函数中使用可变对象可以在多次调用时保留上次操作的值 12345678910111213def make_withdraw_list(balance): b = [balance] def withdraw(amount): if amount &gt; b[0]: return 'Insufficient funds' b[0] = b[0] - amount return b[0] return withdraw withdraw = make_withdraw_list(100) print(withdraw(25)) print(withdraw(25)) withdraw(100) 75 50 'Insufficient funds' 该函数将存款存在作为可变对象的列表中 函数中的withdraw函数始终指向列表b并修改其值，该列表总是这个列表，随着时间其中的内容被更改 为了实现每次更改列表中的值，该函数使用了可变对象来创建了一个可变函数","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Trees","slug":"CS61A——Trees","date":"2025-03-09T05:38:32.956Z","updated":"2025-03-28T13:46:45.653Z","comments":true,"path":"2025/03/09/CS61A——Trees/","permalink":"https://izayoisakuye.github.io/2025/03/09/CS61A%E2%80%94%E2%80%94Trees/","excerpt":"","text":"Trees 描述树形结构的术语 递归描述 - 一课树有一个根节点和一系列分支节点 - 每个分支也是一棵树，也有根节点与分支节点 - 没有分支节点的树被称为叶子节点 亲戚描述 树的每个位置被称为节点 每个节点可以表示任何值 一个节点可以称为另一个节点的父节点/子节点 实现树形结构的抽象 12345678910111213141516171819202122232425262728293031def tree(label, branches=[]): for branch in branches: assert is_tree(branch), \"branches must be trees\" # 确保构造的是一棵树 return [label] +list(branches) # 将同一层的分支节点放在一个列表中 def label(tree): return tree[0] def branches(tree): return tree[1:] def is_tree(tree): \"\"\"判断是不是一棵树\"\"\" if type(tree) != list or len(tree) &lt;1: # 确保树的分支是树，以及存在一个值 return False for branch in branches(tree): # 确保树的分支的分支都是树 if not is_tree(branch): return False return True def is_leaf(tree): \"\"\"判断树本身是不是叶子节点\"\"\" return not branches(tree) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(t) print(label(t)) print(branches(t)) print(label(branches(t)[0])) [1, [5, [7]], [6]] 1 [[5, [7]], [6]] 5 Tree Processing 处理叶子节点 使用递归，将会在每个分支节点进行递归调用，最后合并 12345678910def count_leaves(t): \"\"\"Count the leaves of tree T\"\"\" if is_leaf(t): return 1 else: return sum([count_leaves(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(count_leaves(t)) 2 返回叶子节点的值 实现leaves函数，返回树的叶子节点的值的列表 12345678910def leaves(tree): \"\"\"return a list containing the leaf labels of tree\"\"\" if is_leaf(tree): return [label(tree)] else: return sum([leaves(b) for b in branches(tree)], []) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) [7, 6] 根据树创建树 使用递归根据另一棵树创建一颗新树 如让叶子节点值+1的树 或让所有节点都+1的树 1234567891011121314151617def increment_leaves(t): \"\"\"return a tree like t but with leaf labels incremented\"\"\" if is_leaf(t): return tree(label(t)+1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t), bs) def increment(t): \"\"\"return a tree like t but with all labels incremented\"\"\" return tree(label(t)+1, [increment(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) print(increment_leaves(t)) print(increment(t)) [7, 6] [1, [5, [8]], [7]] [2, [6, [8]], [7]] 例：print_tree 按节点在树中的深度缩进打印一颗树 12345678def print_tree(t, indent = 0): print(' '*indent + str(label(t))) for b in branches(t): print_tree(b, indent+1) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_tree(t)) 1 5 7 6 None 例： 求从根节点沿路径到叶子节点求和并打印 1234567891011def print_sums(t, so_far): so_far = so_far +label(t) if is_leaf(t): print(so_far) else: for b in branches(t): print_sums(b,so_far) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_sums(t, 0)) 13 7 None","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab4","slug":"CS61A——Lab4","date":"2025-03-06T09:57:15.925Z","updated":"2025-03-06T09:57:37.807Z","comments":true,"path":"2025/03/06/CS61A——Lab4/","permalink":"https://izayoisakuye.github.io/2025/03/06/CS61A%E2%80%94%E2%80%94Lab4/","excerpt":"","text":"Dictionaries 部分跳过 Divide 传入一组商数与一组除数，返回字典，键为每个商数，值为表示每个商数能整除的除数的列表 12345678910def divide(quotients, divisors): \"\"\"Return a dictonary in which each quotient q is a key for the list of divisors that it divides evenly. &gt;&gt;&gt; divide([3, 4, 5], [8, 9, 10, 11, 12]) {3: [9, 12], 4: [8, 12], 5: [10]} &gt;&gt;&gt; divide(range(1, 5), range(20, 25)) {1: [20, 21, 22, 23, 24], 2: [20, 22, 24], 3: [21, 24], 4: [20, 24]} \"\"\" return {i: [x for x in divisors if x%i==0] for i in quotients} 注意用表达式建立列表与字典的方法 Buying Fruit 实现buy函数，通过给定的水果与价格，用恰好为传入的total_amount的价格购买指定的水果（每种指定水果至少买一次） 用display函数输出所有结果 123456789101112131415161718192021222324252627282930313233343536def buy(required_fruits, prices, total_amount): \"\"\"Print ways to buy some of each fruit so that the sum of prices is amount. &gt;&gt;&gt; prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9} &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 12) [2 apples][1 orange][1 banana] &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 16) [2 apples][1 orange][3 bananas] [2 apples][2 oranges][1 banana] &gt;&gt;&gt; buy(['apples', 'kiwis'], prices, 36) [3 apples][3 kiwis] [6 apples][2 kiwis] [9 apples][1 kiwi] \"\"\" def add(fruits, amount, cart): if fruits == [] and amount == 0: print(cart) elif fruits and amount &gt; 0: fruit = fruits[0] price = prices[fruit] for k in range(1,amount//price+1): add(fruits[1:], amount-k*price, cart+display(fruit,k)) add(required_fruits, total_amount, '') def display(fruit, count): \"\"\"Display a count of a fruit in square brackets. &gt;&gt;&gt; display('apples', 3) '[3 apples]' &gt;&gt;&gt; display('apples', 1) '[1 apple]' \"\"\" assert count &gt;= 1 and fruit[-1] == 's' if count == 1: fruit = fruit[:-1] # get rid of the plural s return '[' + str(count) + ' ' + fruit + ']' 返回条件是fruits为空或钱被花光，且递归时每次都取fruits的首个元素 可以推断递归时对fruits数组进行了切片，每次往后切一个元素 for循环遍历选择每个水果的个数，从至少选一个到最多能选的个数 递归时传入总价格减去已经使用的价格数的不同情况，并使用display函数进行字符串拼接来显示 Cities ADT 以下问题基于建立的该ADT 一个城市由以下参数描述：名称、经度、维度 包括一个构造函数 - make_city(name, lat, lon)：建立一个城市对象，存储其名称、经度、维度 以下选择器 - get_name(city)：获取城市名称 - get_lat(city)：获取城市经度 - get_lon(city)：获取城市维度 该抽象数据类型已经在文件中实现，你不需要知道是怎么实现的 Distance 计算并返回两城市的距离 12345678910111213from math import sqrt def distance(city_a, city_b): \"\"\" &gt;&gt;&gt; city_a = make_city('city_a', 0, 1) &gt;&gt;&gt; city_b = make_city('city_b', 0, 2) &gt;&gt;&gt; distance(city_a, city_b) 1.0 &gt;&gt;&gt; city_c = make_city('city_c', 6.5, 12) &gt;&gt;&gt; city_d = make_city('city_d', 2.5, 15) &gt;&gt;&gt; distance(city_c, city_d) 5.0 \"\"\" return sqrt(abs(get_lat(city_a)-get_lat(city_b))**2+abs(get_lon(city_a)-get_lon(city_b))**2) Closer City 比较两个城市离给定经纬度的远近，返回更近的那个城市 1234567891011121314151617181920def closer_city(lat, lon, city_a, city_b): \"\"\" Returns the name of either city_a or city_b, whichever is closest to coordinate (lat, lon). If the two cities are the same distance away from the coordinate, consider city_b to be the closer city. &gt;&gt;&gt; berkeley = make_city('Berkeley', 37.87, 112.26) &gt;&gt;&gt; stanford = make_city('Stanford', 34.05, 118.25) &gt;&gt;&gt; closer_city(38.33, 121.44, berkeley, stanford) 'Stanford' &gt;&gt;&gt; bucharest = make_city('Bucharest', 44.43, 26.10) &gt;&gt;&gt; vienna = make_city('Vienna', 48.20, 16.37) &gt;&gt;&gt; closer_city(41.29, 174.78, bucharest, vienna) 'Bucharest' \"\"\" fake_city = make_city('fake', lat, lon) if distance(fake_city,city_a)&lt;distance(fake_city,city_b): return get_name(city_a) else: return get_name(city_b) 可以将指定的经纬度看作第三个城市并构造这么一个对象 通过上面已经写完的distance函数计算两城市与第三个城市的距离并比较，输出更近的 若相同输出city_b","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Data Abstraction","slug":"CS61A——Data Abstraction","date":"2025-03-03T12:52:03.826Z","updated":"2025-03-03T13:06:05.083Z","comments":true,"path":"2025/03/03/CS61A——Data Abstraction/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Data%20Abstraction/","excerpt":"","text":"Data Abstraction Data Abstraction 大多数值都是复合值，由多种对象组成 抽象数据类型可以让我们将符合对象作为一个单元操作，允许我们隔离使用数据的程序的两个部分： 数据的表示 数据的操作 即在数据的表示与操作之间建立一个抽象屏障 Example——Rational Numbers 表示 任何有理数可以表示为一个最简分数 这为小数提供了更精确的表示方法 故我们需要分开分子分母，作为一个复合数据类型： rational(n,d)返回一个有理数x numer(x)返回有理数x的分子 denom(x)返回有理数的分母 第一个函数称为构造函数（constructor），它用于构造一个新值作为抽象数据类型的实例（instance） 第二、三个函数称为选择器（selectors），它们返回得到的有理数的整数部分 这三个函数作为有理数的抽象数据类型使用，用它们进行数字操作 算术 根据小学二年级知识，我们根据分数来执行有理数加乘，公式如下 有理数算术 12345678910def mul_rational(x,y): return rational(numer(x)*numer(y),denom(x)*denom(y)) def add_rational(x,y): nx, dx = numer(x), denom(y) ny, dy = numer(y), denom(y) return rational(nx*dy+ny*dx, dx*dy) def equal_rational(x,y): return numer(x)*denom(y)==numer(y)*denom(x) Abstraction Barriers 拿上方的有理数函数作为例子 抽象屏障 抽象屏障表示使用由有理数计算时使用的函数只能是对应相关的，而不能越界表示 用有理数计算时只需要使用计算相关函数 用来表示有理数和进行操作时只需要使用对应构造函数与选择器 用来构建构造函数与选择器时需要用到列表与元素选择 一种跨越了抽象屏障的反例： 1234add_rational([1,2],[1,4]) def divide_rational(x,y): return [x[0]*y[1], x[1]*y[0]] Pair 创建与访问 通常使用列表表示一个pair 123&gt;&gt;&gt; pair = [1,2] &gt;&gt;&gt; pair [1,2] 通过序列解包或列表下标获得pair中的两个值 1234567&gt;&gt;&gt; x,y=pair &gt;&gt;&gt; x 1 &gt;&gt;&gt; y 2 &gt;&gt;&gt; pair[0] 1 还可以用getitem函数获得值，在operator库中 用法：getitem(&lt;list&gt;, &lt;index&gt;) 1234&gt;&gt;&gt; getitem(pair, 0) 1 &gt;&gt;&gt; getitem(pair, 1) 2 用pair表示有理数 123def rational(n,d): \"\"\"Construct a rational number that represents N/D\"\"\" return [n, d] 返回一个列表，记录分子分母用来表示有理数 1234567def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x[0] def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x[1] 通过访问列表中的元素返回分子分母 应用 分数通分 有理数的分子分母应互质，故我们可以用gcd获取它们的最大公因数来同时除以分子分母以确保获得互质的分子分母 1234from fractions import gcd def rational(n,d): g = gcd(n,d) return [n//g, d//g] Data Representation 数据抽象的基本思想：通过它的行为来识别该抽象数据类型 改变有理数的表现形式 1234567891011121314def rational(n,d): def select(name): if name == 'n': return n elif name == 'd': return d return select def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x('n') def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x('d') 这里使x成为一个函数，这样就可以不需要内置的列表数据类型了 此时rational是一个高阶函数，返回一个表示有理数的函数","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab3","slug":"CS61A——Lab3","date":"2025-03-03T12:51:43.540Z","updated":"2025-03-03T13:04:15.175Z","comments":true,"path":"2025/03/03/CS61A——Lab3/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Lab3/","excerpt":"","text":"WWPD部分省略 Print If 返回列表中满足函数f的元素 12345678910111213141516def print_if(s, f): \"\"\"Print each element of s for which f returns a true value. &gt;&gt;&gt; print_if([3, 4, 5, 6], lambda x: x &gt; 4) 5 6 &gt;&gt;&gt; result = print_if([3, 4, 5, 6], lambda x: x % 2 == 0) 4 6 &gt;&gt;&gt; print(result) # print_if should return None None \"\"\" for x in s: if f(x): print(x) return None Close 返回列表中元素大小与下标差的绝对值小于规定值的元素个数 123456789101112131415161718def close(s, k): \"\"\"Return how many elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close(t, 0) # Only 3 is equal to its index 1 &gt;&gt;&gt; close(t, 1) # 2, 3, and 5 are within 1 of their index 3 &gt;&gt;&gt; close(t, 2) # 2, 3, 4, and 5 are all within 2 of their index 4 &gt;&gt;&gt; close(list(range(10)), 0) 10 \"\"\" count = 0 for i in range(len(s)): # Use a range to loop over indices if abs(s[i]-i)&lt;=k : count+=1 return count Close List 返回一个列表，元素为给定列表中元素大小与下标差的绝对值小于规定值的元素 123456789101112def close_list(s, k): \"\"\"Return a list of the elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close_list(t, 0) # Only 3 is equal to its index [3] &gt;&gt;&gt; close_list(t, 1) # 2, 3, and 5 are within 1 of their index [2, 3, 5] &gt;&gt;&gt; close_list(t, 2) # 2, 3, 4, and 5 are all within 2 of their index [2, 4, 3, 5] \"\"\" return [s[i] for i in range(len(s)) if s[i]-i&lt;=k] Squares Only 返回一个列表，元素为给定列表中为完全平方数的元素 1234567891011121314from math import sqrt def squares(s): \"\"\"Returns a new list containing square roots of the elements of the original list that are perfect squares. &gt;&gt;&gt; seq = [8, 49, 8, 9, 2, 1, 100, 102] &gt;&gt;&gt; squares(seq) [7, 3, 1, 10] &gt;&gt;&gt; seq = [500, 30] &gt;&gt;&gt; squares(seq) [] \"\"\" return [int(sqrt(n)) for n in s if sqrt(n)==round(sqrt(n))] 注意返回的是开方后的数，是整数 Double Eights 使用递归判断给定的数中是否存在相邻的两个8 123456789101112131415161718192021222324252627def double_eights(n): \"\"\" Returns whether or not n has two digits in row that are the number 8. Assume n has at least two digits in it. &gt;&gt;&gt; double_eights(1288) True &gt;&gt;&gt; double_eights(880) True &gt;&gt;&gt; double_eights(538835) True &gt;&gt;&gt; double_eights(284682) False &gt;&gt;&gt; double_eights(588138) True &gt;&gt;&gt; double_eights(78) False &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(LAB_SOURCE_FILE, 'double_eights', ['While', 'For']) True \"\"\" if n==0: return False if n%100==88: return True else: return double_eights(n//10) Making Onions 判断是否能通过f函数与g函数进行至多limit次操作实现将x转化为y 1234567891011121314151617181920212223242526272829303132def make_onion(f, g): \"\"\"Return a function can_reach(x, y, limit) that returns whether some call expression containing only f, g, and x with up to limit calls will give the result y. &gt;&gt;&gt; up = lambda x: x + 1 &gt;&gt;&gt; double = lambda y: y * 2 &gt;&gt;&gt; can_reach = make_onion(up, double) &gt;&gt;&gt; can_reach(5, 25, 4) # 25 = up(double(double(up(5)))) True &gt;&gt;&gt; can_reach(5, 25, 3) # Not possible False &gt;&gt;&gt; can_reach(1, 1, 0) # 1 = 1 True &gt;&gt;&gt; add_ing = lambda x: x + \"ing\" &gt;&gt;&gt; add_end = lambda y: y + \"end\" &gt;&gt;&gt; can_reach_string = make_onion(add_ing, add_end) &gt;&gt;&gt; can_reach_string(\"cry\", \"crying\", 1) # \"crying\" = add_ing(\"cry\") True &gt;&gt;&gt; can_reach_string(\"un\", \"unending\", 3) # \"unending\" = add_ing(add_end(\"un\")) True &gt;&gt;&gt; can_reach_string(\"peach\", \"folding\", 4) # Not possible False \"\"\" def can_reach(x, y, limit): if limit &lt; 0: return False elif x == y: return True else: return can_reach(f(x), y, limit - 1) or can_reach(g(x), y, limit - 1) return can_reach","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【算法】BFS","slug":"BFS","date":"2025-03-01T03:30:53.100Z","updated":"2025-03-01T03:31:12.066Z","comments":true,"path":"2025/03/01/BFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/BFS/","excerpt":"","text":"BFS 参考视频1_ 参考视频2 预备知识：队列 特点：先进先出（FIFO），队头删除元素，队尾插入元素 基本用法：见文件 对于bfs，我们需要一层一层遍历所有节点，那么相邻节点的访问顺序该如何确定？因此我们需要队列去存储和操作，需要使先遍历到的结点先被存储，直到当前层都被存储之后，按存储的先后顺序，先被存储的节点也会先被取出，继续遍历子节点。符合队列的FIFO特点 基本思想 解决问题 从A出发是否存在到达B的路径（DFS也行） 从A出发到达B的最短路径（DFS+剪枝也行，容易TLE） 基本思想 从初始状态s（图上某个节点出发）开始利用规律，生成所有可能状态，构成树的下一层节点 检查是否出现目标状态g，若未出现则对该层所有状态节点分别利用规则，生成在下一层的所有状态节点 对新一层继续检查重复上述操作直到出现目标状态 注意：BFS实际上是传回经过边数最少的解，因此对于所有边长度（边权）相同的情况，此时就一定是从根节点到目标节点最短的路径，BFS先找到的就一定是最短的，但如果是加权边，BFS传回的就不一定最短了。对于加权路径的最短路，我们使用Dijkstra算法求解。 基本步骤 起始：将起点（根节点）放入队列中 扩散：从队列中取出队头结点，将其相邻节点放入队列，不断重复 终止：当队列为空是，说明遍历完了所有节点 空间复杂度 ：b为最大分支系数，n为树高 板子 1234567891011121314151617Node bfs(node source, node target){ memset(visit, 0 , sizeof(visit)); queue&lt;node&gt; q; q.push(source); visit[source] = 1; while(!q.empty()){ Node a = q.front(); q.pop(); if (a==target) return a; for (/*对于a所有的后继节点b*/){ if (visit[b]) continue; q.push(b); visit[b]=1; // 剪枝,保证节点只进队列一次 } return NULL; } } 例：二叉树的层次遍历-queue的实现解释 层次遍历：从上到下，从左到右进行遍历 思想 维护队列，用于存放节点信息，当访问到一个节点时，先访问该节点，然后将该节点的左右儿子分别入队列 伪代码 12345678910bfs(int root){ queue&lt;int&gt; q; q.push(root); while q不为空： 获得队首元素 队首元素出队 输出当前节点值 if 该节点左儿子不为空：将左儿子加入队列 else if 该节点右儿子不为空：将右儿子加入队列 } 例：对于一个层次遍历：5172463的树 ​ 队列q： ​ 放入root节点：q：5 ​ 队列空否？ 不空，输出5并删除，q： ​ 有孩子否？有，放入5的左右孩子1 7，q：1 7 ​ 队列空否？ 不空，输出1并删除，q：7 ​ 有孩子否？有，放入1的左右孩子2 4，q：7 2 4 ​ 队列空否？ 不空，输出7并删除，q：2 4 ​ 有孩子否？有，放入7的左右孩子6 3，q：2 4 6 3 ​ 队列空否？ 不空，输出2并删除，q：4 6 3 ​ 有孩子否？无，继续，q：4 6 3 ​ 剩下三个相同 q：6 3 q：6 q： ​ 例：图的bfs image-20241112203528097 图与树类似，但图任何两点间都可以有边，故方法相似 但图没有层次关系，访问的是某点的邻接点，若一个点已经访问过就没必要在访问了：如B的邻接点AEC，若想要放进去子节点，则AE没有必要再入队列 步骤：放入起始节点，循环判断队列空不空，若不空则放入相邻节点 BFS最适合的：寻找最少几步能达到目标（特殊的最短路问题） 例：奇怪的电梯 奇怪的电梯 题目描述 呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 层楼（）上有一个数字 （）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： 代表了 （，，……），从 楼开始。在 楼，按“上”可以到 楼，按“下”是不起作用的，因为没有 楼。那么，从 楼到 楼至少要按几次按钮呢？ 输入格式 共二行。 第一行为三个用空格隔开的正整数，表示 （，）。 第二行为 个用空格隔开的非负整数，表示 。 输出格式 一行，即最少按键次数，若无法到达，则输出 -1。 样例 #1 样例输入 #1 125 1 5 3 3 1 2 5 样例输出 #1 13 提示 对于 的数据，，，。 本题共 个测试点，前 个每个测试点 分，最后一个测试点 分。 如样例：从1楼到5楼，可以从1-&gt;4-&gt;2-&gt;5 按三次按钮 搜索状态：从一个状态出发，根据题目不断转移状态直到到达目标状态，对实例如图： 如题：从1楼开始 1楼只能往上到4楼，四楼只能往下到2楼，二楼只能往上到五楼 ​ 所以这是一个典型的二叉树，起始状态为起点，目标状态为样例输入的楼层 记录按按钮次数：使用结构体将楼层和按钮次数封装 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 300; struct node{ // 保存按钮次数 int level; // 当前楼层 int steps; // 走到当前楼层所需要步数 }floors[N]; int n,st,ed; // 总楼层数,起始楼层,目标楼层 int a[N], vis[N]; // 分别保存每个楼层可以移动几层, 该楼层是否来过 void bfs(){ queue&lt;node&gt; q; node cur, net; // 记录当前状态与下一状态 cur.level = st; // 当前位于起点，楼层为起始楼层 cur.steps = 0; // 所需步数为0 q.push(cur); // 存入根节点 vis[st]=1; // 起始已经走过，设为1；因为过去以后无需返回，返回得到的值一定更大 while(!q.empty()){ // 队列非空 cur = q.front(); // 取出队首 q.pop(); // 删掉 if (cur.level == ed){ // 如果取出的对手即为目标楼层，则可以结束 cout &lt;&lt; cur.steps; return ; } // 向上扩展 net.level = cur.level + a[cur.level] ; // 下一步可以走到哪个楼层 net.steps = cur.steps+1; // 步数加1 if (net.level&lt;=n){ // 不超最高楼层 if (vis[net.level]==0){ // 若没有来过 vis[net.level] = 1; // 可以去 去完标记已来过 q.push(net); // 将子节点放到队列里 } } // 向下扩展 net.level = cur.level - a[cur.level]; net.steps = cur.steps+1; if (net.level&gt;=1){ if (vis[net.level]==0){ vis[net.level] = 1; q.push(net); } } } cout &lt;&lt; -1; // 找不到咯 return ; } int main(){ ios; cin &gt;&gt; n &gt;&gt; st &gt;&gt; ed; for (int i = 1; i&lt;= n;i++){ cin &gt;&gt; a[i]; vis[i]=0; // 初始化 } bfs(); return 0; } 例：非常可乐 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample 输入 1237 4 3 4 1 3 0 0 0 输出 12No 3 看似找不出图的一个搜索：只要根据信息能表示出状态，且状态能根据规则进行转移就可以用搜索 定义节点状态：三杯水量+当前状态最少倒水次数 状态转移如图（以4 1 3为例，最后一位是次数）： image-20241112220340957 目标状态：达到两个量相等一个量为0 倒水要求：只能倒满或者倒空 这种题目称为隐式图 如何剪枝：访问过的节点不在访问 例：离开中山路 离开中山路 题目背景 《爱与愁的故事第三弹·shopping》最终章。 题目描述 爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 处，车站在 处。现在给出一个 的地图， 表示马路， 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 ）。你能帮他解决吗？ 输入格式 第 行包含一个数 。 第 行到第 行：整个地图描述（ 表示马路， 表示店铺，注意两个数之间没有空格）。 第 行：四个数 。 输出格式 只有 行，即最短到达目的地距离。 样例 #1 样例输入 #1 123453 001 101 100 1 1 3 3 样例输出 #1 14 提示 对于 数据，满足 。 对于 数据，满足 。 可以使用方向数组来转移状态: 对于网格地图,可以定义一个二维数组 int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}}; 则遍历四个方向可以 1234for (int i = 0; i &lt;4; i++){ x2 = x1+dir[i][0]; y2 = y1+dir[i][1]; } 坑点：输入中间无空格，是一起输入的，需要用字符串转换为某行某列（ascii转化，char - 'a'）存入数组 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*迷宫问题如果要求最短路径（权值为1）相关，则可以选用bfs 这里可以将迷宫看作图，详见markdown中图的遍历 */ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 1010; typedef pair&lt;int,int&gt; PII; int n,sx,sy,ex,ey; // 记录地图大小，起点终点 int mmap[N][N], vis[N][N]; // 记录地图和是否走过（走过不用再往回走，不然步数一定更长） int dx[]={-1,0,1,0}; // 方向数组x int dy[]={0,1,0,-1}; // 方向数组y // 结构体记录坐标与步数 struct node{ int first; // 当前x坐标 int second; // 当前y坐标 int steps; // 当前步数 }; void bfs(){ queue&lt;node&gt; q; // 队列 node cur, net; // 记录当前状态与下一状态 cur.first = sx, cur.second = sy, cur.steps = 0; // 初始化为起始坐标，步数为0 vis[sx][sy] = 1; // 不要忘了起始坐标设为1 q.push(cur); // 根节点入队 while(!q.empty()){ // 队列变空时搜索完毕 cur = q.front(); // 取出队首 q.pop(); // 删除队首 if (cur.first == ex &amp;&amp; cur.second == ey){ // 到达终点 cout &lt;&lt; cur.steps; //输出步数 return ; // 跳出 } for (int i = 0;i &lt;4; i++){ net.first = cur.first+dx[i]; // 下一步的x坐标 net.second = cur.second+dy[i]; // 下一步的y坐标 if (net.first&lt;1||net.second&lt;1||net.first&gt;n||net.second&gt;n) continue; // 超出边界 if (mmap[net.first][net.second]) continue; // 碰到障碍 if (vis[net.first][net.second]) continue; // 已经访问 net.steps = cur.steps +1; // 若满足前进的条件就前进一步 vis[net.first][net.second] = 1; // 把访问过的地方标记 q.push(net); // 将子节点入队列 } } return ; } int main(){ ios; cin &gt;&gt; n; string s; // 注意：这里题目输入间没有空格，相当于是输入一整个数字，需要手动拆开 // 这里用转成字符串用ascii转化的方法 for (int i = 1;i &lt;=n;i++){ cin &gt;&gt; s ; for (int j = 1;j &lt;=n;j++){ mmap[i][j] = s[j-1]-'0'; vis[i][j]=0; } } cin &gt;&gt; sx &gt;&gt;sy &gt;&gt; ex &gt;&gt; ey; bfs(); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【算法】DFS","slug":"DFS","date":"2025-03-01T03:29:57.440Z","updated":"2025-03-01T03:30:36.654Z","comments":true,"path":"2025/03/01/DFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/DFS/","excerpt":"","text":"DFS 参考视频 前置知识：二叉树的遍历 三种遍历 先根遍历（根左右） 中根遍历（左根右） 后根遍历（左右根） 注意：这里的左右为左右子树 e.g. 1. 先根遍历：271653894 1. 中根遍历：175632849 1. 后根遍历：153674982 二叉树的确定 给定先根和中根、中根和后根遍历结果，可以唯一确定二叉树 e.g. 上面，在先根中确定2为根，在中根中找到2，则2前后分别为其左右子树；再在先根中找到7，在中根中找到7，则7前后为其左右子树，以此类推。中根后根与前根后根是对称的。 给定先根和后根遍历结果，不能唯一确定二叉树 只知道根数量而不知道左右子树数量 递归 递归特征：大问题与子问题除了规模其他都一样 斐波那契数列的递归实现 1234int fi(int a){ if (a==0||a==1) return 1; else return fi(a-1)+fi(a-2); } 即有一个特定模板： 即先写程序出口（不需要递归的特殊情况），再写普通情况（递归） 全排列问题 输入一个正整数n，按字典序输出n-1的全排列 递归特征 若第一个数确定，剩余的问题就是其余n-1个数的全排列 若前k个数已经排好，剩余问题就是其余n-k个数的全排列 代码实现 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; using namespace std; int n; int num[10], vis[10]; void dfs(int step); int main(){ while (scanf(\"%d\",&amp;n)==1){ memset(vis,0,sizeof vis); dfs(1); // 从第一位开始处理 } return 0; } void dfs(int step){ // 接下来准备处理第step位 if (step==n+1){ // 前n位都放好了，进行输出 for (int i = 1; i &lt;=n; i++) printf(\"%d\", num[i]); printf(\"\\n\"); return ; } for (int i = 1;i &lt;= n;i++){ if (vis[i]==0){ // 第i位数没用过 num[step]=i; // nun中当前这一位保存一个i vis[i]=1; // i被用过了，做标记1 dfs(step+1); vis[i]=0; } } } 若n==3： vis：0 0 0 0 step==1 ​ 进入for循环: vis[1]==0 ​ 使num[1]=1 vis[1] = 1 ​ num： 0 1 0 0 0 ​ vis：0 1 0 0 表示1用过了 vis： 0 1 0 0 step==2 ​ 进入for循环: vis[2]==0 ​ num[2]=2 vis[2] = 1 ​ num： 0 1 2 0 0 ​ vis：0 1 1 0 表示1,2用过了 vis：0 1 1 0 step==3 ​ 进入for循环: vis[3]==0 ​ num[3]=3 vis[3] = 1 ​ num： 0 1 2 3 0 ​ vis：0 1 1 1 表示1,2,3用过了 vis：0 1 1 1 step==4 ​ step == 3+1成立，到达边界，则输出num[1]到num[n] 123 ​ return 到dfs(3)中（谁调用的返回谁） dfs(3)：vis[3]=0 vis：0 1 1 0 程序结束返回dfs(2) dfs(2)：vis[2]=0 vis：0 1 0 0 ​ 此时进行下一次循环 i==3，vis[3]==0 ​ num[2]=3,vis[3]=1 ​ num： 0 1 3 0 ​ vis：0 1 0 1 表示1,3用过了 ​ 再进入dfs(3)，重复上述操作后 ​ num：0 1 3 2 ​ vis：0 1 1 1 ​ 进入dfs(4)到达边界输出 132 ​ return 到dfs(3)中重复上述过程 若没有vis[i]=0的回溯，则第一遍return后vis仍保持全标记1状态，则无法再输出其他排列直接结束 基本模型 关键在于着眼于当下如何做，下一步的做法与当前一样，只是参数不同 123456void dfs(int step){ 特殊情况处理(结束递归情况) 枚举当前每一种可能for(int i=1;i&lt;=;i++) 在枚举的每一种可能中，递归dfs(step+1); 回溯 } 例：迷宫搜索 Tempter of the Bone Problem Description The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze. The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. Input The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following: ‘X’: a block of wall, which the doggie cannot enter; ‘S’: the start point of the doggie; ‘D’: the Door; or ‘.’: an empty block. The input is terminated with three 0’s. This test case is not to be processed. Output For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise. Sample Input 123456789104 4 5 S.X. ..X. ..XD .... 3 4 5 S.X. ..X. ...D 0 0 0 Sample Output 12NO YES 分析： 每个block只能走一次 恰好给定时间到达出口 剪枝条件： 若可走的block总数小于时间：全走完都开不了门，肯定NO 若起点在左上角，门在右下角，没有障碍物且最短路径（曼哈顿距离：行坐标差减列坐标差）都比时间长，肯定NO 奇偶性剪枝（应用条件：每个格子只能等一秒）： 使行列坐标相加为偶数的标为0，为奇数的标为1，发现1的下一步一定为0，0的下一步一定为1 那么如果从0走到1或从1走到0，所需时间为奇数；如果从1走到1或从0走到0，所需时间为偶数 那么如果规定时间为偶数，则从0到1或从1到0肯定NO，反之亦然。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; char mmap[9][9]; // 存储地图 注意地图要比数据范围大一点 int n,m,t,escape; int si,sj,di,dj; // 记录起始与结束点坐标 int dir[4][2]={{0,-1},{0,1},{-1,0},{1,0}}; // 进行上下左右四个方向的行走 void dfs(int x, int y, int cnt){ // 行列坐标，已经花的时间 if (x&gt;n||y&gt;m||x&lt;=0||y&lt;=0) return ; // 越过边界，跳过 if (cnt==t&amp;&amp;x==di&amp;&amp;y==dj) { // 在开门时间到达出口 escape=1; // 标记逃离成功 } if (escape) return ; // t-cnt:剩余时间 两abs:剩余距离 int tmp=((t-cnt)-abs(di-x)-abs(dj-y)); // 小于零：剩余时间内走不到终点 /* 是奇数：为了到达门口，剩余时间与剩余距离的奇偶性一定要相同 奇数-奇数=偶数 偶数-偶数=偶数 故tmp一定要是偶数才能保证走到门口，否则包走不到 即奇偶性剪枝 */ // 该奇偶性剪枝可以在主函数里写，因为时间和距离是同步进行的 if (tmp&lt;0) return ; // 四个方向遍历 for (int i = 0 ;i &lt; 4;i++){ if (mmap[x+dir[i][0]][y+dir[i][1]]!='X'){ // 不是障碍物 mmap[x+dir[i][0]][y+dir[i][1]]='X'; //修改 dfs(x+dir[i][0],y+dir[i][1],cnt+1); //递归 mmap[x+dir[i][0]][y+dir[i][1]]='.'; //回溯，这样可以回到上一步换一条路走 } } return ; } int main(){ while(cin &gt;&gt; n &gt;&gt; m &gt;&gt;t){ if (n==0&amp;&amp;m==0&amp;&amp;t==0) break; // 结束条件 int block = 0; // 障碍物数量：用来剪枝 for(int i = 1;i &lt;=n;i++){ for(int j = 1; j&lt;=m;j++){ cin &gt;&gt; mmap[i][j]; if (mmap[i][j]=='S') { si=i; sj=j; } else if (mmap[i][j]=='D') { di=i; dj=j; } else if (mmap[i][j]=='X') block++; } } // 剪枝1：迷宫格子数量减去障碍物数量小于等于开门时间，一定出不去 if (n*m-block&lt;=t) { cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // 剪枝2：见dfs里的解释 if ((t-(abs(di-si)+abs(dj-sj)))%2==1){ cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // escape标记是否成功，把起点标为障碍物，确保不会再回来 escape = 0, mmap[si][sj]='X'; dfs(si,sj,0); // 判断是否能逃离 if (escape) cout &lt;&lt;\"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【算法】前缀和与差分","slug":"前缀和与差分","date":"2025-03-01T02:53:46.740Z","updated":"2025-03-01T03:30:26.716Z","comments":true,"path":"2025/03/01/前缀和与差分/","permalink":"https://izayoisakuye.github.io/2025/03/01/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和与差分 一维前缀和 e.g. 给定长度为n的数组arr, 求q次询问中每次arr在[l,r]的区间和 暴力枚举的时间复杂度为O(qn) 容易TLE 使用前缀和可以极大减少运行时间 前缀和数组 定义一个前缀和数组prefix[i]=prefix[i-1]+arr[i]，其中i&gt;0 i=0时sum[0]=arr[0] 则对于数a1,a2,a3,a4,a5…. prefix[1]=a1 prefix[2]=a1+a2 prefix[3]=a1+a2+a3 … 可以看出，prefix[i]为区间[0,i]的和 在求区间的和时，如2-4，就可以使用prefix[4]-prefix[1],通式为prefix[r]-prefix[l-1], l=0时为prefix[r] 其中，求前缀和的过程成为预处理 板子 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; //#define get_sum(l, r) ((l)?(sum[r]-sum[l]):(sum[r])) using namespace std; const int N = 10000; int a[N], prefix[10000]; int get_sum(int l , int r){ if (l) return prefix[r]-prefix[l-1]; else return prefix[r]; } int main(){ ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // 预处理，一般以1开始为下标 for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // 访问 int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; //cout &lt;&lt; prefix[r]-prefix[l-1]; cout &lt;&lt; get_sum(l,r); } return 0; } 二维前缀和 给定一个长n,宽m的矩阵: 求矩阵任意两点间矩形的数字之和 二维前缀和数组 定义一个二维前缀和数组prefix[i][j] =prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]，其中i&gt;0 其中，prefix[i][j]为从(0,0)到(i,j)的和 当i=0且j=0时，prefix[0][0]=a[0][0] 当i=0且j!=0时，prefix[0][j]=prefix[0][j-i]+a[0][j] 当i!=0且j=0时，prefix[i][0]=prefix[i-1][0]+a[i][0] 如下图： 即prefix[i][j]是由a[i][j],prefix[i-1][j],prefix[i][j-1]组成的，但两块加多了一块prefix[i-1][j-1]，故减去 若要求解某部分矩形，就可以进行以上的逆过程 a[i][j]=prefix[i][j]-prefix[i-1][j]-prefix[i][j-1]+prefix[i-1][j-1] 从prefix[i][j]开始，求a[i][j]，则可以依次减去prefix[i-1][j],prefix[i][j-1]，但会多减一块prefix[i-1][j-1]，故加上 板子 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m; int a[N][N]; int prefix[N][N]; void pre_sum(){ /*以下代码是当for循环从0开始时的初始化 prefix[0][0]=a[0][0]; for (int i = 1;i &lt;n;i++) prefix[i][0] = prefix[i-1][0]+a[i][0]; for (int j = 1;j &lt;m;j++) prefix[0][j] = prefix[0][j-1]+a[0][j]; */ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]; } } } int get_sum(int x1, int y1, int x2, int y2){ /*以下为从0开始时的特殊情况 // 从0,0开始加 if (!x1 &amp;&amp; !y1) return prefix[x2][y2]; // 成行相加 if (!x1) return prefix[x2][y2]-prefix[x2][y1-1]; // 成列相加 if (!y1) return prefix[x2][y2]-prefix[x1-1][y2]; */ return prefix[x2][y2]-prefix[x1-1][y2]-prefix[x2][y1-1]+prefix[x1-1][y1-1]; } int main(){ int x1,y1,x2,y2; cin &gt;&gt; n &gt;&gt;m; for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; } } cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; pre_sum(); cout &lt;&lt; get_sum(x1,y1,x2,y2); return 0; } 一维差分 给定长度为n的数组arr，进行m个操作，使[l,r]区间内的值都加一个value，操作结束后，询问arr 暴力解法：每次遍历数组[l,r]执行加value操作，遍历m次，时间复杂度O(n*m) 例如 arr中有五个数 1 3 7 5 2 对[2,4] +5 [1,3] +2 [0,2] -3 对于下标为2的数分析，7+5+2-3=11. 若不管中间，则相当于7+4=11. 则我们的目的即为让中间的步骤省略，最后只+4. 差分数组 定义一个差分数组d[i]=arr[i]-arr[i-1] 则对d进行前缀和，得到前缀和数组sum，我们可以发现： ​ 差分数组可以通过前缀和得到原数组 ​ 即d[i]+=d[i-1] 差分标记 对于一位差分区间修改：[l,r]+valued[l]+value, d[r+1]-value 对于以上arr 对应差分数组d为1 2 4 -2 -3 第一次操作等价于d[2]+5 结果为1 2 9 -2 -3 第二次等价于d[1]+2,d[4]-2 结果为1 4 9 -2 -5 第三次：-2 4 9 1 -5 进行前缀和得到sum -2 2 11 12 7 注意： 把标记后的差分数组进行一次前缀和操作 每进行m次操作后都要进行一次前缀和 即适用于多次操作单次询问（单次操作单次询问不适用） 原理： 差分数组中，标记位加了一个数，还原成原数组的时候，后面的数都会累加，然后再r+1位在减去这个数停止累加 最终实现的效果为：sum[l,r]+value, sum[r+1,n-1] +value - value 如：对于差分数组d 0 1 0 0 0，进行一次前缀和后其sum为 0 1 1 1 1，即标记位加的数会作用与该标记之后每一位，即d[i]+value sum[i,n-1]+value 若想在某位置停止累加，在该位置+1处减掉value即可，如 d 0 1 0 0 -1，前缀和后sum为 0 1 1 1 0，加一减一抵消为0，即d[r+1]-value sum[r+1,n-1]-value 板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt; using namespace std; int main(){ int a[10000]={0}, diff[10000]={0}, prefix[10000]={0}; int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // 预处理，得到差分数组，一般以1开始为下标 for (int i = 1; i &lt;= n; i++) { diff[i] = a[i]-a[i-1]; } // 对区间元素处理 // 想让区间元素都+x，则可以让l右边都加x，再r右边都-x int m; cin &gt;&gt; m; while(m--){ int l, r, x; cin &gt;&gt; l&gt;&gt; r&gt;&gt; x; // 进行差分标记 diff[l]+=x, diff[r+1]-=x; } // 对差分数组进行前缀和得出结果 for (int i = 1; i &lt;=n; i++) { a[i] = a[i-1] +diff[i]; } // 再进行前缀和以应对接下来的访问 for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // 访问 int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; prefix[r]-prefix[l-1]; } return 0; } 二维差分 给定长n,宽m的矩阵，从(xi,yi)到(xj,yj)执行m次操作，使两点间矩形中的值都加一个value，操作结束后，询问矩阵 大体思路与一维差分差不多 差分矩阵 定义一个差分矩阵：d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1] 或者可以将差分矩阵中的元素一个个插入： 即若原矩阵(x,y)处值为value，则相当于从左上角(x,y) 到右下角(x,y)都加value,也可以使用差分标记实现 差分标记 对于二位差分区间修改：[(xi,yi),(xj,yj)]+valued[xi][yi]+value, d[xj+1][yi]-value, d[xi][yj+1]-value, d[xj+1][yj+1]+value 原理如图： 板子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m,cnt=0; int a[N][N]; int prefix[N][N]; int d[N][N]; // 差分标记 &amp;&amp;初始化差分矩阵 void add(int x1, int y1, int x2, int y2,int value){ d[x1][y1]+=value; d[x2+1][y1]-=value; d[x1][y2+1]-=value; d[x2+1][y2+1]+=value; } int main(){ cin &gt;&gt; n &gt;&gt;m &gt;&gt; cnt; // 输入每个数并计算差分矩阵 for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; add(i,j,i,j,a[i][j]); } } // 进行差分标记 for (int i = 1; i &lt;=cnt;i++){ int x1,y1,x2,y2,value; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2&gt;&gt;value; add(x1,y1,x2,y2,value); } // 对差分数组进行一次前缀和得到结果 for (int i = 1 ;i &lt;=n;i++){ for (int j = 1;j &lt;=m;j++){ a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + d[i][j]; } } for (int i = 1;i &lt;= n; i++){ for (int j = 1; j &lt;= m; j++){ cout &lt;&lt; a[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【Python】CS61A——Containers","slug":"CS61A——Containers","date":"2025-02-25T08:44:27.451Z","updated":"2025-02-25T08:45:19.402Z","comments":true,"path":"2025/02/25/CS61A——Containers/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Containers/","excerpt":"","text":"Containers Slicing 切片可以简洁的获取列表中的子列表，实质是创建了新的列表而不影响原始列表 如列表odds = [3,5,7,9,11] odds[1:3] -&gt; [5,7] 默认也是包括起始值不包括结束值 odds[:3] -&gt; [3,5,7] 省略开头将从列表头开始算起 odds[1:] -&gt; [5,7,9,11] 省略结尾将覆盖至列表尾 内置函数 sum sum(&lt;可迭代对象&gt;, [起始值]) 返回所有可迭代元素和并加上起始值，起始值默认为0 sum还可以实现列表相加：sum([[2,3],[4]],[]) 注意起始值类型要和前面相同 max max(&lt;可迭代对象&gt;, [键函数]) max(a,b,c,..., [键函数]) 返回对象中的最大值或返回若干值中的最大值 键函数：考虑对每个元素执行键函数并根据返回值比较大小（返回原始值） e.g. max(range(10), key=lambda x: 7-(x-4)*(x-2)) all all(&lt;可迭代对象&gt;) 对每个元素执行bool(x)操作，若所有元素都返回True则返回True，否则返回False，空列表返回True e.g. all([x&lt;5 for x in range(5)]) 返回True len len(&lt;可迭代对象&gt;) 获取某个序列长度 有关string string可以用于表示：数据、语言、程序 表示字符串 使用单引号 使用双引号 使用一对连续的三个双引号：可以跨行 string也是一种sequence 求解长度与选择元素与列表相同 获取到的string中的元素本身也是一个字符串，但只有它本身一个元素 in与not in可以在字符串中寻找连续字符 e.g. 'here' in 'where's waldo? 返回True Dictionary dictionary用于存储键值对，使用花括号和冒号分隔键值 创建： numerals = {'I':1, 'V':5, 'X':10} 可以用数字，字符串当键值，列表或字典 当值 注意：键本身不能是列表或字典，键不能重复 查找： 输入对应的键来查找对应的值，但不能通过值查找键 numerals['V'] &gt;&gt;&gt; 5 遍历： dictionary是键的序列，通过list()创建列表可以获得所有的键，因此可以用for循环遍历所有的键 使用numerals.value()获得字典中所有的值，存储在一个序列中（非列表） Dictionary Comprehensions 可以使用表达式来创建列表 格式：{&lt;key exp&gt;: &lt;val exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;} 过程： 添加以当前作用域为父作用域的新作用域 建立一个空的result字典存储表达式的值 对每个中的元素： 在新作用域中将绑定到每一个元素 若为真，则将与配对并添加到result字典中 e.g. {x*x: x for x in [1,2,3,4,5] if x&gt;2} 结果为{9:3, 16:4, 25:3}","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Sequence","slug":"CS61A——Sequence","date":"2025-02-25T08:44:27.448Z","updated":"2025-02-25T07:38:25.423Z","comments":true,"path":"2025/02/25/CS61A——Sequence/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence Lists 列表是python中的内置数据类型 使用[]创建列表 使用赋值语句命名列表 使用name[下标]访问列表元素(0-index)，或使用getitem( ,)(operator模块)来访问元素 使用len()函数获取元素个数 name[下标]是一种元素评估表达式，可以依次评估下标对应元素 列表中的元素可以是表达式，此时列表中的值将绑定为表达式的结果 digits = [2//2,2+2,2,2*2] 列表间可以相加与相乘（运算符或函数） [2,7]+[1,8,2,8]*2 == [2,7,1,8,2,8,1,8,2,8] 列表中的元素可以是任何东西，包括列表 12pairs = [[10,20],[30,40]] pairs[1][0] # 结果是30 in运算符 in运算符可以判断某元素是否存在于列表中 not in 运算符可以判断某元素是否不存在于列表中 返回值为True 或 False 这两个运算符寻找的是单独元素，而非子序列 e.g. 123456789digits = [1,8,2,8] &gt;&gt;&gt; 1 in digits True &gt;&gt;&gt; '1' in digits False &gt;&gt;&gt; [1,2] in [[1,2],3,4] True &gt;&gt;&gt; [1,2] in [[[1,2],3],4] False For Statement 执行过程 12for &lt;name&gt; in &lt;expression&gt;: &lt;suite&gt; 执行，该表达式必须是一个可迭代的量（如一个序列） 对序列中的每个元素，按序进行如下操作： 在当前作用域中将每个元素赋给 执行语句块中的语句 ### 序列解包 e.g.寻找序列中相同元素的数对 pairs = [[1,2],[2,2],[3,2],[4,4]] 123for x, y in paris: if x==y: same_count+=1 该循环中，for循环会自动将paris中的内层列表中的两个元素赋给x,y两个变量 Ranges range是表示连续整数的序列，通过给出起始与结束值获得范围内的整数 range包括起始值而不包括结束值 用法：range(&lt;起始值(默认为0)&gt;, &lt;结束值&gt;, [步长]) 作用： 计算长度：结束值-起始值 选择元素：起始值+index 作为计数器：用_等当作name而不实际使用它 转换列表：使用list() - 列表构造函数 List Comprehension 列表中可以写一些语句来构造列表 e.g.1 12345&gt;&gt;&gt; odds = [1,3,5,7,9] &gt;&gt;&gt; [x+1 for x in odds] [2,4,6,8,10] &gt;&gt;&gt; [x for x in odds if 25%x == 0] [1,5] e.g.2 查找某个数的因数 12def divisors(n): return [1]+[x for x in range(2,n) if n%x==0]","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Homework3","slug":"CS61A——Homework3","date":"2025-02-05T08:58:25.385Z","updated":"2025-02-05T09:00:31.656Z","comments":true,"path":"2025/02/05/CS61A——Homework3/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Homework3/","excerpt":"","text":"Homework 3 Q1: Num Eights 用递归函数求一个数中有几位8 12345678910111213141516171819202122232425262728def num_eights(n): \"\"\"Returns the number of times 8 appears as a digit of n. &gt;&gt;&gt; num_eights(3) 0 &gt;&gt;&gt; num_eights(8) 1 &gt;&gt;&gt; num_eights(88888888) 8 &gt;&gt;&gt; num_eights(2638) 1 &gt;&gt;&gt; num_eights(86380) 2 &gt;&gt;&gt; num_eights(12345) 0 &gt;&gt;&gt; num_eights(8782089) 3 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all assignment statements &gt;&gt;&gt; check(HW_SOURCE_FILE, 'num_eights', ... ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'For', 'While']) True \"\"\" if n==0: return 0 else: if n%10 ==8: return num_eights(n//10)+1 else: return num_eights(n//10) 递归出口：每一位都减完后n==0时 每次返回时递归调用自身，传入未判断的部分 若发现该位是8，则返回值加一，否则不变 Q2: Digit Distance 用递归函数求每两位的差的绝对值之和 12345678910111213141516171819202122232425def digit_distance(n): \"\"\"Determines the digit distance of n. &gt;&gt;&gt; digit_distance(3) 0 &gt;&gt;&gt; digit_distance(777) 0 &gt;&gt;&gt; digit_distance(314) 5 &gt;&gt;&gt; digit_distance(31415926535) 32 &gt;&gt;&gt; digit_distance(3464660003) 16 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all loops &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance', ... ['For', 'While']) True \"\"\" if n&lt;10: return 0 else: res,last = n//10,n%10 sec_last = res%10 return digit_distance(res)+abs(sec_last-last) 递归出口：当查到最后一位时绝对值为0，返回0 否则将最后一位与倒数第二位取出，将取完最后一位的剩余部分传入递归函数继续判断，返回值加上两位数绝对值之差 Q3: Interleaved Sum 写一个函数，要求对1-n中的所有奇数传入odd_func，所有偶数传入even_func，返回所有数计算后和 123456789101112131415161718192021222324252627def interleaved_sum(n, odd_func, even_func): \"\"\"Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up to n. &gt;&gt;&gt; identity = lambda x: x &gt;&gt;&gt; square = lambda x: x * x &gt;&gt;&gt; triple = lambda x: x * 3 &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1 + 2*2 + 3 + 4*4 + 5 29 &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2 + 3*3 + 4 + 5*5 41 &gt;&gt;&gt; interleaved_sum(4, triple, square) # 1*3 + 2*2 + 3*3 + 4*4 32 &gt;&gt;&gt; interleaved_sum(4, square, triple) # 1*1 + 2*3 + 3*3 + 4*3 28 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and % True \"\"\" def check_num(k): if k&gt;n: return 0 elif k==n: return odd_func(k) else: return check_num(k+2)+odd_func(k)+even_func(k+1) return check_num(1) 由于题目不让使用循环与取模运算判断奇偶，我们只能使用递归函数 由于奇数与偶数是分开的，我们可以发现，奇数+2=奇数，奇数+1=偶数 因此我们可以写一个内嵌函数，让一个计数变量k从1开始，将k传入odd_func，k+1传入even_func 然后递归调用该函数从k+2开始 递归出口即k&gt;n或k=n（此时k一定为奇数，直接传入odd_func并返回） Q4: Count Coins 给予n刀乐，把他分为面值分别为1刀乐，5刀乐，10刀乐，25刀乐的四种货币，输出分法数 1234567891011121314151617181920212223242526272829def count_coins(total): \"\"\"Return the number of ways to make change using coins of value of 1, 5, 10, 25. &gt;&gt;&gt; count_coins(15) 6 &gt;&gt;&gt; count_coins(10) 4 &gt;&gt;&gt; count_coins(20) 9 &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar? 242 &gt;&gt;&gt; count_coins(200) 1463 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For']) True \"\"\" def cal(total,spl_coin): if total==0: return 1 elif total&lt;0: return 0 elif spl_coin==None: return 0 else: with_coin = cal(total-spl_coin,spl_coin) without_coin = cal(total,next_smaller_coin(spl_coin)) return with_coin+without_coin return cal(total,25) Q5: Towers of Hanoi 实现汉诺塔游戏并描述每次移动过程 12345678910111213141516171819202122232425262728293031323334353637def move_stack(n, start, end): \"\"\"Print the moves required to move n disks on the start pole to the end pole without violating the rules of Towers of Hanoi. n -- number of disks start -- a pole position, either 1, 2, or 3 end -- a pole position, either 1, 2, or 3 There are exactly three poles, and start and end must be different. Assume that the start pole has at least n disks of increasing size, and the end pole is either empty or has a top disk larger than the top n start disks. &gt;&gt;&gt; move_stack(1, 1, 3) Move the top disk from rod 1 to rod 3 &gt;&gt;&gt; move_stack(2, 1, 3) Move the top disk from rod 1 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 3 &gt;&gt;&gt; move_stack(3, 1, 3) Move the top disk from rod 1 to rod 3 Move the top disk from rod 1 to rod 2 Move the top disk from rod 3 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 1 Move the top disk from rod 2 to rod 3 Move the top disk from rod 1 to rod 3 \"\"\" assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, \"Bad start/end\" def hanoi(n,start,mid,end): if n == 1: print_move(start, end) return else: hanoi(n - 1, start,end, mid) hanoi(1,start,mid,end) hanoi(n - 1, mid, start,end) return hanoi(n,start,6-start-end,end) 详见五点七边讲解视频","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Tree Recursion","slug":"CS61A——Tree Recursion","date":"2025-02-05T08:57:40.975Z","updated":"2025-02-05T08:57:00.742Z","comments":true,"path":"2025/02/05/CS61A——Tree Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Tree%20Recursion/","excerpt":"","text":"Tree Recursion Order of Recursive Calls e.g.1:Cascade 1234567def cascade(n): if n&lt;10: print(n) else: print(n) cascade(n//10) print(n) 结果为 12345678910&gt;&gt;&gt; cascade(12345) 12345 1234 123 12 1 12 123 1234 12345 首先一直调用cascade到底，返回None，从调用入口出来后继续执行cascade下面的语句 cascade 还可以缩短为以下 12345def cascade_short(n): print(n) if n&gt;10: cascade(n//10) print(n) e.g.2:Inverse Cascade 123456789101112def inverse_cascade(n): grow(n) print(n) shrink(n) def f_then_g(f,g,n): if n: f(n) g(n) grow = lambda n: f_then_g(grow,print,n//10) shrink = lambda n: f_then_g(print,shrink,n//10) grow先进行处理，每次将数字缩短一节，到达递归底部后退出时便是从小到大依次输出 shrink先打印出来当前n，然后将数字缩短一节，这样递归过程便实现了从大到小依次输出 Tree Recursion 当递归函数对自身调用超过一次时，发生树形递归，产生树状过程 e.g.1 斐波那契数列 树形斐波那契 1234567def fib(n): if n==0: return 0 elif n==1: return 1 else: return fib(n-1)+fib(n-2) e.g.2 计算分区 将正整数n分为大小不超过m的分区的方式有多少种，即n能以多少种方式表示为递增的不超过m部分之和 e.g. count_partitions(6,4) 有以下可能： …… 分为两种情况考虑： 至少分一个4 不分4 这样我们可以把递归问题拆分为两个小问题，将两种情况相加 count_partitions(2,4) count_partitions(6,3) 以此类推，count_partitions(6,3)按同样方式考虑，分3与不分3，直到递归底部 1234567891011def count_partitions(n,m): if n==0: return 1 elif n&lt;0: return 0 elif m==0: return 0 else: with_m = count_partitions(n-m,m) without_m = count_partitions(n,m-1) return with_m+without_m","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Recursion","slug":"CS61A——Recursion","date":"2025-02-05T08:57:40.973Z","updated":"2025-02-05T08:56:45.164Z","comments":true,"path":"2025/02/05/CS61A——Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Recursion/","excerpt":"","text":"Recursion Recursive Functions 定义：在函数体中直接或间接调用自身的函数叫递归函数 即在执行函数体时还会调用若干次函数自身 递归函数的结构： def头定义 条件语句用来判断基本条件，无递归调用（递归出口） 递归条件用来递归调用 判断递归是否正确： 验证基本条件 将递归函数看作函数抽象 假设f(n-1)正确，验证f(n)的正确性 e.g.1:用递归求各位数字和 1234567891011def split(n): \"\"\"把n分成最后一位与其他位两部分\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"求和各位数字\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last e.g.2:阶乘（使用diagram） 阶乘 递归与迭代 递归与迭代 递归转换到迭代：弄清需要通过迭代保持的状态 迭代转换到递归：迭代保持的状态可以通过参数传递 互递归（Mutual Recursion） e.g. Luhn Algorithm 改算法常用于信用卡等的校验码计算，步骤如下： 步骤 1：反转数字 算法首先通过反转您正在检查的数字的数字。 步骤 2：每隔一个数字翻倍 从左侧的第一个数字开始（由于反转，现在是原始数字的最后一个数字），对每个第二个数字进行翻倍。 步骤 3：求乘积的数字之和 如果翻倍后的数字大于 9，则将乘积的数字相加（例如，翻倍 8 得到 16，因此相加 1 + 6 = 7）。 步骤 4：将所有数字相加 在上述操作后，将所有数字相加。 步骤 5：检查是否能被 10 整除 如果总和能被 10 整除（即以 0 结尾），则该数字根据 Luhn 算法是有效的。否则，它是无效的。 1234567891011121314151617181920212223242526def split(n): \"\"\"把n分成最后一位与其他位两部分\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"求和各位数字\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last def luhn_sum(n): if n&lt;10: return n else: all_but_last, last = split(n) return luhn_sum_double(all_but_last)+last def luhn_sum_double(n): all_but_last, last = split(n) luhn_digit = sum_digits(2*last) if n&lt;10: return luhn_digit else: return luhn_sum(all_but_last)+luhn_digit 这里使用互递归让分离出来的数字奇数位不执行乘二操作，偶数位执行乘二操作","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Functional Abstraction","slug":"CS61A——Design","date":"2025-02-05T08:57:40.971Z","updated":"2025-02-05T08:57:28.693Z","comments":true,"path":"2025/02/05/CS61A——Design/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Design/","excerpt":"","text":"Functional Abstraction Lambda表达式所在的environment关系 如下例子 12345a = 1 def f(g): a = 2 return lambda y:a*g(y) f(lambda y: a+y)(a) 注意行4与行5的lambda函数的区别： 行4的lambda函数是f函数内定义的函数，他的父级为f，因此此时传入的a=2 行5的lambda函数是f函数外定义的函数，他的父级为global，因此此时传入的a=1 Choosing Names 给函数或变量命名时，要注重传达意思 命名需要传达与之相关值的意义或目的 值的类型最好记录在函数的docstring中 函数名一般包括它们的作用，表现或返回值 为一些重复使用的复合表达式命名 如果需要注释代码，命名可以长一些 如果用于数字，数学运算与函数抽象，命名可以短一些 Error&amp;Traceback 报错有三种形式： Syntax errors：执行前即可发现，通常由于表达式不正确引起 Runtime errors：执行时由python解释器发现的错误。当这些错误发生时，会得到一个Traceback，来提示是在哪里发生了何种错误，错误发生时程序在做什么 Logical error：不会被解释器发现，需要自己进行测试发现问题 Decorator 装饰器用于给现有模块（原函数）进行功能拓展，通过接受一个函数来返回一个新的函数或修改原来的函数 例如： 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced @trace1 def square(x): return x*x 等同于 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced def square(x): return x*x square = trace1(square) 返回值都相同 123&gt;&gt;&gt; square(5) Calling &lt;function square at 0x000001C1247A9240&gt; on argument 5 25","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【算法】KMP","slug":"KMP","date":"2025-02-03T13:17:16.129Z","updated":"2025-02-03T13:18:42.295Z","comments":true,"path":"2025/02/03/KMP/","permalink":"https://izayoisakuye.github.io/2025/02/03/KMP/","excerpt":"","text":"KMP 给予主串S与模式串P，寻找模式串在主串中是否出现过以及出现位置 匹配过程 设主串S：abcxabcdabxabcdabcdabcy，模式串P：abcdabcy 构建Next数组 针对模式串P，我们有一个Next数组，Next[i]指P[0…i]的最长公共前后缀的长度 如例子中P的Next数组为0 0 0 0 1 2 3 0 ，如下表 下标 1 2 3 4 5 6 7 8 字符串 a b c d a b c y 前后缀 a ab abc abcd abcda abcdab abcdabc abcdabcy 最长公共前后缀 / / / / a ab abc / Next[i] 0 0 0 0 1 2 3 0 让两个指针j，i指向P头，让i逐个移动，与j所指的比较，若不同，则j跳转到该位的前一位Next数组值对应的下标，该位Next数组值为0；若相同，则j向右移动一位，该位Next数组值为移动后的j值（即Next[i]=++j） 性质：i+1-Next[i]为前缀循环节的大小 或把P与S合并成一个串，算出Next数组值，若某位值n等于P的长度，说明找到了和P匹配的字串，因为该处合并串的前后缀相同，该位置向前n长度的字串即为P 在构造Next数组时，假如需要计算Next[i]的值，此时前Next[i-1]位相等，记为len-1，若两侧字串加上第len与第i位，字串仍相等，则Next[i]=len+1，若不相等，则寻找第二长的Next，重复判断直到找到最小的Next(len=0) 搜索模式串 用两个指针指向两串头，逐个匹配，当遇到不同字符时，查看该字符前一个字符对应next数组中的值，让模式串指针跳到该值对应的P的下标位置，继续与主串指针逐个匹配 当找到对应模式串在主串出现时，通过i-len(p)+1计算起始位置 注意：整个匹配过程中主串指针不会后退，只会停留；而模式串指针根据next数组反复横条 板子-1 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt; using namespace std; void Next_pre(string p, vector&lt;int&gt; &amp;Next){ for(int i = 1,j=0;i&lt;p.size();i++){ // i是当前遍历到的后缀 while(j&amp;&amp;p[i]!=p[j]) j=Next[j-1]; // 两指针指向不同时按Next中值跳转直到跳到0 if(p[i]==p[j])j++; // 前后缀一样时，前缀向后移动 Next[i]=j; } } int kmp(string s,string p,int begin){ // begin表示从哪里开始匹配 vector&lt;int&gt; Next(p.size()); Next_pre(p,Next); for(int i = begin,j=0;i&lt;s.size();i++){ while(j&amp;&amp;s[i]!=p[j]) j=Next[j-1]; // 两指针指向不同时按Next中值跳转直到跳到0 if (s[i]==p[j])j++; // 前后缀一样时，前缀向后移动 if (j==p.size()){ // 匹配成功后的操作 // 该部分操作按题目要求 return i-p.size()+1; } } return -1; } int main(){ string s,p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; kmp(s,p,0); return 0; } 板子-2 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt; using namespace std; int kmp(string s,string p){ int n = s.size(); int m = p.size(); string mer = p+'#'+s; vector&lt;int&gt; Next(mer.size()); for (int i = 1;i&lt;mer.size();i++){ int len = Next[i-1]; while(len&amp;&amp;mer[i]!=mer[len]) len = Next[len-1]; if (mer[i]==mer[len]){ Next[i]=len+1; if (Next[i]==m){ return i-m*2; } } } return -1; } int main(){ string s,p; cin &gt;&gt; s&gt;&gt;p; cout &lt;&lt; kmp(s,p); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【数据结构】字典树","slug":"字典树","date":"2025-02-01T09:02:16.436Z","updated":"2025-02-03T13:18:56.752Z","comments":true,"path":"2025/02/01/字典树/","permalink":"https://izayoisakuye.github.io/2025/02/01/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"字典树(trie) 给予n个单词，在这n个单词中查询给定的单词是否存在 遍历 使用string遍历每一个单词比较，s1==s2，时间复杂度为，m为单词长度 若询问q次，则复杂度高达 字典树 字典树是一种树形结构，树的每个节点上存储了一个字符 标红的节点表示存在一个以该节点字符结尾的字符串 可以发现，以某个字符结尾的字符串在trie树上是唯一的，因为该节点只有一个父节点，沿着往上即可获得唯一的字符串。 还可以发现，若按照前序遍历，每个节点的字符是按字典序排列的，故trie树还可以用于排序 建树 建立一个根节点，将字符串每一个字符依次从根节点插入，若存在对应字符节点便沿用，否则在上个父节点基础上新建节点，传入结尾位置时标记（是否结尾或第几个相同单词） 时间复杂度 询问 将读入的字符串从根节点开始一个个字符比对，若某个字符在同层节点中都没有则不存在该字符串，若到达该字符串末尾，但此时节点并未标记结尾位置，也判断为不存在该字符串。否则判断为存在 时间复杂度：，x为每次询问字符串长度，共q次询问 删除 判断是否有子节点 若没有子节点，标记不为一时-1，为1时递归删除到根节点 存储 用数组表示层数，每层再用数组表示26个字符在该层出现的次数 缺点：若字符少可行，若字符数过多，或每层分配的节点过多，占用空间会过大 时间换空间：使用map或unordered_map，但时间复杂度会变高 板子 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; // 开辟空间 struct trieNode{ char val; trieNode** son; int cnt; trieNode(char c){ val = c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; // 插入操作 void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c])p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; } p-&gt;cnt++; } // 查询操作 int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main(){ root = new trieNode(' '); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 int trie[M][N]; int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } map实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 vector&lt;map&lt;char,int&gt;&gt; trie; // 或使用unordered_map int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ trie = vector&lt;map&lt;char,int&gt;&gt;(M); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 应用-查询前缀 题目描述 给定 个模式串 和 次询问，每次询问给定一个文本串 ，请回答 中有多少个字符串 满足 是 的前缀。 一个字符串 是 的前缀当且仅当从 的末尾删去若干个（可以为 0 个）连续的字符后与 相同。 输入的字符串大小敏感。例如，字符串 Fusu 和字符串 fusu 不同。 输入格式 本题单测试点内有多组测试数据。 输入的第一行是一个整数，表示数据组数 。 对于每组数据，格式如下： 第一行是两个整数，分别表示模式串的个数 和询问的个数 。 接下来 行，每行一个字符串，表示一个模式串。 接下来 行，每行一个字符串，表示一次询问。 输出格式 按照输入的顺序依次输出各测试数据的答案。 对于每次询问，输出一行一个整数表示答案。 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 3e6 + 10; const int M = 70; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int trie[N][M]; int cnt[N]; int idx = 0; // char到int的转换 int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!trie[p][c]) trie[p][c]=++idx; p=trie[p][c]; cnt[p]++; // 这里与查询整个单词不同，需要每层计数 } } // 询问操作 int query(string s){ int p = 0; //int sum = 0; for (int i = 0;i&lt;s.size();i++){ int c =ascii(s[i]); if (!trie[p][c]) return 0; p=trie[p][c]; // sum+=cnt[p]; } return cnt[p]; } int main() { ios cin &gt;&gt; t; while(t--){ int n , q; cin &gt;&gt; n &gt;&gt; q; // 每次清空使用过的部分 for (int i = 0;i&lt;=idx;i++){ for (int j = 0;j&lt;=M;j++){ trie[i][j]=0; } } for(int i = 0;i&lt;=idx;i++){ cnt[i]=0; } idx = 0; for (int i = 0; i&lt;n;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;q;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s) &lt;&lt; endl; } } return 0; } 缺点是每次查询后数组重置时容易TLE，解决方法为只清空使用的部分 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 63; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; struct trieNode{ char val; int cnt; trieNode** son; trieNode(char c){ val =c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; p-&gt;cnt++; } } int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main() { ios cin &gt;&gt; t; while(t--){ int n,q; cin &gt;&gt; n &gt;&gt; q; root = new trieNode(' '); while(n--){ string s; cin &gt;&gt; s; insert(s); } while(q--){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } } return 0; } 缺点是滥用指针容易MLE，解决方法为N开小一点（差点炸的程度）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【Python】CS61A——Lab2","slug":"CS61A——Lab2","date":"2025-01-30T13:44:27.000Z","updated":"2025-01-30T14:56:07.204Z","comments":true,"path":"2025/01/30/CS61A——Lab2/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Lab2/","excerpt":"","text":"WWPD部分省略 Composite Identity Function 题意：写一个函数，传入f与g两个函数，返回一个含有参数x的函数，用于判断是否等于 123456789101112131415def composite_identity(f, g): \"\"\" Return a function with one parameter x that returns True if f(g(x)) is equal to g(f(x)). You can assume the result of g(x) is a valid input for f and vice versa. &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 # squares x [returns x^2] &gt;&gt;&gt; b1 = composite_identity(square, add_one) &gt;&gt;&gt; b1(0) # (0 + 1) ** 2 == 0 ** 2 + 1 True &gt;&gt;&gt; b1(4) # (4 + 1) ** 2 != 4 ** 2 + 1 False \"\"\" return lambda x: f(g(x))==g(f(x)) 按照题意返回一个lambda函数，传入x即可 Count Cond predicate function: 返回True或False的函数 题意：写一个函数，传入一个两个参数的predicate function condition，返回一个含有参数n的函数，判断1-n中有几个数满足condition函数 1234567891011121314151617181920212223242526272829303132def count_cond(condition): \"\"\"Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5) &gt;&gt;&gt; count_fives(10) # 50 (10 * 5) 1 &gt;&gt;&gt; count_fives(50) # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46) 4 &gt;&gt;&gt; is_i_prime = lambda n, i: is_prime(i) # need to pass 2-argument function into count_cond &gt;&gt;&gt; count_primes = count_cond(is_i_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 \"\"\" def judge(n): cnt = 0 for i in range(1,n+1): if condition(n,i): cnt+=1 return cnt return judge 遍历1-n，传入condition函数并计数即可 注意返回的是函数，传入n Multiple 题意：写一个函数求参数a，b的最小公倍数 12345678910111213def multiple(a, b): \"\"\"Return the smallest number n that is a multiple of both a and b. &gt;&gt;&gt; multiple(3, 4) 12 &gt;&gt;&gt; multiple(14, 21) 42 \"\"\" def gcd(a,b): if b==0: return a return gcd(b,a%b) return a*b//gcd(a,b) 辗转相除法求gcd，用gcd求lcm I Heard You Liked Functions… 题意：定义一个函数传入三个函数f1,f2,f3，返回一个参数为n的函数g，函数g返回一个参数为x的函数h 函数x将会循环传给函数f1，f2，f3，具体如下： n=0时返回x，n=1时返回f1(x)，n=2时返回f2(f1(x))，n=3时返回f3(f2(f1(x)))，n=4时返回f1(f3(f2(f1(x))))，以此类推 12345678910111213141516171819202122232425262728293031323334353637383940414243def cycle(f1, f2, f3): \"\"\"Returns a function that is itself a higher-order function. &gt;&gt;&gt; def add1(x): ... return x + 1 &gt;&gt;&gt; def times2(x): ... return x * 2 &gt;&gt;&gt; def add3(x): ... return x + 3 &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3) &gt;&gt;&gt; identity = my_cycle(0) &gt;&gt;&gt; identity(5) 5 &gt;&gt;&gt; add_one_then_double = my_cycle(2) &gt;&gt;&gt; add_one_then_double(1) 4 &gt;&gt;&gt; do_all_functions = my_cycle(3) &gt;&gt;&gt; do_all_functions(2) 9 &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4) &gt;&gt;&gt; do_more_than_a_cycle(2) 10 &gt;&gt;&gt; do_two_cycles = my_cycle(6) &gt;&gt;&gt; do_two_cycles(1) 19 \"\"\" def g(n): def h(f,g): return lambda x: f(g(x)) if n==0: return lambda x : x elif n==1: return f1 else: temp = f1 i=2 while i&lt;=n: if i%3==1: temp= h(f1,temp) elif i%3==2: temp= h(f2,temp) else: temp= h(f3,temp) i+=1 return temp return g 遍历1-n，每次取模3来判断该套哪个函数，注意0和1时特判，2开始从f1往外套 即执行顺序为","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Hog","slug":"Project1-Hog","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:08.930Z","comments":true,"path":"2025/01/30/Project1-Hog/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project1-Hog/","excerpt":"","text":"Project1-Hog 实现一个掷骰子游戏 规则 两位玩家依次掷任意数量(不多于10个)骰子，点数之和先达到GOAL的胜利。 Sow Sad: 若其中一个骰子点数为一，则该玩家此轮得分为1 Boar Brawl: 玩家可以选择不掷骰子，得分为max(1,3*abs(对手得分十位数-自己得分个位数))，位数不够补零。 Sus Fuss: 若一局结束后，玩家点数数值有三或四个因数(包括1和点数本身)，该玩家点数会变为比当前数值大的最近的一个质数 Phase 1: Rules of the Game 模拟游戏的进行 Problem 0 熟悉dice.py，了解骰子的生成 make_fair_dice()用于生成每面概率相等的SIDE面骰子 make_test_dice()用于测试循环投出一系列指定值 掷出一次骰子的方法：调用生成骰子赋值给的变量e.g. six_sided() Problem 1 实现掷骰子函数，并实现规则Sow Sad 在定义函数时，若出现形参后已经赋值的情况，该值代表该函数不传入参数时形参默认值 如def roll_dice(num_rolls, dice=six_sided)，若不传入dice参数则默认为six_sided roll_dice()函数： 参数： num_rolls指掷骰子次数 dice指传入的骰子（默认值为六面骰子） 理解： 该函数返回的是num_roll次结果之和，若其中有1则返回1 若上次调用函数掷骰子次数少于掷骰子次数，则下次掷骰子时会接着上次开始而非从头开始 在循环中return语句会结束一个循环 My code： 1234567891011121314151617181920212223def roll_dice(num_rolls, dice=six_sided): \"\"\"Simulate rolling the DICE exactly NUM_ROLLS &gt; 0 times. Return the sum of the outcomes unless any of the outcomes is 1. In that case, return 1. num_rolls: The number of dice rolls that will be made. dice: A function that simulates a single dice roll outcome. Defaults to the six sided dice. \"\"\" # These assert statements ensure that num_rolls is a positive integer. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt; 0, 'Must roll at least once.' # BEGIN PROBLEM 1 total = 0 flag = 0 for i in range(num_rolls): temp = dice() if temp==1: flag = 1 total += temp if flag: return 1 else: return total # END PROBLEM 1 Problem 2 实现规则Boar Brawl boar_brawl()函数： 参数： player_score：自己的分数 opponent_score：对手的分数 理解： 获取自己分数的个位数与对手分数的十位数 相减并取绝对值后乘三 若小于1则输出1，否则输出计算结果 My code： 1234567891011121314151617def boar_brawl(player_score, opponent_score): \"\"\"Return the points scored by rolling 0 dice according to Boar Brawl. player_score: The total score of the current player. opponent_score: The total score of the other player. \"\"\" # BEGIN PROBLEM 2 player_one = player_score%10 opponent_ten = opponent_score%100//10 result = 3*abs(opponent_ten-player_one) if result&gt;=1: return result else: return 1 # END PROBLEM 2 注意：传入的参数不一定是十位数，需要进行一些处理 Problem 3 实现函数，将前两个规则结合，输出正确结果 take_turn()函数： 参数： num_rolls：掷骰子次数 player_score：自己的分数 opponent_score：对手的分数 dice：使用的骰子 理解： 若num_rolls&gt;0，则按照正常规则进行，获得本轮掷骰点数之和 若num_rolls=0，即不掷骰子，等同于选择使用Boar Brawl规则，执行该函数 My code： 12345678910111213141516171819def take_turn(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the points scored on a turn rolling NUM_ROLLS dice when the player has PLAYER_SCORE points and the opponent has OPPONENT_SCORE points. num_rolls: The number of dice rolls that will be made. player_score: The total score of the current player. opponent_score: The total score of the other player. dice: A function that simulates a single dice roll outcome. \"\"\" # Leave these assert statements here; they help check for errors. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt;= 0, 'Cannot roll a negative number of dice in take_turn.' assert num_rolls &lt;= 10, 'Cannot roll more than 10 dice.' # BEGIN PROBLEM 3 if num_rolls==0: return boar_brawl(player_score,opponent_score) else: return roll_dice(num_rolls,dice) # END PROBLEM 3 Problem 4 实现Sus Fuss规则 num_factors()函数： 参数： n：要计算的数n 理解： 返回数n的因数个数 1和n本身也算进去 My code： 123456789def num_factors(n): \"\"\"Return the number of factors of N, including 1 and N itself.\"\"\" # BEGIN PROBLEM 4 total = 0 for i in range(1,n+1): if n%i==0: total+=1 return total # END PROBLEM 4 sus_points()函数： 参数： score：某玩家的分数 理解： 该函数用于更新玩家在Sus Fuss规则下新的分数 即用于判断符合条件下大于该分数数值的下一个质数 若该数值不符合条件，则返回本身 My code: 1234567891011def sus_points(score): \"\"\"Return the new score of a player taking into account the Sus Fuss rule.\"\"\" # BEGIN PROBLEM 4 if num_factors(score)==3 or num_factors(score)==4: while True: score+=1 if is_prime(score): return score else: return score # END PROBLEM 4 sus_update()函数： 参数： num_rolls：掷骰子次数 player_score：自己的分数 opponent_score：对手的分数 dice：使用的骰子 理解： 用于输出num_rolls次掷骰子后，考虑以上三种规则后的点数之和 现根据take_turn()函数求出满足前两个规则的本轮分数之和，并累加到当前分数上 再判断此时分数是否满足第三个规则，进行相应分数改动 My code: 12345678def sus_update(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the total score of a player who starts their turn with PLAYER_SCORE and then rolls NUM_ROLLS DICE, *including* Sus Fuss. \"\"\" # BEGIN PROBLEM 4 score = player_score + take_turn(num_rolls, player_score, opponent_score, dice) return sus_points(score) # END PROBLEM 4 Problem 5 完整实现游戏模拟 play()函数： 参数： strategy0：player0使用的策略 strategy1：player1使用的策略 update：使用的更新函数（有无sus） score0：player0的起始分数 score1：player1的起始分数 dice：使用的骰子 goal：实现游戏结束的数值 理解： strategy指的是玩家掷骰子数量 strategy函数传入自己与对手的分数，根据两者分数得出下次掷骰子数量 使用传入的update函数来决定分数改变策略（是否采用sus fuss规则） My code： 123456789101112131415161718192021222324252627282930313233343536def play(strategy0, strategy1, update, score0=0, score1=0, dice=six_sided, goal=GOAL): \"\"\"Simulate a game and return the final scores of both players, with Player 0's score first and Player 1's score second. E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in which both players always choose to roll 5 dice on every turn and the Sus Fuss rule is in effect. A strategy function, such as always_roll_5, takes the current player's score and their opponent's score and returns the number of dice the current player chooses to roll. An update function, such as sus_update or simple_update, takes the number of dice to roll, the current player's score, the opponent's score, and the dice function used to simulate rolling dice. It returns the updated score of the current player after they take their turn. strategy0: The strategy for player0. strategy1: The strategy for player1. update: The update function (used for both players). score0: Starting score for Player 0 score1: Starting score for Player 1 dice: A function of zero arguments that simulates a dice roll. goal: The game ends and someone wins when this score is reached. \"\"\" who = 0 # Who is about to take a turn, 0 (first) or 1 (second) # BEGIN PROBLEM 5 while score0&lt;goal and score1 &lt; goal: if who==0: score0 = update(strategy0(score0, score1), score0, score1, dice) else: score1 = update(strategy1(score1, score0), score1, score0, dice) who = 1 - who # END PROBLEM 5 return score0, score1 Phase 2: Strategies 这部分将会根据自己与对手的分数生成每轮玩家的掷骰数（0-10） Problem 6 返回一个函数，获取自己与对手分数并输出指定骰子个数 理解： 返回的是函数，有两个参数：自己与对手分数 无论两者分数多少，返回的总是一开始传入的指定骰子个数 My code： 1234567891011121314151617def always_roll(n): \"\"\"Return a player strategy that always rolls N dice. A player strategy is a function that takes two total scores as arguments (the current player's score, and the opponent's score), and returns a number of dice that the current player will roll this turn. &gt;&gt;&gt; strategy = always_roll(3) &gt;&gt;&gt; strategy(0, 0) 3 &gt;&gt;&gt; strategy(99, 99) 3 \"\"\" assert n &gt;= 0 and n &lt;= 10 # BEGIN PROBLEM 6 return lambda x,y: n # END PROBLEM 6 Problem 7 判断每种分数组合是否都有一种对应的掷骰个数（分数组合指一种自己与对手的分数） is_always_roll()函数： 参数： strategy：掷骰策略 goal：玩家胜利要达到的目标分数 理解： 自己与对手的得分在胜利之前可能性均有100种（0-99），故可能性组合有10000种 该函数实现了判断每种可能性组合下返回的掷骰数是否相同 goal不一定是100 My code： 12345678910111213141516171819def is_always_roll(strategy, goal=GOAL): \"\"\"Return whether STRATEGY always chooses the same number of dice to roll given a game that goes to GOAL points. &gt;&gt;&gt; is_always_roll(always_roll_5) True &gt;&gt;&gt; is_always_roll(always_roll(3)) True &gt;&gt;&gt; is_always_roll(catch_up) False \"\"\" # BEGIN PROBLEM 7 num = strategy(0,0) for i in range(0,goal): for j in range(0,goal): if strategy(i,j)!=num: return False return True # END PROBLEM 7 Problem 8 返回一个函数，用来调用n次掷骰函数，并返回这n次掷骰得到的值之和的平均值 语法特性：*args *args参数允许函数接受任意数量的位置参数，以元组形式传入 args可以改为其他名称，*必须有 应用： 定义的函数接受不定数量位置参数时 编写高阶函数（higher-order function）时，传递参数给内部的定义的函数 make_averaged()函数 参数： original_function：调用的掷骰函数 times_called：调用次数 理解： 函数需要做到执行n次掷骰函数，并将返回值累加，最后求这n次和的平均值 在内联函数中使用了*args来表示若干参数，与调入的掷骰函数参数数量一致 My code： 1234567891011121314151617181920def make_averaged(original_function, times_called=1000): \"\"\"Return a function that returns the average value of ORIGINAL_FUNCTION called TIMES_CALLED times. To implement this function, you will have to use *args syntax. &gt;&gt;&gt; dice = make_test_dice(4, 2, 5, 1) &gt;&gt;&gt; averaged_dice = make_averaged(roll_dice, 40) &gt;&gt;&gt; averaged_dice(1, dice) # The avg of 10 4's, 10 2's, 10 5's, and 10 1's 3.0 \"\"\" # BEGIN PROBLEM 8 def average_cal(*args): suma = 0 for i in range(times_called): suma+=original_function(*args) return suma/times_called return average_cal # END PROBLEM 8 Problem 9 实现函数，枚举掷骰次数（1-10），看哪次的分数平均值最大 max_scoring_num_rolls()函数 参数： dice：使用的骰子 times_called：调用次数 理解 遍历掷骰次数，调用make_averaged函数计算平均值，取1-10掷骰次数中平均值最大值 当平均值相等时取更小的 My code： 123456789101112131415161718def max_scoring_num_rolls(dice=six_sided, times_called=1000): \"\"\"Return the number of dice (1 to 10) that gives the maximum average score for a turn. Assume that the dice always return positive outcomes. &gt;&gt;&gt; dice = make_test_dice(1, 6) &gt;&gt;&gt; max_scoring_num_rolls(dice) 1 \"\"\" # BEGIN PROBLEM 9 maxi = 0 maxc = 0 for i in range(1,11): temp = make_averaged(roll_dice,times_called)(i,dice) if temp &gt; maxc: maxc = temp maxi = i return maxi # END PROBLEM 9 Problem 10 采用Boar Brawl规则，若roll出0时根据该规则得到的分数比threshold大，返回0，否则返回掷骰次数 boar_strategy()函数 参数： score：自己的分数 opponent_score：对手的分数 threshold：阈值分数，若采用boar brawl得到的分数大于它则返回掷骰0次 num_rolls：掷骰次数 理解： boar brawl规则是在掷骰0次下的特殊规则 若采用该规则策略获得的分数要比正常掷骰获得的分数更高，就采用该策略（返回掷骰次数0次） 否则按正常掷骰次数掷骰 My code： 12345678def boar_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice if Boar Brawl gives at least THRESHOLD points, and returns NUM_ROLLS otherwise. Ignore score and Sus Fuss. \"\"\" # BEGIN PROBLEM 10 if boar_brawl(score,opponent_score)&gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 10 Problem 11 采用Sus Fuss规则，若roll出0时根据该规则与Boar Brawl规则得到的分数与起始分数差值比threshold大，返回0，否则返回掷骰次数 sus_strategy()函数 参数： score：自己的分数 opponent_score：对手的分数 threshold：阈值分数，若采用boar brawl得到的分数大于它则返回掷骰0次 num_rolls：掷骰次数 理解： 即在boar brawl规则下采用sus fuss规则得到分数 若采用该规则策略获得的分数要比正常掷骰获得的分数更高，就采用该策略（返回掷骰次数0次） 否则按正常掷骰次数掷骰 My code： 123456def sus_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice when your score would increase by at least threshold.\"\"\" # BEGIN PROBLEM 11 if sus_update(0,score,opponent_score) - score &gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 11 Problem 12 结合上述所有策略与自己的策略，实现最终策略 My code： 12345678910def final_strategy(score, opponent_score): \"\"\"Write a brief description of your final strategy. *** YOUR DESCRIPTION HERE *** \"\"\" # BEGIN PROBLEM 12 threshold = GOAL-score if score&gt;80 and score-opponent_score&gt;20: return 0 return 6 # Remove this line once implemented. # END PROBLEM 12","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Cat","slug":"Project2-Cat","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:21.217Z","comments":true,"path":"2025/01/30/Project2-Cat/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project2-Cat/","excerpt":"","text":"Project2-Cat 实现一个金山打字通（？） 具体实现：记录打字速度以及自动修正拼写错误的字符 Phase 1: Typing 实现打字以及检测打字速度相关功能 Problem 1 挑选用户打字的段落 pick函数 参数： paragraphs：一串字符串记录了打字内容 select：一个函数，检测段落是否能被选择 k：非负数，作为index 思路： 函数功能实现了用户选择第k个段落作为打字内容 若选择的k没有对应段落则返回空字符串 选择的字符串要符合select函数的条件 符合条件的才能编号第k个字符串 code： 1234567891011121314151617181920212223242526272829def pick(paragraphs, select, k): \"\"\"Return the Kth paragraph from PARAGRAPHS for which SELECT called on the paragraph returns True. If there are fewer than K such paragraphs, return the empty string. Arguments: paragraphs: a list of strings select: a function that returns True for paragraphs that can be selected k: an integer &gt;&gt;&gt; ps = ['hi', 'how are you', 'fine'] &gt;&gt;&gt; s = lambda p: len(p) &lt;= 4 &gt;&gt;&gt; pick(ps, s, 0) 'hi' &gt;&gt;&gt; pick(ps, s, 1) 'fine' &gt;&gt;&gt; pick(ps, s, 2) '' \"\"\" # BEGIN PROBLEM 1 valid_para = [] for s in paragraphs: if select(s): valid_para.append(s) if k&gt;=len(valid_para): return '' else: return valid_para[k] # END PROBLEM 1 Problem 2 通过给定的关键词选取段落 about函数 参数：subject：关键词列表 思路： about函数用于pick函数中的select选项，用于筛选指定关键字的段落 故它返回的是一个select函数，若段落满足条件则返回True否则返回False 单词匹配时不区分大小写，但要是一个完整单词，且不能是单词的字串 可以使用给定的函数remove_punctuation-去除标点，lower-变小写，split-将一句话分割为若干单词存入列表 code： 1234567891011121314151617181920212223242526def about(subject): \"\"\"Return a select function that returns whether a paragraph contains one of the words in SUBJECT. Arguments: subject: a list of words related to a subject &gt;&gt;&gt; about_dogs = about(['dog', 'dogs', 'pup', 'puppy']) &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup!'], about_dogs, 0) 'Cute Dog!' &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup.'], about_dogs, 1) 'Nice pup.' \"\"\" assert all([lower(x) == x for x in subject]), 'subjects should be lowercase.' # BEGIN PROBLEM 2 def select(para): sp_para = split(remove_punctuation(para)) for i in range(0,len(sp_para)): sp_para[i]=lower(sp_para[i]) for s in subject: if s in sp_para: return True return False return select # END PROBLEM 2 Problem 3 计算已经输入且匹配单词占需要输入内容的百分比 accuracy函数 参数： typed：已经输入的内容 source：需要输入的内容 思路： 按单词顺序匹配指定输入内容，第一个对第一个，第二个对第二个…. 区分大小写，且包含标点符号 若已经输入内容比需要输入内容长，则长的部分认定为不正确 若两者均为空字符串则准确率为100.0，若前者为空后者非空或前者非空后者为空则准确率为0.0 code： 12345678910111213141516171819202122232425262728293031323334353637def accuracy(typed, source): \"\"\"Return the accuracy (percentage of words typed correctly) of TYPED when compared to the prefix of SOURCE that was typed. Arguments: typed: a string that may contain typos source: a string without errors &gt;&gt;&gt; accuracy('Cute Dog!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('A Cute Dog!', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('cute Dog.', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute Dog. I say!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute', 'Cute Dog.') 100.0 &gt;&gt;&gt; accuracy('', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('', '') 100.0 \"\"\" typed_words = split(typed) source_words = split(source) # BEGIN PROBLEM 3 cnt = 0 for t, s in zip(typed_words, source_words): if t==s: cnt+=1 if len(typed_words)==0 and len(source_words)==0: return 100.0 elif len(typed_words)==0 or len(source_words)==0: return 0.0 else: return (cnt/len(typed_words))*100 # END PROBLEM 3 注意： 同时遍历两个列表时，使用zip函数解包，因为原代码实现的是遍历一个包含两个列表的元组 空字符部分特判，因为计算百分比时可能会导致分母为0 计算的是已经输入字符与需要输入字符匹配的字符个数在已经输入字符中的占比，分母是typed_words的长度 Problem 4 按照words/min计算打字速度 wpm函数 参数： typed：已经输入的内容 elapsed：总共打字时间（按秒计） 思路： wpm的计算是按照字符数来的，单位是每五个字符数，这样可以减少单词长度对结果的影响 字符数时间 code: 1234567891011121314151617def wpm(typed, elapsed): \"\"\"Return the words-per-minute (WPM) of the TYPED string. Arguments: typed: an entered string elapsed: an amount of time in seconds &gt;&gt;&gt; wpm('hello friend hello buddy hello', 15) 24.0 &gt;&gt;&gt; wpm('0123456789',60) 2.0 \"\"\" assert elapsed &gt; 0, 'Elapsed time must be positive' # BEGIN PROBLEM 4 length = len(typed) return (length/5)/(elapsed/60) # END PROBLEM 4 注意：elapsed单位是秒，wpm使用的时间是分钟 Phase 2: Autocorrect 按下空格触发单词自动纠正，若最近的一个词接近正确词汇但不正确，则会用正确词汇替代 Problem 5 返回一个列表，内部提供了几个接近输入单词的正确单词 参数： typed_word：一个字符串，表示输入的单词 word_list：源单词列表 diff_function：评估单词不同程度的函数 limit：单词能否被更改的阈值 思路： autocorrect实现的 若输入字符已经在word_list中，将会直接返回该字符 否则会返回基于diff函数计算的不同程度最小的单词 若输入单词与word_list中最小的不同程度仍大于limit，则返回输入单词 所有输入单词和word_list中的单词都是小写且没有标点 若多个单词与输入字符不同程度最小相同，则返回最靠前的 不同程度可以使用两个单词相同部分长度衡量 code： 123456789101112131415161718192021222324252627282930def autocorrect(typed_word, word_list, diff_function, limit): \"\"\"Returns the element of WORD_LIST that has the smallest difference from TYPED_WORD. If multiple words are tied for the smallest difference, return the one that appears closest to the front of WORD_LIST. If the difference is greater than LIMIT, instead return TYPED_WORD. Arguments: typed_word: a string representing a word that may contain typos word_list: a list of strings representing source words diff_function: a function quantifying the difference between two words limit: a number &gt;&gt;&gt; ten_diff = lambda w1, w2, limit: 10 # Always returns 10 &gt;&gt;&gt; autocorrect(\"hwllo\", [\"butter\", \"hello\", \"potato\"], ten_diff, 20) 'butter' &gt;&gt;&gt; first_diff = lambda w1, w2, limit: (1 if w1[0] != w2[0] else 0) # Checks for matching first char &gt;&gt;&gt; autocorrect(\"tosting\", [\"testing\", \"asking\", \"fasting\"], first_diff, 10) 'testing' \"\"\" # BEGIN PROBLEM 5 if typed_word in word_list: return typed_word word_diff = [diff_function(typed_word, s, limit) for s in word_list] min_diff = min(word_diff) if min_diff &gt; limit: return typed_word else : return word_list[word_diff.index(min_diff)] # END PROBLEM 5 注意： 可以使用list.index(&lt;val&gt;)获取列表中某值的下标 Problem 6 返回为纠正单词需要修改的字符个数 参数： typed：输入单词 source：目标单词 limit：最多修改字符数 思路： 比较个位字符，若不同则执行更改，记录更改数 若一边比另一边长，长度的不同也算入更改数 若更改数比limit打，则返回任何大于limit的数（为了避免多余的计算） 要求使用递归 code： 123456789101112131415161718192021222324252627282930313233343536373839def feline_fixes(typed, source, limit): \"\"\"A diff function for autocorrect that determines how many letters in TYPED need to be substituted to create SOURCE, then adds the difference in their lengths and returns the result. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of chars that must change &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; feline_fixes(\"nice\", \"rice\", big_limit) # Substitute: n -&gt; r 1 &gt;&gt;&gt; feline_fixes(\"range\", \"rungs\", big_limit) # Substitute: a -&gt; u, e -&gt; s 2 &gt;&gt;&gt; feline_fixes(\"pill\", \"pillage\", big_limit) # Don't substitute anything, length difference of 3. 3 &gt;&gt;&gt; feline_fixes(\"roses\", \"arose\", big_limit) # Substitute: r -&gt; a, o -&gt; r, s -&gt; o, e -&gt; s, s -&gt; e 5 &gt;&gt;&gt; feline_fixes(\"rose\", \"hello\", big_limit) # Substitute: r-&gt;h, o-&gt;e, s-&gt;l, e-&gt;l, length difference of 1. 5 \"\"\" # BEGIN PROBLEM 6 # assert False, 'Remove this line' def compute(typed_w,source_w,count): if count &gt; limit: return limit+1 if typed_w == \"\" and source_w == \"\": return count elif typed_w == \"\": return compute(typed_w,source_w[1:],count+1) elif source_w == \"\": return compute(typed_w[1:],source_w,count+1) elif typed_w[0]==source_w[0]: return compute(typed_w[1:],source_w[1:],count) else: return compute(typed_w[1:],source_w[1:],count+1) return compute(typed,source,0) # END PROBLEM 6 注意： 超过limit限制的一律设为limit+1 通过slice来每次递归往后截取一位字符，比较每次截取后的首字符来判断相同与否，不相同让count+1 递归出口为两字符串均被截取成空串，返回计数 长度不同的情况下，已经被截成空串的不再截取，长串继续截取，该情况下直接让count+1 Problem 7 返回将输入字符改为目标字符所需要执行的操作次数，操作有以下： 添加字符 删除字符 替换字符 参数： typed：输入单词 source：目标单词 limit：最多修改字符数 思路： 比较输入单词与指定单词，寻找不同位置 若需要修改数量大于limit，则返回任何大于limit的值 代码需要使用递归，应需要三个递归调用以及两个递归出口 code： 123456789101112131415161718192021222324252627282930313233343536def minimum_mewtations(typed, source, limit): \"\"\"A diff function that computes the edit distance from TYPED to SOURCE. This function takes in a string TYPED, a string SOURCE, and a number LIMIT. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of edits &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; minimum_mewtations(\"cats\", \"scat\", big_limit) # cats -&gt; scats -&gt; scat 2 &gt;&gt;&gt; minimum_mewtations(\"purng\", \"purring\", big_limit) # purng -&gt; purrng -&gt; purring 2 &gt;&gt;&gt; minimum_mewtations(\"ckiteus\", \"kittens\", big_limit) # ckiteus -&gt; kiteus -&gt; kitteus -&gt; kittens 3 \"\"\" # assert False, 'Remove this line' if limit&lt;0: # Base cases should go here, you may add more base cases as needed. # BEGIN return 0 # END # Recursive cases should go below here if typed == \"\" and source == \"\": # Feel free to remove or add additional cases # BEGIN return 0 # END elif typed == \"\" or source == \"\": return abs(len(typed)-len(source)) elif typed[0] == source[0]: return minimum_mewtations(typed[1:],source[1:],limit) else: add = minimum_mewtations(typed,source[1:],limit-1) remove = minimum_mewtations(typed[1:],source,limit-1) substitute = minimum_mewtations(typed[1:],source[1:],limit-1) # BEGIN return min(add,remove,substitute)+1 # END 注意： 和上一个problem类似，使用递归与slice一位位判断 三种操作依次递归，并取最小值 Phase 3: Multiplayer 实现多人对战模式 Problem 8 将玩家输入进度与信息传入多人服务器并返回对应信息 report_progress函数 参数： typed：输入的字符，列表存储 source：需要输入的字符，列表存储 user_id：当前玩家id upload：上传进度的函数 思路： 将输入字符与需要输入字符比较，计算输入进度 输入进度指已经输入正确单词与需要输入正确单词的比例（因此，若中间有一个单词打错，后面再正确也不会记录） 函数的返回值是计算的进度 code： 123456789101112131415161718192021222324252627282930313233def report_progress(typed, source, user_id, upload): \"\"\"Upload a report of your id and progress so far to the multiplayer server. Returns the progress so far. Arguments: typed: a list of the words typed so far source: a list of the words in the typing source user_id: a number representing the id of the current user upload: a function used to upload progress to the multiplayer server &gt;&gt;&gt; print_progress = lambda d: print('ID:', d['id'], 'Progress:', d['progress']) &gt;&gt;&gt; # The above function displays progress in the format ID: __, Progress: __ &gt;&gt;&gt; print_progress({'id': 1, 'progress': 0.6}) ID: 1 Progress: 0.6 &gt;&gt;&gt; typed = ['how', 'are', 'you'] &gt;&gt;&gt; source = ['how', 'are', 'you', 'doing', 'today'] &gt;&gt;&gt; report_progress(typed, source, 2, print_progress) ID: 2 Progress: 0.6 0.6 &gt;&gt;&gt; report_progress(['how', 'aree'], source, 3, print_progress) ID: 3 Progress: 0.2 0.2 \"\"\" # BEGIN PROBLEM 8 typed_count = 0 for t,s in zip(typed,source): if t != s: break typed_count+=1 ratio = typed_count/len(source) upload({'id': user_id, 'progress': ratio}) return ratio # END PROBLEM 8 注意： 判断是否相等时，若发现不等就需要break结束循环 Problem 9 计算两个玩家输入每个单词时的用时差 time_per_word函数 参数： words：按输入顺序排列的单词列表 timestamps_per_player：一个二维列表，记录了每位玩家开始与结束输入每个单词的时间 data abstraction：match 参数： words：输入单词组成的单词列表 times：二维列表，记录了每个玩家输入每个单词需要多长时间，如times[i][j]指玩家i输入单词words[j]所花费的时间 思路： timestamps_per_player记录的是每个玩家敲每个单词的开始与结束时间 传入match后，时间会自动计算为敲每个单词使用的时间（结束-开始），并存入每个单词key对应的value中 通过get_all_word与get_all_times函数可以返回match中对应的键与值形成的列表 通过get_word与time函数可以返回指定的键与值 code: 123456789101112131415161718192021222324252627def time_per_word(words, timestamps_per_player): \"\"\"Given timing data, return a match data abstraction, which contains a list of words and the amount of time each player took to type each word. Arguments: words: a list of words, in the order they are typed. timestamps_per_player: A list of lists of timestamps including the time the player started typing, followed by the time the player finished typing each word. &gt;&gt;&gt; p = [[75, 81, 84, 90, 92], [19, 29, 35, 36, 38]] &gt;&gt;&gt; match = time_per_word(['collar', 'plush', 'blush', 'repute'], p) &gt;&gt;&gt; get_all_words(match) ['collar', 'plush', 'blush', 'repute'] &gt;&gt;&gt; get_all_times(match) [[6, 3, 6, 2], [10, 6, 1, 2]] \"\"\" # BEGIN PROBLEM 9 times = [] for l in timestamps_per_player: each_times = [] for i in range(1,len(l)): each_times.append(l[i]-l[i-1]) times.append(each_times) return match(words,times) # END PROBLEM 9 注意： 该函数的作用是通过调用match函数构造该抽象类型 但match函数需要每个单词的时间差，故需要在该函数中处理输入的时间列表（结束-开始） 将处理后的列表与传入该函数的单词列表传入match函数并返回获得的抽象类型 Problem 10 返回每个单词哪位玩家敲得块 fastest_words函数 参数： match：match函数中获得的抽象数据类型 思路： 比较多个玩家输入每个字符时间，选择输入时间最少的 返回的列表中存储了每个玩家输入最快的单词组成的列表 若多个玩家输入时间相同，则取编号更小的玩家 code: 123456789101112131415161718192021222324252627def fastest_words(match): \"\"\"Return a list of lists of which words each player typed fastest. Arguments: match: a match data abstraction as returned by time_per_word. &gt;&gt;&gt; p0 = [5, 1, 3] &gt;&gt;&gt; p1 = [4, 1, 6] &gt;&gt;&gt; fastest_words(match(['Just', 'have', 'fun'], [p0, p1])) [['have', 'fun'], ['Just']] &gt;&gt;&gt; p0 # input lists should not be mutated [5, 1, 3] &gt;&gt;&gt; p1 [4, 1, 6] \"\"\" player_indices = range(len(get_all_times(match))) # contains an *index* for each player word_indices = range(len(get_all_words(match))) # contains an *index* for each word # BEGIN PROBLEM 10 result = [[] for i in player_indices] for i in word_indices: min_player = -1 for j in player_indices: if min_player == -1 or time(match, j, i) &lt; time(match, min_player, i): min_player = j result[min_player].append(get_word(match,i)) return result # END PROBLEM 10 注意： 列表中创建多个列表要用for表达式[[] for _ in player_indices] result列表中下标表示玩家，对应元素表示该玩家最快的单词组成的列表 我们首先遍历单词，然后遍历玩家找出时间最小的玩家，并将对应单词存入该玩家对应列表","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Environments","slug":"CS61A——Environments","date":"2025-01-30T08:23:18.274Z","updated":"2025-01-30T13:43:44.143Z","comments":true,"path":"2025/01/30/CS61A——Environments/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Environments/","excerpt":"","text":"Environments Environments in Higher-orde function Local Names e.g. 123456def f(x,y): return g(x) def g(a): return a+y result = f(1,2) 该代码会报错NameError: global name 'y' is not defined 原因很明显：当执行到行4时，系统在g的作用域中找不到y，接着去全局作用域中也找不到y，因而报错 而对于嵌套函数，函数中定义的函数是可以直接使用嵌套外函数的参数的，因为在同一个作用于下 Function Composition e.g. 123456789101112def make_adder(n): def adder(k): return k+n return adder def square(x): return x*x def triple(x): return 3*x def compose1(f,g): def h(x): return f(g(x)) return h compose1函数将两个函数结合起来计算 compose1(triple,square)(5)的结果为225 compose1(square,triple)(5)的结果为75 compose1(square, makek_adder(2))(3)的结果为25 该函数实际上开辟了两个environments用来分别计算两个函数的return值 如图中蓝色和绿色的两个environments，每个中都包含了三个作用域，分别用来计算square与make_adder(2)的值，其中make_adder还会先进入adder函数的作用域 Self-Reference e.g.1 12345def print_all(x): print(x) return print_all print_all(1)(3)(5) 该函数执行后会输出1 即print_all函数可以在函数体内以return值形式返回自身，因此该函数被调用的次数与第五行后面的括号数一致（即被调用几次） e.g.2 1234567def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) 函数会把括号后面的数依次相加，输出每次相加的和 首先传入x=1，打印1，定义next_sum函数，print_sums函数返回该函数，并传入y=3，next_sum返回print_sums函数，传入值为x+y=4 再次打印4，定义next_sum函数，print_sums函数返回该函数，并传入y=5，next_sum返回print_sums函数，传入值为x+y=9 再次打印9，没有参数传入，结束 因此要注意调用表达式中传入的参数去了哪里： 1传入了print_sums，而3和5传入了print_sums的返回值next_sum函数用于求和 Currying 注意以下两种函数 12345def make_adder(n): return lambda k:n+k def add(x,y): return x+y make_adder函数一次调用一个参数，返回一个函数再调用参数 add函数调用多个参数，返回最终结果 我们可以用以下函数将add函数转换为make_adder函数 123456def curry(f): def g(x): def h(y): return f(x,y) return h return g 这样，当我们把add函数传入curry函数，我们就可以通过一次调用一个参数的方法实现相同效果 add_three = curry(add) add_three(3)(2) &gt;&gt;&gt; 5 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c)","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【数据结构】ST表","slug":"st表","date":"2025-01-28T03:05:06.000Z","updated":"2025-02-23T14:20:11.737Z","comments":true,"path":"2025/01/28/st表/","permalink":"https://izayoisakuye.github.io/2025/01/28/st%E8%A1%A8/","excerpt":"","text":"ST表 给n个数，进行m次询问，每次寻找区间[l,r]中的最大值 DP打表 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; using namespace std; int arr[N]; int ans[N][N]; int n, m; int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; for(int i = 0;i&lt;n;i++){ for(int j = i;j&lt;n;j++){ if (i==j) ans[i][j]=arr[j]; else ans[i][j]=max(ans[i][j-1],arr[j]); } } int l,r; while(m--){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ans[l][r]&lt;&lt;' '; } return 0; } 时间复杂度： 这种打表方式会很紧凑，用到了许多不用的空间 ST表 基于动态规划与倍增思想，是一种更稀疏的表 定义 dp[i][j]为一个从开始，长度为的区间最值 询问 e.g.询问[0,5] 使用max(dp[0][2],dp[4][1])，即询问区间从0开始，长度为，即[0,3]，与区间从4开始，长度为即[4,5]两个区间中的max值 e.g.询问[0,13] 使用max(dp[0][3],dp[8][2]),dp[12][1])即询问区间[0,7],[8,11],[12,13]三个区间中的max值 对于任意区间都可以分解为若干个小区间求max值 因为根据二进制，任意一个整数都可以分解为若干个2的n次幂的和 因此我们可以将任意区间划分为n个长度为不相交的区间并多次求max 若区间发生重叠，我们可以取重叠区间的max 因此询问步骤如下 求出区间长度 计算dp数组中的 计算最值 预处理 将一个区间分成两半，则每一半的长度均为，后半第一个元素下标即为 处理第一个 处理后面的 时间复杂度： 注意：st表是一个静态表，适用于离线处理 板子 1234567891011121314151617181920212223242526#include &lt;bits\\stdc++.h&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; dp; int query(int l,int r){ int j = (int)log2(r-l+1); return max(dp[l][j],dp[r-(1&lt;&lt;j)+1][j]); } int main(){ vector&lt;int&gt; arr = {9,3,1,7,5,6,0,8}; const int N = 8; // 预处理 dp = vector&lt;vector&lt;int&gt;&gt; (N,vector&lt;int&gt;((int)log2(N)+5,0)); // 初始化dp数组 for (int i = 0;i &lt; N;i++) dp[i][0]=arr[i]; for (int j= 1;j&lt;=log2(N);j++){ for (int i = 0; i+(1&lt;&lt;j)-1&lt;N;i++){ dp[i][j]= max(dp[i][j-1], dp[i+(1&lt;&lt;(j-1))][j-1]); } } // 询问 int l, r; while(cin &gt;&gt; l &gt;&gt; r){ cout &lt;&lt; query(l,r) &lt;&lt; endl; } return 0; } 时间复杂度：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【题解】2025牛客寒假集训-3","slug":"2025牛客寒假集训-3","date":"2025-01-25T16:00:00.000Z","updated":"2025-02-15T04:14:26.702Z","comments":true,"path":"2025/01/26/2025牛客寒假集训-3/","permalink":"https://izayoisakuye.github.io/2025/01/26/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-3/","excerpt":"","text":"","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【数据结构】树状数组","slug":"树状数组","date":"2025-01-25T07:33:06.000Z","updated":"2025-02-21T13:08:51.521Z","comments":true,"path":"2025/01/25/树状数组/","permalink":"https://izayoisakuye.github.io/2025/01/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"树状数组 给出一个长度为n的数组，完成以下两个操作 将第x个数加上k 输出区间内每个数的和 前缀和 使用前缀和进行询问时，可以通过询问r与l-1处的前缀和并相减获得区间数之和 但进行增加操作时，若想实现在某位置i处增加v，那么该数后面的所有元素都要对应增加v 对于这个问题，朴素算法能做到的时间复杂度，易TLE 优化思维 单个求区间和会超时，我们可以对数组进行处理： 我们可以把数字两两求和，存到另一个数组中，再进行两两求和，一直到剩一个数字 这样即使要求的数很多，我们也可以利用额外的数组计算答案 如计算前15个数的和，我们只需要计算4个数字即可 但我们可以发现，每层中第偶数个数字是没有用的，因为都可以找到更上一层的代替，去掉以后，剩下的数据恰好为n个，可以装到一个数组中，与原始数组一样长 该数组即为树状数组，每个元素都对应着树的每个节点，而每个节点对应的是原数组的某个区间和 也可以理解为每个元素是以该元素为右边界所管辖的最长区间和中元素个数 求和时只需要找到对应区间，相加即可得到答案 修改某个数据时，也只需要向上找到包含它的区间进行修改即可 lowbit()运算 定义 表示非负整数二进制表示下最低位1及其后面的0构成的数 即实现了提取最右侧1，并让其余位置变为0 e.g. 求解方法 如44，二进制为101100 首先将该数取反： 然后加一： 这时发现除了最低位1与后面的0，其余位上与原数均不同 将这两个数按位与： 故lowbit(n)=n&amp;(~n+1)=n&amp;-n 树状数组实现 我们根据序列建造一棵树，每个节点 保存以为根的子树中叶节点值之和 将每个的x转化为二进制，我们发现每一层末尾0的个数相同，且0的个数与其覆盖长度有关，每层的lowbit()值都相同 故节点覆盖长度就是lowbit(x) ，序号为i的序列正好就是长度为lowbit(i)且以i结尾的序列 且节点的父节点为 整棵树的深度为 add()操作 对于add(x,k)操作，若要在整棵树上维护这个值，需要一层一层找到父节点，并按照需要来修改这个节点的值 123void add(int x,int k){ for(;x&lt;=n;x+=x&amp;-x) t[x]+=k; } 最坏复杂度： ask()操作 向坐上找一个节点，只需要将下标-=lowbit(这个节点的下标) 12345int ask(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t[x]; return ans; } 最坏复杂度： 应用 树状数组是一个动态维护前缀和的工具 单点修改，单点查询 12add(x,k); ans=ask(x)-ask(x-1); 单点修改，区间查询 12add(x,k); ans=ask(r)-ask(l-1); 区间修改，单点查询 由差分可知，原数组第i项可以由差分数组第1项到第i项累加获得 则对于区间修改，只需要在对应l与r+1处进行val的修改即可完成对整个差分数组的修改 引入差分数组b，用树状数组维护b的前缀和，即a数组每个元素的增量 区间修改： add(l,d); add(r+1,-d) 单点查询：ans = a[x]+ask(x) 12add(l,d); add(r+1,-d); ans=a[x]+ask(x); 区间修改，区间查询 将k项数按差分数组和拆开合并如下 故我们可以维护两棵树，转换为四条add 查询操作按找公式分别计算两棵树 设树状数组维护b[i]前缀和，维护i*b[i]前缀和 区间修改： 对，add1(l,d), add1(r+1,-d) 对，add2(l,(l-1)*d), add2(r+1,-r*d) 区间查询：ans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) 12345678910111213141516171819int t1[maxn],t2[maxn]; void add1(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t1[x]+=k; } int ask1(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t1[x]; return ans; } void add2(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t2[x]+=k; } int ask2(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t2[x]; return ans; } add1(l,d); add1(r+1,-d); add2(l,(l-1)*d); add2(r+1, -r*d); ans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) 应用：逆序对 查询符合条件逆序对思路 从右往左遍历，每次将搜到的数计入词频数组++，并查询该位置右侧有多少小于该位置数的数，可以通过对词频数组进行前缀和（求和到该位置-1）获得 由于一直在查询前缀和，可以将词频数组构建树状数组，查询能到到 由于该题数据范围很大，若直接建立树状数组空间会炸，故需要离散化获得数据间的相对大小 离散化 该树状数组叫做值域树状数组：下标为值，对应值为词频，故下标要支持值域的数据范围 处理：将原数组复制并排序，从左到右遍历，且要将相同值去掉 回到原数组，用二分查找当前数在排序数组中的位置，用位置下标替换当前值 这样操作结束后，数与数之间的相对大小没有变化，故逆序对的数量也不会变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 5e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll arr[N]; ll sorted[N]; ll tree[N]; ll n; void add(ll x,ll k){ for (;x&lt;=n;x+=x&amp;-x)tree[x]+=k; } ll ask(ll x){ ll ans = 0; for (;x;x-=x&amp;-x) ans += tree[x]; return ans; } void solve() { ll re = 0; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; arr[i]; sorted[i]=arr[i]; } sort(sorted+1,sorted+n+1); // 对用于离散化的数组排序 ll m = 1; // 对sorted数组去重，以得到实际参与离散化的范围1-m for (int i = 2;i&lt;=n;i++){ if(sorted[m]!=sorted[i]){ sorted[++m]=sorted[i]; } } // 二分查找 auto b_sort = [&amp;](ll x){ ll l = 0, r = m+1, ans = 0; while(l+1!=r){ ll mid = (l+r)/2; if (sorted[mid]&gt;=x){ //ans = mid; r=mid; } else l = mid; } return r; }; for (int i = 1;i&lt;=n;i++){ arr[i]=b_sort(arr[i]); // 二分查找找到对应数在sorted的位置并将值替换为下标，进行离散化 } for (int i = n;i&gt;=1;i--){ add(arr[i],1); // 词频+1 re += ask(arr[i]-1); // 寻找小于当前数-1的词频前缀和 } cout &lt;&lt;re &lt;&lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【题解】2025牛客寒假集训-2","slug":"2025牛客寒假集训-2","date":"2025-01-23T16:00:00.000Z","updated":"2025-01-25T05:02:24.367Z","comments":true,"path":"2025/01/24/2025牛客寒假集训-2/","permalink":"https://izayoisakuye.github.io/2025/01/24/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-2/","excerpt":"","text":"F-一起找神秘的数！ ^：看作不带进位的加法 &amp;：看作哪位发生了进位（进位就是1，不进位就是0） |：不进位下就是a+b，进位就是1 故若两位都为1，则&amp;与^结果都为1，若两位都为0，则&amp;与^结果都为0，若一位是0一位是1则&amp;为0^为1 此时与和或计算求和以后就可与原两数之和相等了 又时有，因此两数相等的时候就可以满足等式 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; while(n--){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (l==0 &amp;&amp; r==0) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } cout &lt;&lt; r-l+1 &lt;&lt; endl; } return 0; } G-一起铸最好的剑！ 枚举，看哪次更接近最佳温度 注意时由于怎么乘温度都不增长，故一次即可最近 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n, m; ll cnt = 1; cin &gt;&gt;n &gt;&gt;m; if (m==1||n==1){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } if (n&lt;m){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } ll tep = m; while(tep&lt;n){ tep*=m; cnt++; } if (abs(tep-n)&gt;=abs(tep/m-n)) cout &lt;&lt;cnt-1&lt;&lt;endl ; else cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } J-数据时间？ 大模拟 注意两点： scanf格式化输入很好用，可以忽略中间的间隔符 由于前导零补齐，日期与时间的大小可以用字符串直接比较 由于同一个人在同一时段多次登录视作一次，我们可以把id插入set去重 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n, h, mon; struct node{ string id; int y, m, d; int hour, min, sec; }user[N]; set&lt;string&gt; work,nap,_sleep; // 对同一个人去重 int main() { scanf(\"%d %d %d\",&amp;n,&amp;h,&amp;mon); //printf(\"%d %d %d\",n,h,mon); for (int i =1;i&lt;=n;i++){ cin &gt;&gt; user[i].id; scanf(\"%d-%d-%d %d:%d:%d \",&amp;user[i].y,&amp;user[i].m,&amp;user[i].d,&amp;user[i].hour,&amp;user[i].min,&amp;user[i].sec ); //好用的格式化输入 } for (int i =1;i&lt;=n;i++){ if (user[i].y==h &amp;&amp; user[i].m==mon){ if ((user[i].hour&gt;=7 &amp;&amp; user[i].hour&lt;9)||(user[i].hour==9&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=18 &amp;&amp; user[i].hour&lt;20)||(user[i].hour==20&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=11 &amp;&amp; user[i].hour&lt;13)||(user[i].hour==13&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))nap.insert(user[i].id); else if ((user[i].hour&gt;=22 &amp;&amp; user[i].hour&lt;=23)||(user[i].hour&gt;=0 &amp;&amp; user[i].hour&lt;1)||(user[i].hour==1&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))_sleep.insert(user[i].id); } } printf(\"%d %d %d\",work.size(),nap.size(),_sleep.size()); return 0; } 牛可乐在演奏什么好难猜呢 K-可以分开吗？ 離さないでいて~ 递归找到蓝色地板后bfs或dfs搜索连通块，同时找每个连通块的每个蓝色地板四联通周围的灰色地板 取所有连通块周围灰色地板的最小值 注意TLE或MLE：不要在每次搜连通块时memset vis数组，不然会超时 注意注意：题目输入描述输入的是01字符串，调了一下午最后才发现是这里出了问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 510; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int dx[]={1,0,-1,0}; int dy[]={0,1,0,-1}; int n,m; int re = INF; char floors[N][N]; bool vis[N][N]; void bfs(int x, int y){ queue&lt;PII&gt; q; PII cur, net; cur.first = x,cur.second = y; q.push(cur); bool visl[N][N]={}; // bfs搜索蓝瓷砖周围的灰瓷砖时使用的访问数组 int tot = 0; while(!q.empty()){ cur = q.front(); q.pop(); for (int i = 0;i &lt;4;i++){ net.first = cur.first+dx[i], net.second = cur.second+dy[i]; if (net.first&lt;1 || net.first&gt;n || net.second&lt;1 || net.second &gt;m) continue; // 越界 if (vis[net.first][net.second]) continue; // 访问过 if (floors[net.first][net.second]=='0'){ // 搜到灰瓷砖 if (!visl[net.first][net.second]) tot++; // 未访问，计数 visl[net.first][net.second]=true; // 标记访问 continue; } vis[net.first][net.second]=true; // 标记蓝瓷砖已经访问过 q.push(net); } } re = min(re,tot); } int main() { ios cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { cin&gt;&gt;floors[i][j]; } } // 枚举查找蓝瓷砖连通块 for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { if (floors[i][j]=='1'&amp;&amp;!vis[i][j]) { // 碰到未搜过的连通块就开始搜灰瓷砖 bfs(i,j); } } } cout &lt;&lt; re; return 0; } D-字符串里串 该字符串某一个前缀的最后一个字母在后面能出现第二次即可满足 注意，也可以从后往前看，后缀的第一个字母在前面能出现第二次即可满足 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; string s; int main() { ios cin &gt;&gt; n &gt;&gt; s; s=' '+s; map&lt;char,int&gt; mp1; map&lt;char,int&gt; mp2; int ans1=0,ans2=0; for (int i = 1;i&lt;=n;i++){ mp1[s[i]]++; if (mp1[s[i]]&gt;1){ ans1 = n-i+1; break; } } for (int i = n;i&gt;=1;i--){ mp2[s[i]]++; if (mp2[s[i]]&gt;1){ ans2 = i; break; } } int ans = max(ans1,ans2); ans==1?cout &lt;&lt; 0:cout &lt;&lt; ans; return 0; } H-一起画很大的圆！ 由几何知识可得，当三点连线越发接近直线时，这三点所在的圆半径越大（理论上三点在一条直线上时所在的圆是无限大的） 对于以下一种情况是可以实现的： 即找到一条边上最右侧的一点与次右侧的一点，与另一条边（对侧）上最接近另外两点那条边下面的一点 即 若矩形竖起来，对应的三点为 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ vector&lt;PII&gt; re; int a,b,c,d; cin &gt;&gt;a &gt;&gt;b&gt;&gt;c&gt;&gt;d; if (b-a&gt;d-c){ // 横着的矩形 re.push_back({b,d}); re.push_back({b-1,d}); re.push_back({a,d-1}); } else{ // 竖着的矩形 re.push_back({a,c}); re.push_back({a,c+1}); re.push_back({a+1,d}); } for (auto t:re) cout &lt;&lt; t.first &lt;&lt;' '&lt;&lt;t.second &lt;&lt; endl; } return 0; } C-字符串外串 可以将构造的字符串分为两部分，第一部分为满足可爱度的m个字符，第二部分为剩下的字符 由D可知，若第二部分中出现了重复字符，则可爱度一定会大于m，故不满足条件； 若总长度小于可爱度那一定不可能有满足的字符串 这两种情况可以输出NO 故我们只要保证第一部分的结尾字母与第二部分的结尾字母相同即可 一种可能的构造方法： 先构造第二部分，按字母表顺序填充n-m个字符。 再构造第一部分，让第二部分反复出现即可 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n ,m; cin &gt;&gt; n &gt;&gt; m; if (n&lt;=m || m+26&lt;n) { // 特殊条件 cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } cout &lt;&lt; \"YES\"&lt;&lt;endl; string s; for (int i = 0;i&lt;n;i++){ s.push_back('a'+i%(n-m)); // 循环插入第二部分的字符 } cout &lt;&lt; s &lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【算法】滑动窗口","slug":"滑动窗口","date":"2025-01-23T02:39:01.000Z","updated":"2025-01-23T13:27:35.824Z","comments":true,"path":"2025/01/23/滑动窗口/","permalink":"https://izayoisakuye.github.io/2025/01/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口 定义 在一个数组中框定一段子数组作为窗口 若想让该窗口元素增加，可以考虑让右边界r++，即窗口从右边吸收数字 若想让该窗口元素减少，可以考虑让左边界l++，即窗口从左边弹出数字 一般解决子数组相关问题 例1/模板 给定一个含有个正整数的数组和一个正整数target 找到累加和target的长度最小的子数组并返回长度，如果不存在符合条件的则返回0 我们可以先固定子数组的左端点，让右端点右移，直到数组和大于target，由于数组所有数都为正整数，因此找到第一个累加和大于target后，后面再加一定也大于target 此时循环判断累加和是否target，若成立则剔出左侧数字，记录子数组长度 然后以该子数组为起点，右端点右移，重复上述操作，寻找等于target的子数组，记录数组长度 时间复杂度： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,tar; int a[N]; int main() { ios cin &gt;&gt; n &gt;&gt; tar; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } int ans = 0x3f3f3f3f, sum = 0, l = 0; // 定义记录结果长度，数组元素之和，左端点 for (int r = 1;r&lt;=n;r++){ // 先让右端点右移 sum+=a[r]; // 累加求和 while(sum&gt;=tar){ // 当求和大于等于目标开始移动左端点以寻找更小区间 ans = min(ans,r-l+1); // 更新最小区间 sum-=a[l++]; // 减去滑出窗口的数同时让左端点右移 } } // 找到符合目标的区间 if (ans&lt;=n) cout &lt;&lt; ans; else cout &lt;&lt; 0 ; return 0; } 例2 给定一个字符串，找出不含有重复字符的最长字串长度 即寻找最长无重复字符的窗口 让右边界一直右移，直到遇到重复字符，让左边界移动到max(左边界，重复字符上次位置+1) 因为任何时候窗口情况一定是没有重复数组在内的，若重复字符上次位置比此时左边界小，则若还是移动到重复字符上次位置+1的话，窗口会变长，不保证加长部分会不会又出现重复字符 若右移后无重复字符，可以看作重复字符位置为-1或不存在，用max仍保持原左边界 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s; for (int i = 0;i&lt;s.size();i++) cnt[s[i]]=-1; // 初始化都为第一次出现 int ans = 0; // 记录最长区间 for (int l = 0, r = 0;r&lt;s.size();r++){ l = max(l,cnt[s[r]]+1); // 左边界移动 ans = max(ans,r-l+1); // 记录结果 cnt[s[r]]=r; // 更新上次出现字符位置为当前r位置 } cout &lt;&lt; ans; return 0; } 例3 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 我们可以逆向以一种”debt”思维解决。遍历要查找的字符，发现一个-1，这样需要查找的字符数都为负数，在查找时，每个字符出现后对应加一，则非 要查找字符将始终为正数，而要查找的字符为负数 先让右边界右移，当debt变为0（窗口包含了足够要查找的字串），开始移动左边界，使字串最小，这时debt大于0的都为不需要查找的字符，故可以左移，直到碰到需要查找的不再移动。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s,t; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s &gt;&gt; t; if (s.size()&lt;t.size()){ cout &lt;&lt; \"\"; return 0; } for (int i = 0;i&lt;t.size();i++) cnt[t[i]]--; int len = INF, start = 0; // len用于记录最小字串，start记录字串开头，便于输出 int debt = t.size(); for (int l = 0, r = 0;r&lt;s.size();r++){ if (cnt[s[r]]++&lt;0) debt--; // 字符计数加一后仍是负的，证明是要查找的(debt的)字符，让debt-- if(debt==0){ // 所有字符都查到后 while(cnt[s[l]]&gt;0){ // 寻找最小子区间 cnt[s[l++]]--; // 若是非查找字符，可以让左边界右移拿回 } if (r-l+1&lt;len){ // 记录最小子区间以及开始位置 len = r-l+1; start = l; } } } // 若查不到则输出空字符串，否则截取字符串输出 len == INF ? cout &lt;&lt;\"\" : cout &lt;&lt; s.substr(start,start+len); return 0; } 总结 关键：找到范围和答案指标之间的单调性关系 求解大流程：求子数组在每个位置开头或结尾情况下的答案","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构】优先队列","slug":"优先队列(priority_queue)","date":"2025-01-22T13:35:19.944Z","updated":"2025-01-23T12:54:03.554Z","comments":true,"path":"2025/01/22/优先队列(priority_queue)/","permalink":"https://izayoisakuye.github.io/2025/01/22/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97(priority_queue)/","excerpt":"","text":"优先队列(priority_queue) 优先队列可以用来存储具有优先级的元素，队头的元素都是当前队列中优先级最高(或最低)的元素 STL中的优先队列默认为最大堆，即优先级最高的先出队 结构 优先队列的结构 优先队列仅维护堆顶(top)，其余元素优先级都比堆顶小 初始化 优先队列使用需要引入头文件queue 如下代码可以声明一个优先队列，其中T为数据类型，优先队列中的数据数据类型都相同 注意：使用结构体时，需要重载小于号或声明一个比较类并重载()运算符 123456789101112131415161718192021222324#include &lt;bits\\stdc++.h&gt; using namespace std; struct node{ int x, y; // 使用结构体需要重载小于号 bool operator &lt; (const node &amp;u)const{ return x == u.x? y&lt;u.y : x&lt;u.x; } }; // 或重载()运算符实现比较 struct cmp{ bool operator ()(const int &amp;u, const int &amp;v)const{ return u&gt;v; } }; int main(){ // 声明优先队列，整型，默认大顶堆(最大元素在顶上) // 一般声明一个空优先队列 priority_queue&lt;T&gt; pque; // 声明一个小顶堆,传入仿函数, 第二个参数表示优先队列底层储存容器为vector priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; } 基本操作 1234567891011121314// 取出堆顶 cout &lt;&lt; pque.top() &lt;&lt; endl; // 插入元素到队尾并执行上浮操作 pque.push(1); // 弹出堆顶 pque.pop(); // 返回队列元素个数 cout &lt;&lt; pque.size() &lt;&lt; endl; // 判断队列是否为空 cout &lt;&lt; pque.empty() &lt;&lt; endl; //间接修改堆顶元素 int x = pque.top(); pque.pop(); pque.push(x+1); 注意：priority_queue没有迭代器，不能用begin()，end()，auto等遍历，也不能直接修改队列中的元素","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"}]},{"title":"【题解】2025牛客寒假集训-1","slug":"2025牛客寒假集训-1","date":"2025-01-21T14:15:49.000Z","updated":"2025-01-23T02:30:49.763Z","comments":true,"path":"2025/01/21/2025牛客寒假集训-1/","permalink":"https://izayoisakuye.github.io/2025/01/21/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-1/","excerpt":"","text":"(按官方难度排序) A-茕茕孑立之影 考虑特殊情况：若数组中包含1，则一定是1的倍数，可以直接输出-1 考虑一般情况：质数的因数只有1和他本身，又数组中不含1，因此任意一个比该数组中最大数还大的质数肯定不是数组中的倍数，又因为该数都比数组中的数大，因此也不可能是他的倍数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; bool is_prime(int n){ if (n==1) return 0; if (n==2) return 1; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0) return 0; } return 1; } int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } for (int i = 1;i&lt;=n;i++){ if (a[i]==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; break; } } if (flag) continue; cout &lt;&lt; 1000000007 &lt;&lt; endl; } return 0; } D-双生双宿之决 用map存储出现数字次数后比较即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,cnt=0; map&lt;int,int&gt; a; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; a[tep]++; } if (n&amp;1){ cout &lt;&lt; \"No\" &lt;&lt; endl; continue; } if (a.size()!=2){ // 判断值的个数用size cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } else{ set&lt;int&gt; tep; for (auto &amp;pr:a){ tep.insert(pr.second); } if (tep.size()!=1) { cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } } cout &lt;&lt; \"Yes\"&lt;&lt;endl; } return 0; } B-一气贯通之刃 即判断这些节点能不能连成一条链，若是的话输出头尾，不是的话输出-1 若有两个节点度数为1，其余节点度数都为2则是一条链 故可以用map记录每个节点出现次数并判断 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=(n-1)*2;i++){ int tep; cin &gt;&gt; tep; num[tep]++; } vector&lt;int&gt; p; for (auto &amp;pr:num){ if (pr.second&gt;2){ cout &lt;&lt; -1 &lt;&lt; endl; return 0; } if (pr.second==1)p.push_back(pr.first); } for (auto t:p) cout &lt;&lt; t &lt;&lt;' '; return 0; } G-井然有序之衡 由于同时加一减一对数组总和没有影响，而最后生成的permutation正好为一个的等差数列，故可以实现的条件为数组数值之和等于该等差数列前项和 将数组排序，每一位正好对应permutation从1开始的每一位，计算每位数与对应permutation之差求和即可以得到需要操作多少次加一或减一才能变成对应permutation 注意：一次操作包含一次加一与一次减一，故最后结果要除二 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll n,op; ll a[N]; int main() { ios cin &gt;&gt;n; ll sum=0; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; sum+=a[i]; } if (1ll*n*(n+1)/2!=sum){ cout &lt;&lt; -1; return 0; } sort(a+1,a+1+n); for (int i = 1;i&lt;=n;i++){ op += abs(a[i]-i); } cout &lt;&lt; op/2; return 0; } E-双生双宿之错 中位数定理： 中位数有一个性质：一个数列中所有数与中位数之差的绝对值之和最小，因为中位数是处于中间的数 即若要通过加一减一将一个数组所有数变为相同，最少操作次数即将他们变为中位数 对于这道题，我们要做到的是将数组所有数变为两个数，且出现次数相同，故我们可以按照D题的思路，将数组排序后分为前后两部分，分别求出其中位数后计算两部分各达到各自中位数所需要的操作次数求和 若两侧中位数相同，我们可以选择将前半部分中位数-1或将后半部分中位数+1并计算，取最优 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n,op=0; ll a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); // 排序 ll midl = a[((n/2)+1)/2], midr = a[((n/2)+1)/2+n/2]; // 计算前后两部分中位数 //cout &lt;&lt; midl &lt;&lt; ' ' &lt;&lt; midr &lt;&lt; endl ; if (midl!=midr){ // 正常情况 // 分两部分计算到达中位数所需要的操作次数 for (int i = 1;i&lt;=n/2;i++){ op+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op+=abs(a[i]-midr); } cout &lt;&lt; op &lt;&lt; endl; } else{ // 两侧中位数相等 // 将左侧中位数-1并计算操作次数 ll mid1 = midl-1; ll op1 = 0; for (int i = 1;i&lt;=n/2;i++){ op1+=abs(a[i]-mid1); } for (int i = n/2+1;i&lt;=n;i++){ op1+=abs(a[i]-midr); } // 将右侧中位数+1并计算操作次数 ll mid2 = midr+1; ll op2 = 0; for (int i = 1;i&lt;=n/2;i++){ op2+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op2+=abs(a[i]-mid2); } // 输出更优结果 cout &lt;&lt; min(op1,op2)&lt;&lt;endl; } } return 0; } H-井然有序之窗 对于n个区间选数，区间内数多要尽量放在后面选，因为选择可能性更多 在选第i个数时，我们的重点是右界的大小，不管左边从哪开始都可以看成从i开始，因为其余的已经放完了 e.g. 区间 [1,3] [5,5] [3,5] [2,7] [3,4] [2,4] [4,7] permutation 1 5 4 6 3 2 7 因此我们可以总结如下步骤 按左界排序：决定i能不能放进去（左界相等时右界小的在前） 每次询问i放在哪个区间时，找出对应左界为i的区间，放入右界更小的区间内 因此需要一个容器来存储区间 此时，放入的区间应为当前左界为i的区间与左界为i-1且没被用过的区间，要在这些区间中寻找右界更小的区间 也就是每次往该容器里填入区间，并把容器内所有区间排序，取出右界最小的区间，当前i可以放在该区间内 故我们可以使用priority_queue实现，且为小根堆 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; vector&lt;vector&lt;PII&gt;&gt; a(n+10); // 按左端点分类存入区间右端点与区间位置 for (int i = 1;i&lt;=n;i++){ int l,r; cin &gt;&gt; l &gt;&gt; r; a[l].push_back({r,i}); } int ans[N]; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;&gt;&gt; pq; for (int i = 1;i&lt;=n;i++){ // 询问哪个数就把该数所在的区间左界的区间右界与区间位置添入优先队列 for (auto &amp;pr:a[i]) pq.push(pr); // 判断当前数是否能从区间中取到，若不能就pop换下一个 while(!pq.empty() &amp;&amp; pq.top().first&lt;i) pq.pop(); // 若都不能从当前区间中取到，表明不存在满足的，直接-1 if (pq.empty()) { cout &lt;&lt; -1 ; return 0; } // 记录当前数所在的区间位置 ans[pq.top().second]=i; pq.pop(); } for (int i = 1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【题解】Codeforces Round 998 (Div. 3)","slug":"Codeforces-Round-998-Div-3","date":"2025-01-21T14:15:30.000Z","updated":"2025-01-22T06:08:35.976Z","comments":true,"path":"2025/01/21/Codeforces-Round-998-Div-3/","permalink":"https://izayoisakuye.github.io/2025/01/21/Codeforces-Round-998-Div-3/","excerpt":"","text":"A- Fibonacciness 题意 给予，求满足的 思路 枚举所有可能的取最大值，有以下情况 代码 123456789101112131415161718192021222324252627282930313233// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int a1,a2,a4,a5; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a4 &gt;&gt; a5; int a31 = a1+a2; int a32 = a4-a2; int a33 = a5-a4; if (a31==a32 &amp;&amp; a32 == a33) cout &lt;&lt; 3 &lt;&lt; endl; else if (a31==a32 || a32 == a33 || a31==a33) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; } return 0; } B-Farmer John’s Card Game 题意 个人手里有张牌，每个人每轮出一张牌在牌堆上，需要满足牌上数字大于牌堆顶数字，若某人无法防止满足条件的牌（手里有牌的情况下）游戏便失败 构造一个permutation代表出牌顺序，使得所有人最后都能出完牌 思路 考虑特殊情况：时，它只需要按照数值递增顺序放置卡牌即可胜利，故只需要输出1 一般情况：为了按照递增顺序放置卡牌，每个人需要按照从小到大的数值出牌 又因为一个人一轮只能出一张牌，因此如果一个人手里有两张连续数值的卡牌，他出完更小的一张之后，其他人出的牌肯定会比他更大的一张牌大，这样他手里总会留下那张牌，导致失败 若没有上述情况，只要对每个人手里的牌排序，按照第一张牌的大小从小到大出牌即为正确顺序 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e3 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; //t++; while(t--){ int n, m,tep=0; int a[N]={},ord[N]={},b[N]={}; cin &gt;&gt; n &gt;&gt; m; int flag=0; for(int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ cin &gt;&gt; a[j]; tep++; } sort(a+1,a+1+m); if (n==1 &amp;&amp; flag != 1) { cout &lt;&lt; 1 &lt;&lt; endl; flag = 1; break; } for (int j = 1;j&lt;m;j++){ if (abs(a[j+1]-a[j])==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; for (int i = 1;i&lt;=n*m-tep;i++) { int t; cin &gt;&gt; t; } break; } } if (flag) break; ord[a[1]]=i; } if (flag) continue; for (int i = 0;i&lt;n*m;i++){ if (ord[i]!=0) cout &lt;&lt; ord[i]&lt;&lt;' '; } cout &lt;&lt; endl; } return 0; } C-Game of Mathletes 题意 个数，Alice和Bob轮流每次选择一个数并去除，若两数之和等于则分数加一，求最终分数 思路 对于每组数分数是固定的，因为只要Alice选一个数，Bob就会选择数，因此只要看有几组数满足即可 这里单纯枚举会TLE，可以使用双指针优化 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,k,score=0; int a[N]; cin &gt;&gt; n &gt;&gt; k; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } sort(a+1,a+1+n); // 排序 int l = 1, r = n; // 对撞指针，分别指向头尾 while(l&lt;r){ int sum = a[l]+a[r]; // 计算和 if (sum==k){ // 满足条件 score++; // 分数加一 l++,r--; // 两端指针同时移动，计算下一组数 } else if (sum&lt;k)l++; // 若和比条件小，则让和变大，左指针右移 else r--; // 若和比条件大，则让和变小，右指针左移 } cout &lt;&lt; score &lt;&lt; endl; } return 0; } D-Subtract Min Sort 题意 一个数组，你每次可以让两个相邻的数一起减去他们之中的最小值。问能不能使数组非递减 思路 对于数与，在进行操作后一定会有一个数变为0，若为0，则之后的操作一定会让变为0以保证数组非递减 考虑最右端的与，若为0，则这之前的所有数都为0 因此我们考虑两个元素与，将两者减去最小的那个，其中一个变为0，则该数之前一定都为0，而后面的不变 考虑特殊情况，若想让变为0，那么只能让同时减去而没有其他方法，这导致恒成立 对于一般情况，三个连续的数,与，我们希望先算后面两个数，这样可以让减去更多的值，以确保小于，此时若变为0，连带着也会变为0，若不变为0，则之后一定需要同时减一个让他们保证是非递减的 因此我们可以反过来，先从头对与操作，一步步往后操作。若每一组都操作结束后仍有，则无法实现，否则我们可以通过排序实现非递减数组。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 0;i&lt;n;i++) cin &gt;&gt; a[i]; if (a[0]&gt;a[1]){ // 特判第一个和第二个 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } for (int i = 1;i&lt;n-1;i++){ a[i]-=a[i-1]; // 往前减 if (a[i]&gt;a[i+1]){ // 减后若还是大则不行 cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = 1; break; } } if (!flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"}]},{"title":"【题解】牛客周赛 Round 77","slug":"牛客周赛-Round-77","date":"2025-01-19T13:37:37.000Z","updated":"2025-01-21T14:19:46.159Z","comments":true,"path":"2025/01/19/牛客周赛-Round-77/","permalink":"https://izayoisakuye.github.io/2025/01/19/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-Round-77/","excerpt":"","text":"A-时间表 把时间放到数组中按下标搜索即可 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios int a[]={20250121,20250123,20250126,20250206,20250208,20250211}; cin &gt;&gt; n; cout &lt;&lt; a[n-1]; return 0; } B- 数独数组 形如以下的数组其实都可以： 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 8 9 1 2 3 4 5 6 7 8 9 … 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 … 即每种数字出现次数要不相等，要不相差1，且都必须出现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int a[N]; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=9;i++) num[i]=0; // 初始化map for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; num[tep]++; // 统计数字出现次数 } // 该特判可以不要 for (int i = 1;i&lt;=9;i++) { if (num[i]==0){ cout &lt;&lt; \"NO\"; return 0; } } for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;=9;j++){ if (num[i]!=num[j]) { // 两数不等的情况下 if(abs(num[i]-num[j])!=1){ // 差值只能为1 cout &lt;&lt; \"NO\"; return 0; } } } } cout &lt;&lt; \"YES\"; return 0; } C-小红走网格 将行列分开看，逻辑相同 由于每次移动距离固定，因此问题可以转化为以下条件： 在x方向是否存在整数（向右次数）与（向左次数）使得 在y方向是否存在整数（向右次数）与（向左次数）使得 即同余方程的可解性，可以见逆元部分 故两方程等价于与 由此我们引入裴蜀定理： 设是不全为0的整数，对任意整数，满足，且存在整数使 因此只要满足是的倍数，是的倍数，就有对应的解，即能到达指定位置 123456789101112131415161718192021222324252627282930313233343536373839// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int gcd(int a, int b){ return b?gcd(b,a%b):a; } int main() { ios cin &gt;&gt; t; while(t--){ int x,y,a,b,c,d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (x%gcd(c,d)!=0) { cout &lt;&lt; \"NO\" &lt;&lt; endl; } else if (y%gcd(a,b)!=0){ cout &lt;&lt; \"NO\" &lt;&lt; endl; } else cout &lt;&lt; \"YES\"&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【Python】CS61A——Higher-Order Functions","slug":"CS61A——Higher-order Functions","date":"2025-01-19T01:03:01.170Z","updated":"2025-01-30T09:40:55.863Z","comments":true,"path":"2025/01/19/CS61A——Higher-order Functions/","permalink":"https://izayoisakuye.github.io/2025/01/19/CS61A%E2%80%94%E2%80%94Higher-order%20Functions/","excerpt":"","text":"Higher-Order Functions 函数特征 一个函数的定义域(domain)即为所有可能的输入 一个函数的值域(range)即为所有可能的输出 一个纯函数表现即为建立输入与输出之间的映射 assert语句 格式：assert &lt;bool expression&gt; &lt;output information&gt; 用处：当布尔表达式成立时，语句继续执行；当布尔表达式不成立时，程序跳出并提示指定的报错信息。 函数作为形参 设计一个计算求和、立方项求和的函数，我们可以通过在对求和函数中传入对每一位数的操作对应的函数来简化代码，而非为不同种类求和分别设计函数，如下： 1234567891011121314151617181920212223242526272829from math import pow def identity(k): return k def cube(k): return int(pow(k,3)) def summation(n,term): \"\"\"sum the first N terms of a sequence. &gt;&gt;&gt; summation(5,cube) 225 \"\"\" total,k=0,1 while k&lt;=n: total,k = total + term(k), k+1 return total def sum_naturals(n): \"\"\"sum the first N natural numbers &gt;&gt;&gt; sum_naturals(5) 15 \"\"\" return summation(n,identity) # 传入返回原值函数进行计算 def sum_cubes(n): \"\"\"sum the first N cubes of natural numbers &gt;&gt;&gt; sum_cubes(5) 225 \"\"\" return summation(n,cube) # 传入返回每个值的立方函数进行计算 其中，summation函数中的term参数与传入的函数有关 identity与cube函数作为单个参数传入summation函数，以处理不同情况下的求和 形参term函数在计算total时被回调，回调的是传入的对应函数 函数作为返回值 当一个函数在另一个函数体内定义，该函数的名称绑定在本地作用域中 如下： 123456789def make_adder(n): \"\"\"return a function that takes one argument called k and return k+N &gt;&gt;&gt; add_three = make_adder(3) &gt;&gt;&gt; add_three(4) 7 \"\"\" def adder(k): return k+n # adder函数返回数值k+n return adder # make_adder函数返回adder函数 make_adder函数返回一个函数adder，而函数adder是局部定义的函数，它可以使用make_adder内部的变量（k与n） 对于语句make_adder(1)(2)，实现的效果即为1+2 作用 函数是第一类值(first-class)：函数可以作为参数传递，作为返回值返回 higher-order函数指代以函数作为参数或返回值的函数 它可以表示计算的一般情况 它可以防止程序代码过于重复冗杂 它可以将不同功能分离成多个函数 匿名函数(Lambda Expressions ) 格式：lambda &lt;formal parameter&gt;: &lt;return value&gt; lambda指定义一个匿名函数 lambda后紧跟一个形式参数，冒号后为返回值（无return关键字） 返回值只能是一句表达式 使用时将其赋值给一个变量并按照def函数方式调用或直接按照def函数方式调用 与def不同的一点是：def定义的函数拥有一个内部名称(intrinsic name)，而lambda定义的函数即使赋值给了另一个名字的变量，它的名称仍为lambda 返回语句(Return Statements) 函数中的return语句让程序返回到先前的environment，并给函数一个值 在执行函数体时，遇到return语句函数即结束 看如下例子： 123456789101112131415161718192021def search(f): \"\"\"find a number that one more than the square root of the number put in the positive function &gt;&gt;&gt; search(positive) 11 \"\"\" x=0 while not f(x): # 当positive函数返回为0时进入循环 x+=1 return x def square(x): return x**2 def positive(x): return max(0,square(x)-100) def inverse(f): \"\"\"return g(y) such that g(f(x)) -&gt;x &gt;&gt;&gt; inverse(square)(16) 4 \"\"\" return lambda y: search(lambda x:f(x)==y) # 返回某个完全平方数的平方根 positive函数： ​ 传入search后，寻找的是第一个比positive函数中减数的平方根大的数 ​ 因为若数x的平方比减数小，return值肯定是0，while条件成立，x++继续寻找 inverse函数： inverse用于寻找完全平方数y的平方根 传入square函数用于计算search函数中x的平方，与inverse函数返回的lambda函数中传入的y比较是否相等，若不相等，满足while循环条件，x++继续比较，若相等则找到，跳出循环返回此时x值。 控制语句(Control Statements) 条件语句 执行条件：每一句clause按序执行 判断条件判断语句是否成立（若存在） 若值为true或遇到else的clause，执行语句块并跳过其余clauses 但为何没有一个函数能实现条件判断呢？ 对于调用表达式(call expression)的执行如下： 而在if语句中，只有其中一句会被执行，因此使用函数替代并不合适，如下代码： 12345678910111213def if_(c,t,f): if c: return t else: return f from math import sqrt def real_sqrt(x): return if_(x&gt;0,sqrt(x),0.0) if __name__ == '__main__': print(real_sqrt(-4)) 我们需要实现返回一个实数平方根结果的实部，众所周知，负数开平方后实部为0，因此负数应输出0 但执行后发现却出现了sqrt的 ValueError: math domain error 因为在函数调用时，sqrt(x)同时也会执行，此时x小于0故触发了sqrt的assert 因此没有了控制语句，我们只能在值之间选择而不能在条件之间选择 条件语句的简单形式 &lt;consequent&gt; if &lt;predicate&gt; else &lt;alternative&gt; 执行predicate语句 若为真，则整个表达式的值为consequent的值 若为假，则整个表达式的值为alternative的值 逻辑运算符的短路效应 执行一个语句&lt;left&gt; and &lt;right&gt; 计算left语句 若结果是false，则整个表达式的结果是false 若结果是true，则整个表达式的结果是right语句的结果 执行一个语句&lt;left&gt; or &lt;right&gt; 计算left语句 若结果为true，则整个表达式的结果是true 若结果为false，则整个表达式的结果是right语句的结果 HW Lecture4的作业部分 柯里化(Currying) 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c) 如上文中的makeadder函数，返回的是在内部定义的adder函数，每个函数接受一个参数，等同于makeadder(k,n) 柯里化是函数式编程的一个体现，使得函数代码更简洁 1-Product My solution: 123456x = 1 re = 1 while x&lt;=n: re*=term(x) x+=1 return re product函数有一个term参数用于接收函数，根据不同计算需要可以传入不同计算相关函数(square，identity等) 2- Accumulate My solution: 123456a=1 re=start while a&lt;=n: re = fuse(re,term(a)) a+=1 return re 1return accumulate(add, 0, n, term) 1return accumulate(mul, 1, n, term) 在上一题的基础上添加了选择每个数之间使用加法还是乘法的参数fuse，fuse同时也是接收函数来指定每个term运算之间的运算方式(add,mul 等) 3-Make repeater My solution: 12if n == 0: return lambda x: x return lambda x: f(make_repeater(f,n-1)(x)) 这里需要将传入的数值执行n次指定运算f，即f(f(...f(x)...)) 本人使用了递归实现，即make_repeater(f,n)(x)=f(make_repeater(f,n-1)(x))=f(f(make_repeater(f,n-2)))=...=f(f(...f(x)...)) 每次加一层f()，直到时替换为x","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【题解】牛客小白月赛109-C","slug":"牛客小白月赛109-C","date":"2025-01-17T14:16:39.000Z","updated":"2025-01-17T16:42:49.194Z","comments":true,"path":"2025/01/17/牛客小白月赛109-C/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B109-C/","excerpt":"","text":"题目描述 Tobo 养了 nnn 只猪猪，猪猪们的编号为 。我们规定两种操作： 1. 对于给定的 l,r 表示 Tobo 要和编号为 l 到 r的猪猪按顺序玩耍，但因为 Tobo 喜新厌旧，所以已经玩耍过的猪猪不会再一起玩，会直接跳过它。 2. 对于给定的 x ，表示编号为 x 的猪猪想知道自己是第几个和 Tobo 玩耍的，如果没有玩耍过则输出 0 。 你一共需要处理 q 次操作。 输入描述: 第一行输入两个整数 代表 Tobo 养的猪猪数量、操作次数。 此后 q 行，每行先输入一个整数 表示操作类型，随后： 若 op=1，在同一行上输入两个整数 代表 Tobo 将依次和编号为 l 到 r的猪猪玩耍。 若 op=2，在同一行上输入一个整数 代表一次询问。 输出描述: 对于每一次询问，在单独的一行上输出一个整数，表示询问的猪猪是第几个和 Tobo 玩耍的；若没有玩耍过，则直接输出 0。 输入 123456785 7 1 2 3 2 3 1 3 5 2 4 2 1 1 1 5 2 1 输出 12342 3 0 5 说明 123对于第一次操作，Tobo 将依次和编号为 2,3 的猪猪玩耍； 对于第二次操作，编号为 3 的猪猪想知道自己是第几个和 Tobo 玩的，输出 2 ； 对于第三次操作，Tobo 将依次和编号为 3,4,5的猪猪玩耍，这其中，由于编号为 3 的猪猪已经和 Tobo 玩过，所以 Tobo 会跳过它，直接和编号为 4 的猪猪玩耍。 错解 每次操作1遍历区间，暴力枚举每一只猪，若没有玩过则赋值为当前玩过的第n只猪，若玩过则直接跳过 该方法会TLE（后面又加强数据了优化后的暴力也差一点点ww） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; int play[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; int tep = 0; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (tep&gt;=n) continue; // 全部玩过后直接跳过 if (play[l]==0) { // 遍历区间的左端赋值 tep++; play[l]+=tep; } for(int i = l; i&lt;r;i++){ // 遍历l到r并赋值为第tep只玩过的猪 if (play[i+1]==0) { tep++; play[i+1]=tep; } } } else { // 询问操作 int p; cin &gt;&gt;p; cout &lt;&lt; play[p]&lt;&lt;endl; } } return 0; } 正解 前置知识 lower_bound()函数： 定义：const_iterator lower_bound( const K&amp; x ) const; STL内置函数，用于寻找第一个大于等于key的值，返回值为指向刚好大于等于key的下一个元素，若不存在则返回末尾迭代器（指向最后一个元素） 解析 我们可以使用set来优化 由于每只猪的编号都连续且不相同，我们可以用set来存储 使用lower_bound()函数查找在待查找区间里下一个没有玩过的猪 然后将该猪标记为第n个玩的，从集合中删除 这样可以保证集合里始终都是没有被玩过的猪，每次查找都找到离l最近的一个没有被玩过的猪，直到区间删空，即所有猪都被玩过 询问操作直接输出标记 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; set&lt;int&gt; pig; int tag[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; pig.insert(1e9); // 防止最后全删完后剩下索引0处无法跳出 for (int i = 1;i&lt;=n;i++) pig.insert(i); // 把所有猪存入集合 int cnt = 1; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l,r; cin &gt;&gt; l &gt;&gt; r; while(1){ int tep = (*pig.lower_bound(l)); // 用lower_bound()返回第一个大于l的数，即找到下一个在区间内且没有玩过的猪 if (tep&gt;r) break; // 区间为空，寻找结束 tag[tep]=cnt; // 标记找到的猪是第几个被玩的 cnt++; pig.erase(tep); // 把被玩过的猪从集合中删除 } } else { // 询问猪是第几个玩的 int p; cin &gt;&gt; p; cout &lt;&lt; tag[p]&lt;&lt;endl; } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【C/C++】指针","slug":"指针","date":"2025-01-17T06:53:15.466Z","updated":"2025-01-22T12:16:27.333Z","comments":true,"path":"2025/01/17/指针/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E6%8C%87%E9%92%88/","excerpt":"","text":"指针 数据在内存中的存储 这是一段内存，他被分成了许多段，每段一个byte 当我们声明一个变量int a，计算机会给该变量分配一块空间，分配取决于数据类型与编译器 如：int 与float占4bytes，char占1bytes 当我们给变量a赋值a=5，计算机会去寻找该变量，去到他的地址，以二进制写入数据 指针的基础使用 指针是一种变量，它可以存储变量的地址 使用数据类型* 变量名创建一个指针：int *p char *c 使用取地址符&amp;获取一个变量的地址，并可以将指针指向该变量地址：p=&amp;a print p，print &amp;a，print &amp;p分别对应打印p指向(a)的地址，a的地址，p的地址 将一个*放在指针变量前，可以对指针进行解引用，即获取p指向地址的值 则print *p会返回a的值，*p = 8会更改a的值到8 实例代码： 1234567891011121314151617181920#include&lt;stdio.h&gt; int main(){ int a=5; int* p; // 若该指针p没有被初始化，p会变成一个野指针，会因为指向任意位置而报错 p = &amp;a; // 储存a的地址 // 上两行等同于int* p = &amp;a; printf(\"A:%d\\n\",p); // a的地址 printf(\"V:%d\\n\",*p); // a的值 printf(\"A:%d\\n\",&amp;a); // a的地址 *p = 12; // 更改p指向地址(a)的元素值 printf(\"A:%d\\n\",a); // 更改后的a值 int b = 20; *p = b; // p不会指向b，只会将b的值赋给a printf(\"A:%d\\n\",p); // 还是a的地址 printf(\"V:%d\\n\",*p); // b的值 return 0; } 指针类型 不同的数据类型占据不同的内存： int：4bytes char：1byte float：4bytes void指针： 可以存放任意类型的指针，且无需强制类型转换 需要进行显式转换后才能赋值给其他类型 可以与其他类型指针直接比较地址值 只有强制类型转换后才能操作（解引用、算术运算等） 可以和普通指针一样传入NULL或nullptr表示空指针 作为函数输入输出时，表示可以接受任意类型和输出任意类型的指针 指针类型间的转换 定义一个变量int a=1025： 他在内存中的布局为（从右到左分别为第0 1 2 3个字节，他们的地址也是连续的）： 其中，最左边的一位为符号位，0为整数1为负数 若我们定义一个字符指针c指向a，由于字符只占一个字节，故c只会指向a的第一个字节： 对c进行算术运算(+1)会让他指向下一个字节 以至于得到4 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; int main(){ // 一个整形指针 int a = 1025; // 在二进制中为四字节:00000000 00000000 00000100 00000001 int* p; p = &amp;a; printf(\"size of integer is %d\\n\", sizeof(int)); printf(\"Address = %d, value = %d\\n\",p,*p); // 一个字符指针 char *c; c = (char*)p; // 进行强制类型转换 printf(\"size of integer is %d\\n\", sizeof(char)); // 由于char指针只有一个字节,则机器只看从右边开始的一个字节 即00000001 printf(\"Address = %d, value = %d\\n\",c,*c); // 增加一个字节,则指针指向从右边开始的第一个字节 即00000100 printf(\"Address = %d, value = %d\\n\",c+1,*(c+1)); // 一个void指针 void *p0; p0 = p; // 不需要显式的类型转换 // 当p0没指向任何特定类型时,不能解引用 printf(\"Address = %d, value = %d\\n\",p0,*p0); // 也不要进行算术运算 printf(\"Address = %d %d\\n\",p0,p0+1); } 指针算术运算 对一个指针进行加1操作，相当于将该指针增加一个该指针数据类型所占字节数的字节数 例如对int *p=&amp;a; p++;得到p的值为a的地址加4 123456789101112#include &lt;stdio.h&gt; int main(){ int a = 10; int *p; p = &amp;a; // 指针加法 : +1代表增加一个数据类型的字节数 printf(\"Address p is %d\\n\",p); // p的地址 printf(\"Value at address p is %d\\n\",*p); // p指向的值 printf(\"size of integer is %d bytes\\n\", sizeof(int)); // int类型所占的字节数 printf(\"Address p+1 is %d\\n\",p+1); // p+1指向的地址 printf(\"Value at address p+1 is %d\\n\",*(p+1)); // p+1指向的值(垃圾值) } 指向指针的指针 假设定义了一个数据int x = 5; 我们定义一个指针指向x int *p = &amp;x 此时我们可以再定义一个指针指向指针p int **q = &amp;p 甚至还可以定义一个指针指向指针q int ***r = &amp;q (r是205) 示例代码 123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int x =5; int* p = &amp;x; *p = 6; int** q = &amp;p; int*** r = &amp;q; printf(\"%d\\n\",*p); // p指向x的值 printf(\"%d\\n\",*q); // q指向p的值(x的地址) printf(\"%d\\n\",*(*q)); // q指向p的值指向x的值 printf(\"%d\\n\",*(*r)); // r指向q的值,q指向p的值 printf(\"%d\\n\",*(*(*r))); // r指向q的值,q指向p的值,p指向x的值 // 更改x的值 ***r = 10; print(\"x = %d\\n\", x); // **q与*p都指向x的值,则相当于x自加2 **q = *p +2; print(\"x = %d\\n\", x); } 指针用例—函数传引用 or 传值？ e.g. 局部变量与全局变量： 有以下代码 12345678910#include &lt;stdio.h&gt; void f(int x){ x=x+1; } int main(){ int x=10; f(x); printf(\"%d\\n\",x); return 0; } 该代码中的函数想让变量+1，但输出的结果显然还是10，这是为什么呢？ 看以下代码： 1234567891011#include &lt;stdio.h&gt; void f(int x){ printf(\"Address of x in f is:%d\\n\",&amp;x); x=x+1; } int main(){ int x=10; f(x); printf(\"Address of x in main is:%d\\n\",&amp;x); return 0; } 你会惊奇的发现，f函数中的x与main函数中的x的地址不一样，这也就说明了为什么+1不成立 当程序运行时，计算机会预留一部分内存给程序，他们被分为四个部分：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等）。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧 让一个函数调用另一个函数时，两个函数分别称为主调函数与被调函数，在主调函数中调用其他函数用到的参数称为实际参数，被调函数中的函数称为形式参数，实参会被映射到形参。这个操作即传值 当main函数调用f函数时，一块它的栈帧会被创建，其中的参数会被分配到对应空间，执行+1操作后，这个函数的栈帧中的变量执行了+1，但不影响其他地方的变量。 当f函数执行完毕，程序回到main函数，此时f的栈帧会被清除，main函数会被继续执行，故局部变量的生命周期只是函数执行期间。 接下来进行的函数是printf函数，这是一个库函数，在栈中创建它的栈帧并指型。这一个结构被称为(函数)调用栈，即：是将一个个函数的栈帧，按照调用的顺序依次压入栈中，等最上层的函数执行完了，就弹出相应的栈帧的过程 注意：栈是有大小的，如果因为无限递归等原因导致栈帧一直被创建而不清除，程序会因为栈溢出而终止 那传引用能否实现？ 1234567891011#include &lt;stdio.h&gt; void f(int *p){ *p = (*p)+1; } int main(){ int a; a = 10; f(&amp;a); printf(\"a = %d\", a); return 0; } 该函数传的是地址 当调用main函数，它的栈帧被创建，a=10进入栈。 调用f函数，它的栈帧被创建，则p接收到a的地址，入栈，此时p指向a。 在函数中解引用p，并执行操作，p指向的内存(a)的值就会增加，即a的值增加1 回到main函数，a的值就是11 这就是传引用，它可以节省很多内存空间，也可以处理一些复杂数据类型以节省内存 指针与数组 让我们声明一个数组 int a[5] 即我们创建了五个整型变量，在内存中连续存在(int 占四个字节)，则整个数组占的大小为20bytes，作为一个连续的块 我们定义一个指针int* p，将p指向a的第一个元素，则p解引用后打印的是a[0]的值 回忆之前说的指针算术，若我们将p+1，则p会往前移动四个字节，**此时*(p+1)即a[0]后四个字节的值，即a[1]** 与之前不同，一个值它的地址+1后会移动到一个未知内容的地址，而数组a中+1后p指向的值是已知的 若直接将数组名赋值给p，则p默认接收到的是数组a首元素的地址，称为数组的基地址 若想获得数组某个值的地址，可以使用&amp;a[i]或者a+i 若想获得数组某个值，可以使用a[i]或者*(a+i) 注意：对数组名（常量 ）自加是非法的，可以定义一个指针指向数组名让该指针自加 实例代码： 1234567891011#include &lt;stdio.h&gt; int main(){ int a[]={2,4,5,8,1}; for (int i = 0;i&lt;5;i++){ printf(\"Address = %d\\n\",&amp;a[i]); printf(\"Address = %d\\n\",a+i); printf(\"Value = %d\\n\",a[i]); printf(\"Value = %d\\n\", *(a+i)); } } 指针用例—数组传参 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int suma(int a[],int size){ int sum = 0; for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int sumb(int a[]){ int sum = 0; int size = sizeof(a)/sizeof(a[0]); printf(\"In sumb - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int main(){ int a[]={1,2,3,4,5}; // 计算数组大小 printf(\"In main - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); int size = sizeof(a)/sizeof(a[0]); // 传入数组大小后进行加和 int tot = suma(a,size); // 在函数中计算数组大小并加和 int tot2 = sumb(a); printf(\"tot = %d\\n\", tot); printf(\"tot2 = %d\\n\", tot2); } 以上代码会出现一些问题： 在调用main与sumb函数时，它们的栈帧会被创建 调用sumb函数时，编译器只会创建一个同名的指针在sumb的栈帧中，即它只指向main函数中数组a的首元素地址（即int a[]等同于int *a） 因此函数中的sizeof a是一个8字节的指针。 指针与字符数组 字符数组 C中的字符串存储在数组中，必须以’\\0’结束 字符数组赋值： 可以指定每一位进行赋值， 或者使用字符串字面值（用双引号括起来的字符串）赋值，该方法会隐式地添加一个’\\0’ 或者使用大括号初始化每一位，以逗号间隔并在结尾加上’\\0’ 注意：只能在声明同时用字符串字面值赋值 使用指针 字符数组中数组名代表的是数组首元素的地址，可以用一个指针变量指向它，该变量也可以对字符数组进行操作 12345678910#include &lt;stdio.h&gt; int main(){ char c1[6]=\"Hello\"; char *c2; c2 = c1; c2[0]='A'; // equal to c1[0]='A'; c2++; // 指向下一个元素 c1++; // 非法 } 有等价关系： c2[i]等同于*(c2+i) c1[i]等同于*(c1+i) 函数传参 12345678910111213141516171819#include&lt;stdio.h&gt; void print(char *c){ int i = 0; // while (c[i]!='\\0'){ // *(c+i)也可以 // printf(\"%c\",c[i]); // i++; // } // 由于c是指针，故可以通过自增与解引用来进行访问 while(*c!='\\0'){ printf(\"%c\",*c); c++; } printf(\"\\n\"); } int main(){ char c[20] = \"Hello\"; print(c); return 0; } 指针与二维数组 如果我们要创建一个二维数组b[2][3] 此时，b[0]与b[1]表示三个整数的一维数组，在内存中占用3*4=12个字节，是按行存储的 故int *p=b;指代的是返回一个指向一维数组的指针，此时不能指针运算或解引用，故不能这么用 故应使用int (*p)[3]来创建一个二维指针数组，其中3表示三个指向一维数组的指针 这时print b or &amp;b[0]都指代第一个元素的地址 ​ print *b or b[0] or &amp;b[0][0]都指代第一个元素地址的值 ​ print b+1 or &amp;b[1]会跳到下一个数组的首地址（+12） 使用print *(b+ 1)or b[i]or&amp;b[1][0]指代下一个指向一维数组的并返回 值 解引用时，需要一步步解 例 *(*b+1) *b 为b[0]，一个一维数组的首元素地址，*b+1会让指针移动四个字节带到下一个整型变量， 相当于&amp;b[0][1] 我们解引用后，*(*b+1)就相当于b[0][1] 指针运算：b[i][j]=*(b[i]+j)=*(*(b+i)+j) 指针与多维数组 原理 与二维数组类似 假如我们有一个int数组c[3][2][2]，在内存中的存储如下 简化为三个二维数组线性存储，每个二维数组内两个一维数组线性存储 故我们可以声明一个指针int (*p)[2][2] = c;，指向2*2的二维数组 这时print c，print *c，print c[0]，print &amp;c[0][0]均输出第一个一维数组的地址 指针运算：c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) 可以理解为解引用一次就脱一层[] e.g. print *(c[0][1]+1)指向的是c[0][1][1] print *(c[1]+1)指向的是c[1][1]，即c[1][1][0] 用于函数传参 如一维数组传参，我们可以通过传值或传引用两种方法传参 注意：传值时除了最高维度，其他维度必须要指定偏移量（即形参定义时必须和传入数组长度一样） 123456int two_dim(int a[][3]){ } int three_dim(int a[][2][2]){ } 而根据数组名就是指向第一个元素的指针，我们可以直接传引用来实现降维度 注意：只能降到次一级维度，且其余的必须指定偏移量 123456int two_dim(int (*a)[3]){ } int three_dim(int (*a)[2][2]){ } 指针与动态内存 内存的分配 在一个典型架构中，分配给应用程序的内存分为四个区段：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等），函数调用信息。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 栈 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧，大小在编译期间决定 所有函数从下往上开辟栈帧后，在执行时总是栈顶的函数在执行，其余函数暂停，等待上方函数返回值等。当上方函数返回后，它占用栈的内存也会被清除，下一个函数运行。任何时候正在执行的函数都是栈顶的那个函数 预留给栈的空间在运行期间并不会增长，也不能请求更多内存。如果运行时的栈增长超过了程序预留的栈内存大小，那么会造成栈溢出(stack overflow) 因此栈有两个限制： 在栈上的变量无法操作骑作用域 当声明一个很大的数据类型，可能会造成溢出；且只能在编译时分配他的大小，无法在程序运行时分配它的大小 堆(动态内存) 这时我们需要用到堆来分配或销毁或内存。我们可以任意使用堆上的内存，只要不超过系统内存限制。 堆又称为动态内存，使用堆内存称为动态内存分配 (注意这里的堆并不是数据结构) C风格： 12345678910111213#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; // 分配到栈上 int *p; // 指向堆内存的指针 p = (int*)malloc(sizeof(int)); // 在堆上开辟一块四字节的内存，让指针p指向其地址 *p=10; // 解引用将值存入堆 free(p); // 释放内存 p = (int*)malloc(20*sizeof(int)); // 在堆上再开辟一块20个四字节的内存作为数组，让指针p指向其首元素地址 // 可以用以下两种方式访问 p[0] = 1; *(p+1) = 2; } 定义一个指针变量p，它被存储在栈中，指向堆中分配的内存地址 通过malloc在堆上分配一块四字节的内存，malloc会返回一个指向这块内存起始地址的指针，void类型。故我们需要进行一个强制类型转换，并赋给指针变量p 使用堆上内存的唯一方式是通过引用，自己维护一个指针指向这块内存。我们通过对指针变量p解引用并赋值来使用。 若我们再以同样方式分配一块四字节内存，让p指向它，并赋值为20，p此时指向的便是堆中的另一块内存。而之前那块内存仍在堆上，并不会被自动回收，此时称为内存泄漏，因此我们需要在用完一块内存后，及时调用free()释放内存。 如果要分配一个数组内存，我们只需要传入数组大小字节数即可，返回的是内存的初始地址 若malloc无法在堆上成功分配内存，会返回NULL C++风格： 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; int *p; // 指向堆内存的指针 p = new int; // 在堆上开辟一块int大小的内存(四字节) *p = 10; // 解引用并赋值 delete p; // 释放内存 p = new int[20]; // 在堆上开辟一个20大小的int数组 delete[] p; // 释放数组内存 } c++中使用关键字new与delete开辟与释放内存，不需要类型转换 相关函数 malloc 定义：void* malloc(size_t size)(size_t相当于无符号整数) 用法：int *p = (int*)malloc(分配空间大小) 分配空间大小一般习惯通过sizeof计算，如想要开辟一个存储三个int变量的数组，我们可以用3*sizeof(int)来计算大小，一般不直接写。 由于malloc返回的是void指针，指向其初始地址，而void指针无法解引用，因此我们一般在前面进行强制类型转换来转化成int指针以方便操作 malloc不会将分配的空间初始化，建议使用memset(p,0x00,sizeof(p))初始化 calloc 定义：void* calloc(size_t num, size_t size) 用法：int *p = (int*)calloc(分配元素个数, 每个元素空间大小) calloc可以指定分配的元素个数 calloc在分配空间后会自动将其初始化为0 realloc 定义：void* realloc(void* ptr, size_t size) 用法：realloc(已指向某处内存的指针, 修改空间大小) realloc用于修改分配的内存大小 若需要的新内存块比原来大，程序会创建一块新内存并将内容复制过去 若之前的内存的相邻部分还有可用内存，程序会直接拓展原空间 若需要的新内存块比原来小，则多余部分的内存会被释放掉 注意以下用法： 12int *a = (int*)realloc(a,0); // 相当于free(a) int *b = (int*)realloc(NULL,n*sizeof(int)); // 相当于malloc 内存泄漏 当我们动态申请了内存后，忘记去释放，此时程序占用了一些未使用的内存，称为内存泄露 对于栈：由于栈帧在使用完后会被自动销毁，故不会发生内存泄漏 对于堆：在开辟空间后，堆上的内存必须要被显式地释放掉，否则会一直存在 注意：任何未使用和未引用的堆上内存都是垃圾，程序员要确保不要浪费内存 函数返回指针 我们可以在函数类型处加上*来声明函数返回值是一个指针。 注意以下情况： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int c = (*a)+(*b); return &amp;c; } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 该程序对print的输出正常，而输出sum时出现了异常，从底层原理分析： 执行main函数，开辟栈帧，执行add函数，在main函数上再开辟栈帧，main函数会等待add返回 此时add中a与b存储了main函数中x与y的地址，c存储了*a与*b的和，返回的是c的地址，故main函数中的p指针存储的是c的地址 add执行完毕，占用空间被清除。但注意，此时p指向的内存仍未变化，即此时它指向了被释放掉的内存空间，值是随机的 现在执行print函数，开辟栈帧，原空间被覆盖，因此p存储的地址对应的值已经不是c的值了，因此输出异常。 还有一种情况：若不执行print函数，输出的值可能会正确。因为此时程序还没重写或清除那个空间上的数据（虽然已经释放空间） 而对于main与add函数，由于被调函数的栈空间总是在主调函数之上，因此被调函数执行时主调函数仍在栈内存中，因此add可以访问main函数中的变量。但若我们想要返回被调函数的一个局部变量给主调函数，当被调函数结束后，内存已被释放，因此会出问题。 因此可以从栈底向上传局部变量或局部变量的地址，但不能从栈顶向下传局部变量或局部变量的地址 因此我们可以修改： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int *c = (int*)malloc(sizeof(int)); // 在堆上开辟内存 *c = (*a)+(*b); return c; // 返回的是堆上的指针 } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 我们将c开辟在堆上，此时就不会被清除了，返回c是安全的 函数指针 我们可以用指针指向函数地址，即指向函数的指针。我们可以用这种指针解引用和调用函数。 函数的地址 在内存中，一个函数就是一块连续的内存。 一般程序执行指令会按照地址依次执行，而函数调用可以让程序跳到某一个地址开始执行其中的指令。 此时对应的函数地址可以称为函数的入口点，即函数第一条指令的地址 函数指针的使用 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(char *name){ printf(\"hello\"); } int add(int a, int b){ return a+b; } int main(){ int c; int (*p)(int,int); // 函数指针 p = &amp;add; // 指针指向add函数的地址(不用&amp;也可) c = (*p)(2,3); // 解引用，并传入参数执行函数(不用解引用也行) printf(\"%d\\n\",c); void (*ptr)(char*); ptr = print; // 不用&amp;的情况 ptr(\"mixbp\"); // 不用解引用的情况 } 由于单纯的函数名代表函数入口点，故不用&amp;与解引用也可以 注意：为了指向一个函数，函数指针的类型必须是正确的 回调函数 将函数指针作为函数参数传入，并在函数内部通过该函数指针调用函数，被调用的函数即为回调函数 123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(){ printf(\"hello\"); } void b(void (*ptr)()){ ptr(); // 用ptr回调传进来的函数 } int main(){ void (*p)() = print; // 定义一个指针指向print b(p); // 传入该函数指针 b(print); // 这样也可以传 } 代码中，函数b可以通过函数指针来回调函数print 可以定义一个指向print函数的指针传入，也可以直接传入print，此时指代的是print函数的首地址 应用：排序 设计一个排序函数，并可以按照不同逻辑进行排序 我们可以在普通排序函数中添加一个函数指针参数(比较函数)，通过设计蚂蚁比较逻辑并传入排序函数，可以灵活实现不同情景的比较，而不用每次都根据不同逻辑重新写一遍排序函数 如实现正序、逆序、按绝对值排序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;math.h&gt; int compare(int a,int b){ if (a&gt;b) return 1; else return -1; } int r_compare(int a, int b){ if (a&gt;b) return -1; else return 1; } int abs_compare(int a, int b){ if (abs(a)&gt;abs(b)) return 1; else return -1; } void sort(int *a, int n, int (*cmp)(int,int)){ int tep; for (int i = 0;i&lt;n;i++){ for (int j = 0;j&lt;n-1;j++){ if (cmp(a[j],a[j+1])&gt;0){ tep = a[j]; a[j] = a[j+1]; a[j+1]=tep; } } } } int main(){ int a[]={3,2,1,5,6,4}; int b[]={-2,-3,5,4,1,-6}; sort(a,6,compare); // 正序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(a,6,r_compare); // 逆序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(b,6,abs_compare); // 绝对值排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",b[i]); printf(\"\\n\"); } 同样的逻辑，在c的stdlib.h库中有一个qsort函数，只要给予它排序逻辑并传入就可以对任意数组排序","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"【算法】快速幂","slug":"快速幂","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-17T07:01:52.295Z","comments":true,"path":"2024/12/20/快速幂/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 问题引入 如何计算 朴素算法：让n个a相乘，时间复杂度为，当n特别大的时候，耗时特别长 而快速幂算法可以大大减少时间复杂度 n的分类 n为2的幂次时 如 我们可以用上一次的结果当作下一次的乘数： 快速幂原理 这样只需要进行六次乘法就可以得出结果，时间复杂度为 即使用了倍增原理，将每次a的数量翻倍 n不为2的幂次时 我们可以将不是2的幂的数写成若干个2的幂的数的和，如 可以改写为，再根据以上方法计算 如何将n分解为2的幂次之和？ 答案是位运算 让我们看看这几个数的二进制表示形式 二进制表示分解n的原理 会发现，目标数n的二进制中的1的个数与位置正好对应它分解后的数字 伪代码 12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r 逻辑 行3，7：每次除二，让二进制位从右到左减少一位，相当于右移一位 行6：每次让翻倍（,,,,…） 行2，4，5，8：如果mod2==1，代表该位是1，则将该位代表的与结果相乘，即让幂次相加 位运算改进 n mod 2==1等同于n&amp;1，n/2等同于n&gt;&gt;1 时间复杂度 ，循环次数为n的二进制位数，对于整数n，它的二进制位数为 板子 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } 应用1：幂取模 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } 注： 应用2：斐波那契数列 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } 用矩阵形式表示斐波那契数列，如下图 斐波那契矩阵表示 我们可以发现它可以分为n个矩阵相乘 再乘列向量F1 F0","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数学】逆元","slug":"逆元","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/逆元/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"逆元 前置知识 单位元 在一个集合中，对于某种运算，如果对于任何的集合元素 a，和元素 e 运算，得到还是集合元素 a 本身，则称 e 为这个运算下的单位元。 在加法运算中，对于任意实数，有，则单位元 (可以认作相反数) 在乘法运算中，对于任意实数，有，则单位元 (可以认作倒数) 模乘的单位元是 (证明自己搜) 逆元 在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 模意义下的乘法逆元 若 且(a与p互质)，则称a关于模p的乘法逆元为x 逆元即数论中的广义倒数。 费马小定理 若p为质数，则，则 或对于任意整数a，有 欧拉函数 ，表示小于等于n的正整数中和n互质的数的个数，如 当n是质数时，有 欧拉函数是积性函数，即对任意满足的整数a,b，有 特别地，当n是奇数时 求一个数的欧拉函数值：在质因数分解的同时求解即可 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } 欧拉定理 若，则 则对于费马小定理，有更一般的结论： 应用 求除法的模运算时，经常会因为精度或溢出问题而导致结果产生误差。 故我们可以将求转化为的逆元 将除法转为乘法，精度问题便就解决了 扩展欧几里得定理求逆元 给定正整数a，b，求满足的x的最小正整数解，若无解返回-1 结论 当a与b不互质时，逆元必定不存在 当a与b互质时，有 对应系数可得： 若改为求满足 的最小正整数解，经过变形 原式可以由变为，则和上方一致 模板 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } 费马小定理 给定素数p和正整数a，求满足的最小正整数x，若不存在返回-1 此时模数固定为素数，故直接可以用费马小定理求解 当a为p的倍数时，，所以一定不存在，返回-1 根据费马小定理有，又 则，逆元x满足 代码 12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } 线性求逆元 对于求一连串数字模p的逆元，上两种方法容易超时，用这种方法更快一些 结论 (证明见oi-wiki) 有递推式 代码 123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } 线性求任意逆元 首先我们求出n个数的前缀积，这时我们可以用exgcd或费马小定理求出的乘法逆元 又因为，，故我们可以将，就会和其逆元抵消，以求出 求出所有前缀积的逆元后，我们可以让前缀积的逆元乘i-1的前缀积来消除其他逆元，以得到的逆元，即 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // 也可以用exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【数据结构】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-25T07:36:57.832Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set) 概念 不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1 如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率 查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素， 123find1(x){ return set[x]; } 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素， 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } 实现2 每个集合用一颗有根树表示 定义一个数组set 若set[i]=i, 则i为该树的根节点，i代表本集合 若set[i]=j, 若ji, 则j是i的父节点 效率 查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏，一般 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } 并：只需要将根节点改为另一个集合的根节点即可， 123merge2(a,b){ set[a]=b; } 改进 如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } 此时查找操作的时间复杂度变成了 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 路径压缩示意 代码 1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; } 模板 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 ,表示共有 个元素和 个操作。 接下来 行，每行包含三个整数 。 当 时，将 与 所在的集合合并。 当 时，输出 与 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1234N Y N Y 提示 对于 的数据，，。 对于 的数据，，。 对于 的数据，，，，。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // 并查集 // 查找操作，使用路径压缩 int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // 初始化每一位的根节点是他自己 for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // 进行合并 if (z==1){ merge(x,y); } else { // 如果两者的根节点相同，则属于同一集合 if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-17T07:00:58.279Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 这是一个测试帖子 三级标题 四级标题 五级标题 测试代码 123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ ### じや……一生 ACMしてくれる?","categories":[{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"},{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://izayoisakuye.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"https://izayoisakuye.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"},{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}