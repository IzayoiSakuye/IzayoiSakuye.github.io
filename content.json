{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【算法】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2024-12-13T03:19:01.116Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set)概念不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素，$O(1)$ find1(x)&#123; return set[x]; &#125; 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素，$O(n)$ merge1(a,b)&#123; i &#x3D; min(a,b); j &#x3D; max(a,b); for (int k&#x3D;1;k&lt;&#x3D;n;k++)&#123; if (set[k]&#x3D;&#x3D;j) set[k]&#x3D;&#x3D;i; &#125; &#125; 实现2每个集合用一颗有根树表示 定义一个数组set 若set[i]&#x3D;i, 则i为该树的根节点，i代表本集合 若set[i]&#x3D;j, 若j$\\neq$i, 则j是i的父节点 效率查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏$O(n)$，一般$O(\\log n)$ find2(x)&#123; r &#x3D; x; while(set[r]!&#x3D;r)&#123; r &#x3D; set[r]; &#125; return r; &#125; 并：只需要将根节点改为另一个集合的根节点即可，$O(1)$ merge2(a,b)&#123; set[a]&#x3D;b; &#125; 改进如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过$\\lfloor \\lg k \\rfloor$ 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 merge3(a,b)&#123; if (height(a)&#x3D;&#x3D;height(b))&#123; height(a)&#x3D;height(a)+1; set[b]&#x3D;a; &#125; else if (height(a)&lt;height(b)) set[a]&#x3D;b; else set[b]&#x3D;a; &#125; 此时查找操作的时间复杂度变成了$O(\\log n)$ 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 代码find3(x)&#123; if (set[x]!&#x3D;x) set[x]&#x3D;find3(set[x]); &#x2F;&#x2F;当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; &#125; 模板 题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。 接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。 当 $Z_i&#x3D;1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。 当 $Z_i&#x3D;2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式对于每一个 $Z_i&#x3D;2$ 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1样例输入 #14 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1N Y N Y 提示对于 $30%$ 的数据，$N \\le 10$，$M \\le 20$。 对于 $70%$ 的数据，$N \\le 100$，$M \\le 10^3$。 对于 $100%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in { 1, 2 }$。 #include &lt;iostream&gt; using namespace std; const int N &#x3D; 1e4+10; int n,m; int disj[N]; &#x2F;&#x2F; 并查集 &#x2F;&#x2F; 查找操作，使用路径压缩 int find(int x)&#123; if(disj[x]!&#x3D;x) disj[x]&#x3D;find(disj[x]); return disj[x]; &#125; &#x2F;&#x2F; 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b)&#123; if(find(a)&gt;find(b))disj[find(a)]&#x3D;find(b); else disj[find(b)]&#x3D;find(a); &#125; int main()&#123; cin &gt;&gt; n &gt;&gt;m; &#x2F;&#x2F; 初始化每一位的根节点是他自己 for(int i &#x3D; 1;i&lt;&#x3D;n;i++) disj[i]&#x3D;i; while(m--)&#123; int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; &#x2F;&#x2F; 进行合并 if (z&#x3D;&#x3D;1)&#123; merge(x,y); &#125; else &#123; &#x2F;&#x2F; 如果两者的根节点相同，则属于同一集合 if(find(x)&#x3D;&#x3D;find(y)) cout &lt;&lt; &quot;Y&quot;&lt;&lt;endl; else cout &lt;&lt; &quot;N&quot;&lt;&lt;endl; &#125; &#125; return 0; &#125;","categories":[],"tags":[]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2024-12-04T10:23:21.632Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"这是一个测试帖子三级标题四级标题五级标题测试代码 123456#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello world!&quot;; return 0;&#125; 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ じや……一生 ACMしてくれる?","categories":[],"tags":[]}],"categories":[],"tags":[]}