{"meta":{"title":"红魔咖啡馆","subtitle":"随手记录学习点滴","description":"","author":"IzayoiSakuye","url":"https://izayoisakuye.github.io","root":"/"},"pages":[],"posts":[{"title":"【数据结构】栈","slug":"栈","date":"2025-03-21T14:21:59.923Z","updated":"2025-03-21T14:22:16.434Z","comments":true,"path":"2025/03/21/栈/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E6%A0%88/","excerpt":"","text":"栈 特点 仅可在表尾操作 表尾称为栈顶(top)，表头称为栈底 不含元素的空表为空栈 栈遵循后进先出（LIFO）的原则 基本操作包括push，pop 顺序表实现 初始化 123456789typedef struct{ ElemType data[MAXSIZE]; int top; }Stack; // 栈的初始化 void initStack(Stack *s){ s-&gt;top = -1; // 表示空栈 } 判断空栈 123456789int isEmpty(Stack *s){ if (s-&gt;top==-1){ printf(\"Empty\"); return 1; } else { return 0; } } 压栈 12345678910// 压栈 int push(Stack *s, ElemType e){ if (s-&gt;top&gt;=MAXSIZE-1){ printf(\"Full\"); return 0; } s-&gt;top++; // 栈顶上移一位 s-&gt;data[s-&gt;top]= e; // 压入数据 return 1; } 出栈 12345678910// 出栈 int pop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; // 弹出栈顶元素 s-&gt;top--; // 栈顶下移一位 return 1; } 获取栈顶元素 123456789// 获取栈顶元素 int getTop(Stack *s, ElemType *e){ if (s-&gt;top==-1){ printf(\"Empty\"); return 0; } *e = s-&gt;data[s-&gt;top]; return 1; } 动态分配内存 123456789101112typedef struct{ ElemType *data; int top; }Stack; // 栈的初始化 Stack* initStack(){; Stack *s = (Stack*)malloc(sizeof(Stack)); s-&gt;data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); s-&gt;top = -1; // 表示空栈 return s; } 链表实现 使用单向链表来实现栈 尾节点为栈底，首节点为栈顶 压栈：链表头插法 出栈：删除头节点后的首节点 判空：只有头节点（head-&gt;next == NULL） 获取栈顶数据：找头节点的next的data（head-&gt;next-&gt;data） 初始化 12345typedef int ElemType; typedef struct stack{ ElemType data; struct stack *next; }Stack; 判空 12345678910// 判空 int isEmpty(Stack *s){ if (s-&gt;next == NULL){ // 头节点的next指向NULL printf(\"Empty\"); return 1; } else { return 0; } } 压栈 123456789// 压栈 int push(Stack *s, ElemType e){ Stack* p = (Stack*)malloc(sizeof(Stack)); p-&gt;data = e; p-&gt;next = s-&gt;next; s-&gt;next = p; return 1; } 出栈 123456789101112// 出栈 int pop(Stack *s, ElemType *e){ if (s-&gt;next==NULL){ printf(\"Empty\"); return 0; } Stack *q = s-&gt;next; *e = q-&gt;data; s-&gt;next = q-&gt;next; free(q); return 1; } 获取栈顶元素 123456789// 获取栈顶元素 int getTop(Stack *s,ElemType *e){ if (s-&gt;next == NULL){ printf(\"Empty\"); return 0; } *e = s-&gt;next-&gt;data; return 1; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"【数据结构】表","slug":"表","date":"2025-03-21T14:21:27.493Z","updated":"2025-03-21T14:21:50.714Z","comments":true,"path":"2025/03/21/表/","permalink":"https://izayoisakuye.github.io/2025/03/21/%E8%A1%A8/","excerpt":"","text":"表 线性表 n个数据类型相同的元素构成的有限序列 空表：大小为0的表 首节点：存在唯一一个被称为第一个的元素 尾节点：存在唯一一个被称为最后一个的元素 前驱：前驱 后继：后继 对于除了首尾节点的元素，它只会有一个前驱、一个后继 顺序表实现 顺序表：一组连续内存单元存储线性表的各个元素 对于静态表，main函数调用时，应传入列表的地址(&amp;) 建表 123456789#define MAXSIZE 100 typedef int ElemType; // 方便存储不同类型数据的情况下修改数据类型 // 建表 typedef struct SeqList { ElemType data[MAXSIZE]; int length; // 顺序表数据个数 }; 初始化 1234// 初始化 void initList(SeqList *L){ L-&gt;length = 0; } 尾插元素 12345678910// 尾插元素 int appendElem(SeqList *L, ElemType e){ if (L-&gt;length&gt;=MAXSIZE){ // 判满 printf(\"已满\\n\"); return 0; } L-&gt;data[L-&gt;length] = e; // 在末尾添加元素 L-&gt;length++; // 将顺序表长度加一 return 1; } 插入元素 123456789101112131415161718// 插入元素 int insertElem(SeqList *L, ElemType e, int pos){ if (L-&gt;length&gt;=MAXSIZE){ // 判满 printf(\"已满\\n\"); return 0; } if (pos&lt;1 || pos&gt; L-&gt;length){ printf(\"位置错误\\n\"); return 0; } for (int i = L-&gt;length-1; i&gt;=pos-1;i--){ // 倒序让插入元素后面的元素后移一位 L-&gt;data[i+1] = L-&gt;data[i]; // 向后移动元素 } L-&gt;data[pos-1] = e; // 插入元素 L-&gt;length++; // 将顺序表长度加一 return 1; } 最坏时间复杂度 需要将插入位置后的元素都后移一位 遍历列表 1234567// 遍历元素 void listElem(SeqList *L){ for (int i = 0; i &lt; L-&gt;length; i++){ printf(\"%d \", L-&gt;data[i]); } printf(\"\\n\"); } 删除元素 1234567891011// 删除元素并返回删除的元素 int delElem(SeqList *L, int pos, ElemType *e){ *e = L-&gt;data[pos-1]; // 取出删除元素 if (pos &lt; L-&gt;length){ for (int i = pos; i&lt;L-&gt;length; i++){ L-&gt;data[i-1] = L-&gt;data[i]; // 从pos开始向后，将后面一位覆盖到前一位实现删除 } } L-&gt;length--; // 表长度减一，这样最后一个元素不用覆盖也可以 return 1; } 该删除可以返回删除掉的元素，用e变量存储 查找元素 123456789// 查找元素 int findElem(SeqList *L, ElemType e){ for (int i = 0; i&lt;L-&gt;length; i++){ if (e==L-&gt;data[i]){ // 找到元素 return i+1; // 返回位置 } } return -1; // 找不到返回-1 } 使用动态顺序表实现 通过malloc函数在堆中动态分配内存建表 不同的地方只是在建表与初始化上 12345678910111213// 建表 typedef struct { ElemType *data; int length; }SeqList; // 初始化 分配内存 SeqList* initList(){ SeqList *L = (SeqList*)malloc(sizeof(SeqList)); L -&gt; data = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); L -&gt; length = 0; return L; } 此时在main函数建表时只需要调用initList函数初始化并将返回的结构体指针存入一个对应变量即可 由于此时获得的直接是地址，故对应操作时便不需要取地址了 链表实现 链表存储的特点是用一组任意的存储单元存储数据（可连续可不连续） 对每一个存储单元，除了要存储当前数据，还需要存储一个指示其直接后继的信息（地址），这两部分信息组成了一个节点，n个节点链接成了一个链表，即为线性表 节点包括两个域： 数据域：存储数据元素信息 指针域：存储直接后继存储位置 单链表 next中存储了下一个节点的地址，其中尾节点中的next指向NULL，表示到达链表尾部 初始化 123456789101112// 单链表初始化-建立头节点 Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // 分配一个节点大小的空间 head-&gt;data = 0; // 数据设为0 head-&gt;next = NULL; // 下一个地址设为NULL return head; } int main(){ Node* test = initList(); return 0; } 建立一个头节点，作为线性表的开始，其数据为0，地址默认为NULL 创建链表时，只需要调用initList函数并将返回的结构体指针赋给对应变量即可 头插元素 头插元素实现了在头节点后插入数据 先让新节点的next指向原头节点指向的下一个节点 再让头节点指向的节点更改为新的节点 顺序很重要 123456int insertHead(Node* L, ElemType e){ Node *p = (Node*)malloc(sizeof(Node)); // 分配存储数据的节点的空间 p-&gt;data = e; // 将插入元素赋值给该节点 p-&gt;next = L-&gt;next; // 将该节点的next指向原头节点指向的节点 L-&gt;next = p; // 将原头节点的next指向该新节点 } 尾插元素 头插元素实现了在尾节点后插入数据，我们需要先寻找尾节点 找到某节点的next==NULL时便找到了尾节点 12345678// 获得尾节点地址 Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // 当节点不为空时 p = p-&gt;next; // 顺着寻找下一个节点 } return p; } 先让先前的尾节点指向新节点 再让新节点指向NULL 12345678// 尾插法插入元素 Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; tail-&gt;next = p; p-&gt;next = NULL; return p; } 注意，尾插法每次返回尾节点，这样下次插入时就可以接着上一次的插入了，不需要再get 指定位置插入元素 首先要找到待插入位置的前一个元素，然后让新节点指向该元素的下一个元素 然后让前一个节点指向新节点的位置 1234567891011121314151617// 指定位置插入元素 int insertNode(Node* L, int pos, ElemType e){ Node* p = L; // 让指针指向需要插入位置的前驱节点 for(int i = 0; i&lt;pos-1;i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); // 要插入的新节点 q-&gt;data = e; // 输入数据 q-&gt;next = p-&gt;next; // 新节点下一个位置赋值为前驱节点指向的后一个节点 p-&gt;next = q; // 前驱节点指向插入的新节点 return 1; } 删除节点 找到删除节点的前驱节点p 用指针q指向要删除的节点 通过改变p的后继节点实现删除 并释放删除节点的空间 1234567891011121314151617181920// 删除节点 int delNode(Node* L, int pos){ Node* p = L; // 让指针指向需要删除位置的前驱节点 for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p == NULL) { return 0; } } if (p-&gt;next == NULL){ printf(\"位置错误\\n\"); } Node* q = p-&gt;next; // q指向要删除的节点 p-&gt;next = q-&gt;next; // 要删除节点的前驱节点指向其后继节点 free(q); return 1; } 获取链表长度 12345678910// 获取链表长度 int listLength(Node* L){ Node* p = L; int cnt = 0; while(p!=NULL){ p = p-&gt;next; cnt++; } return cnt; } 释放链表 把头结点后的节点都释放掉 让指针p指向头节点后的第一个节点 若p不为NULL，让q指向p的后继节点，并释放p指向的节点 让p, q指向同一个节点，循环以上操作 12345678910111213// 释放链表 void freeList(Node* L){ Node* p = L-&gt;next; // p指针指向头节点后的第一个节点 Node* q; while(p!=NULL){ // 判断p指向是否是空节点 q = p-&gt;next; // q指向p的后继 free(p); // 释放p p = q; // p指向其后继（q指向的节点） } L-&gt;next = NULL; //释放后原链表头节点指向NULL } 注意 时间复杂度：读取数据–顺序表&gt;链表 修改数据–链表&gt;顺序表 不要忘记初始化指针变量，防止其变为野指针 何时使用malloc？ 声明指向一个结构的指针不会创建该结构，而是给出足够空间容纳结构可能会使用的地址 使用malloc可以使系统创建一个新的结构并返回指向该结构的指针 故若想使用指针变量沿着一个表行进，就没必要创建新的结构，不宜使用malloc free的结果：指针指向的地址没变，但该位置处的数据已经无定义了（野指针） 若未对链表进行过删除操作，则调用malloc的次数应该等于表的大小，含表头再+1 单项循环链表 特点：表中最后一个节点的指针域指向头节点，形成一个环 终止条件：p!=L或p-&gt;next!=L 判断是否有环 快慢指针 让快指针一次走两步，慢指针一次走一步 当遇不到NULL时，若有环，则两者会一直追赶，根据概率一定会有一个时候相遇 若能相遇则说明有环，否则若碰到NULL证明没有环 注意特判只有一个元素或没有元素时，不然当前节点的指针域会赋值给空指针而报RE 1234567891011121314class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return false; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow) return true; } return false; } }; 找到环的入口 设起点到入口距离为，入口到相遇距离为，相遇再到入口距离为，则快慢指针走的路程如下： 其中n为圈数，由于快指针的速度为慢指针的两倍，故慢指针一定会在一圈内与快指针相遇 有 化简得$ = n(y+z)-y，由于快指针先入环，且速度快于慢指针，故快指针至少转一圈才能与慢指针相遇，即n$至少为1 多拿出一圈来将y约掉，则 当时，即快指针转一圈与慢指针相遇的情况下，，即两者会在环的入口处相遇 当时，由于是一整圈的路程，即走完若干圈后快指针还会再走距离，最后与慢指针在环的入口处相遇 故我们可以在相遇位置设置一个指针，在起始位置设置一个指针，两者相遇处即为入口 12345678910111213141516171819202122232425262728struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; class Solution { public: ListNode* detectCycle(ListNode *head) { int cnt[10005]; ListNode* fast = head; ListNode* slow = head; if (fast==nullptr||fast-&gt;next==nullptr) return nullptr; while(fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast==slow){ ListNode* index1 = fast; ListNode* index2 = head; while(index1!=index2){ index1 = index1-&gt;next; index2 = index2-&gt;next; } return index1; } } return nullptr; } }; 双向链表 特点：双向链表的节点中有两个指针域：一个指向直接后继，另一个指向直接前驱 建表 12345typedef int ElemType; typedef struct node{ ElemType data; struct node *prev, *next; }Node; 初始化 与单链表相同 1234567// 初始化建立头节点 Node* initList(){ Node *head = (Node*)malloc(sizeof(Node)); // 分配一个节点大小的空间 head-&gt;data = 0; // 数据设为0 head-&gt;next = NULL; // 下一个地址设为NULL return head; } 头插法 让新节点的prev指向头节点 让新节点的next指向头节点的next 让头节点的next节点的prev指向新节点，让头节点的next指向新节点 123456789101112// 头插法 int insertHead(Node* L, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = L; // 新节点的prev指向头节点 p-&gt;next = L-&gt;next; // 新节点的next指向头节点后的第一个节点 if (L-&gt;next!=NULL){ // 保证并非只有一个头节点 L-&gt;next-&gt;prev = p; // 新节点的next节点的prev指向新节点 } L-&gt;next = p; // 头节点的next节点指向新节点 return 1; } 尾插法 让新节点的prev指向尾节点 让尾节点的next指向新节点 将NULL值赋给新节点的next 123456789101112131415161718// 获得尾节点地址 Node* get_tail(Node* L){ Node *p = L; while(p-&gt;next!=NULL){ // 当节点不为空时 p = p-&gt;next; // 顺着寻找下一个节点 } return p; } // 尾插法 Node* insertTail(Node* tail, ElemType e){ Node* p = (Node*)malloc(sizeof(Node)); p-&gt;data = e; p-&gt;prev = tail; tail-&gt;next = p; p-&gt;next = NULL; return p; } 指定位置插入 寻找前置节点，让新节点prev指向前置节点 让新节点的next指向后置节点 让前置节点的next的prev指向新节点 前置节点的next指向新节点 1234567891011121314151617// 指定位置插入数据 int insertNode(Node* L, int pos, ElemType e){ Node* p = L; for (int i = 0; i&lt;pos-1; i++){ p = p-&gt;next; if (p==NULL){ return 0; } } Node* q = (Node*)malloc(sizeof(Node)); q-&gt;data = e; q-&gt;prev = p; q-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = q; p-&gt;next = q; return 1; } 删除元素 找到要删除节点的前驱节点，用指针记录要删除的节点 改变p的后继节点以及删除节点的后继节点的前驱来删除节点 12345678910111213141516171819// 删除元素 int delNode(Node* L, int pos){ Node *p = L; for (int i = 0;i&lt;pos-1;i++){ // 找到前驱节点 p = p-&gt;next; if (p==NULL){ return 0; } } if (p-&gt;next==NULL){ // 判断删除位置是否超出了表长度 printf(\"要删除的位置错误\"); return 0; } Node* q = p-&gt;next; // q指向要删除的节点 p-&gt;next = q-&gt;next; // p的next指向q的后继节点 q-&gt;next-&gt;prev = p; // q的后继节点的prev指向p free(q); // 删除q return 1; } 顺序表与链表","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"}]},{"title":"【计算机网络】Web应用的请求与响应机制","slug":"Web应用的请求与响应机制","date":"2025-03-21T14:20:01.860Z","updated":"2025-03-21T14:26:06.491Z","comments":true,"path":"2025/03/21/Web应用的请求与响应机制/","permalink":"https://izayoisakuye.github.io/2025/03/21/Web%E5%BA%94%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Web应用的请求与响应机制 HTTP协议 HTTP是web通信的基础协议，是客户端与服务器进行交互的标准，所有www文件必须遵守这个标准，其端口号为80 HTTPS是HTTP的安全版，在HTTP下加入SSL层 SSL是主要用于web的安全传输协议，在传输层对网络连接进行加密，其端口号为443 工作原理 HTTP通信由两部分组成：客户端请求信息、服务器响应信息 - 当用户在地址栏输入一个URL并回车后，客户端向web服务器发送HTTP请求，建立一个到服务器指定端口的TCP连接 - 服务器在那个端口监听客户端发送过来的请求，收到请求后，服务器根据内容与类型进行处理，并生成HTTP响应，包括一个状态行与相应的信息 - 客户端接受服务器返回的响应，并根据内容呈现给用户 URL 统一资源定位符（Uniform / Universal Resource Locator），是用于完整描述网页和其他资源的地址的一种标识方法 基本格式： scheme://host[:port#]/path/…/[?query-string][#anchor] - scheme：协议（如http与https） - host：服务器ip地址或域名 - port：服务器端口（如果走协议默认端口，缺省端口80） - path：访问资源的路径 - query-string：参数，发送给http服务器的数据 - anchor：锚，跳转到网页的指定锚点位置 HTTP请求 HTTP用来提交和获取资源，客户端发送一个HTTP请求请求到服务器的请求信息，包括：请求行、请求头部、空行、请求数据四个部分，格式如下 HTTP请求 一些常用的请求报头： - Host：对应URL中的web名称与端口号，用于指定被请求资源的Internet主机与端口号 - Connection：表示客户端与服务器连接类型 Client 发起一个包含 Connection:keep-alive 的请求， HTTP/1.1 使用 keep-alive 为默认值。 Server 收到请求后：如果 Server 支持 keep-alive（长连接）， 回复一个包含 Connection:keep-alive 的响应， 不关闭连接；如果 Server 不支持 keep-alive， 回复一个包含 Connection:close 的响应， 关闭连接。如果 client 收到包含 Connection:keep-alive 的响应， 向同一个连接发送下一个请求， 直到一方主动关闭连接。 keep-alive 在很多情况下能够重用连接， 减少资源消耗， 缩短响应时间， 比如当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)， 不需要每次都去请求建立连接。 - Upgrade-Insecure-Requests：升级不安全的请求， 意思是会在加载 http 资源时自动替换成 https 请求， 让浏览器不再显示 https 页面中的 http 请求警报。 - User-Agent：客户浏览器的详细信息，服务器根据这条信息来判断来访用户是否为真实用户 - Accept：指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions）文件类型，服务器根据其判断并返回适当文件格式 - Accept: /： 表示什么都可以接收。 - Accept: text/html, application/xhtml+xml;q=0.9, image/;q=0.8： 表示浏览器支持的 MIME 类型分别是html文本、xhtml和xml文档、 所有的图像格式资源。 q是权重系数， 范围 ，q值越大，请求越倾向于获得其“;”之前的类型表示的内容。若没有指定 q 值， 则默认为1，按从左到右排序顺序；若被赋值为 0，则用于表示浏览器不接受此内容类型。 Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的； Application：用于传输应用程序数据或者二进制数据。 - Referer：表明产生请求的网页来自于哪个URL，用户是从该referer页面访问到当前请求的页面，可以用来跟踪web请求来自哪个页面，哪个网站 - Accept-Encoding：指出浏览器可以接受的编码方式。 编码方式不同于文件格式， 它是为了压缩文件并加速文件传递速度。 浏览器在接收到 Web 响应之后先解码， 然后再检查文件格式， 许多情形下这可以减少大量的下载时间。 如Accept-Encoding:gzip;q=1.0, identity; q=0.5, ;q=0 如果有多个 Encoding 同时匹配, 按照q值顺序排列，本例中按顺序支持 gzip, identity压缩编码， 支持gzip的浏览器会返回经过gzip编码的HTML页面。 如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 - Accept-Language：指语言可以接受的语言种类，如zh或zh-cn指中文 - Accept-Charset：指浏览器可以接受的字符编码，缺省为任何字符集 - Cookie：浏览器用这个属性向服务器发送 Cookie。 - Content-Type：POST请求里用来表示的内容类型。 示例： HTTP请求示例 常见HTTP方法 GET：请求指定资源，通常附加在URL中，不适合传递大量数据与隐私数据 POST：向服务器提交数据，通常用于提交表单与上传文件 PUT：更新指定资源内容 HEAD：只返回响应头，不返回响应体 OPTIONS：查询服务器支持的HTTP方法 HTTP响应 由四部分组成，分别为状态行、消息报头、空行、响应正文，格式如下： HTTP响应 理论上所有响应头信息都是回应请求头的，但还会添加对应的响应头信息 示例： HTTP响应示例 HTTP状态码 web服务器对HTTP请求的回应，表示请求是否成功处理 1xx：服务器成功接受部分请求 2xx：成功（200 OK） 3xx：重定向（301 Moved Permanently） 4xx：客户端错误（404 Not Found） 5xx：服务器错误（500 Internal Server Error） Cookie与Session： 服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的链接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息。 - Cookie：通过在 客户端 记录的信息确定用户的身份。 - Session：通过在 服务器端 记录的信息确定用户的身份 请求参数的获取与处理 HTTP携带多种数据，这里通过python，使用urllib与requests库来处理这些数据 处理URL路径与查询参数 ​ URL 查询参数是指在 URL 中通过键值对的形式传递的参数，用于在 URL 中增加额外的信息，如查询条件、排序方式、页码等。查询参数通常使用键值对的形式定义，键和值之间用 = 符号分隔，多个参数之间用 &amp; 符号分隔。例如，定义一个查询参数 page 的值为 2，可以写成 page=2 ​ 查询参数的主要用途是通过 URL 传递信息，实现搜索查询、过滤器等功能。例如，用户在输入框输入 abc，按下回车之后，会返回一条地址为 https://www.example.com/?keyword=abc 的 URL。在用户访问时，服务器会通过 URL 参数 keyword 检索相关内容，然后返回给用户 ​ 在python中，可以使用urllib库中urllib.parse模块中的parse_qs函数来解析查询字符串，以下为示例程序，程序返回字典，键值对分别为等号左右的内容 123456789101112131415from urllib.parse import urlparse, parse_qs # 示例URL url = 'http://example.com/path/to/resource?name=John&amp;age=30' # 解析URL parsed_url = urlparse(url) # 获取路径 path = parsed_url.path print(\"Path:\", path) # 解析查询参数 query_params = parse_qs(parsed_url.query) print(\"Query Parameters:\", query_params) Path: /path/to/resource Query Parameters: {'name': ['John'], 'age': ['30']} 处理表单数据 表单数据是通过网页上的表单收集并提交给服务器的信息，用户可以填写表单来提供各种信息。当用户点击表单上的提交按钮时，表单数据会被发送到服务器，服务器则根据接收到的数据执行相应操作 表单的基本结构如下 123456789&lt;form action=\"/submit\" method=\"post\"&gt; &lt;label for=\"username\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt;&lt;br&gt;&lt;br&gt; &lt;label for=\"password\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;form&gt;标签定义了一个表单，action属性指定了表单数据提交的目标url，method属性制定了提交数据时使用的HTTP方法 - GET：当method属性被设置为GET时，表单数据会被附加在url后面作为查询参数提交。这种方法适合提交少量的非敏感数据 - POST：当method属性被设置为POST时，表单数据会在请求体中发送，不会出现在url中。这种方法适合提交敏感与大量数据 &lt;input&gt;标签用于创建输入控件，type属性定义了输入控件的类型，name属性为提交属性时的键名，id用于关联&lt;label&gt;标签 &lt;label&gt;标签用于描述每个输入控件的用途 表单数据的编码： - application/x-www-form-urlencoded：这是默认的编码方式，表单数据被编码成键值对的形式，如 username=John&amp;password=Doe。 - multipart/form-data：当表单中包含文件上传字段时，必须使用此编码方式。它允许将文件和其他数据一起发送。 我们可以在python中通过request库发送POST请求来获取表单数据并处理，返回的是html类型的表单数据 1234567891011121314import requests # 示例表单数据 form_data = { 'username': 'john_doe', 'password': 'securepassword' } # 发送POST请求 response = requests.post('https://www.baidu.com/', data=form_data) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text) 处理JSON数据 python中可以使用request库来处理json数据 123456789101112131415import requests import json # 示例JSON数据 json_data = { 'name': 'John', 'age': 30 } # 发送POST请求 response = requests.post('https://www.baidu.com/', json=json_data) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response JSON:\", response.json()) 处理文件上传 HTTP文件上传是通过HTTP协议将文件从客户端传输到服务器的一种方式。通常使用POST方法，并且数据格式为multipart/form-data。这种格式允许在同一个请求中传输多个字段和文件。 HTTP文件上传中，请求头需要包含Content-Type，其值为multipart/form-data，并指定一个边界（boundary），用于分隔不同的字段和文件。例如 12345678910POST /upload HTTP/1.1 Host: www.example.com Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycz5DOEJKqu7XXB7k ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name=\"file\"; filename=\"example.png\" Content-Type: image/png &lt;文件内容&gt; ------WebKitFormBoundarycz5DOEJKqu7XXB7k-- 我们可以使用python的request库来处理文件上传响应 1234567891011import requests # 打开文件 files = {'file': open('example.txt', 'rb')} # 发送POST请求 response = requests.post('http://example.com/upload', files=files) # 查看响应 print(\"Response Status Code:\", response.status_code) print(\"Response Text:\", response.text)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【Python】CS61A——Mutablity","slug":"CS61A——Mutablity","date":"2025-03-19T11:10:30.067Z","updated":"2025-03-19T11:11:00.592Z","comments":true,"path":"2025/03/19/CS61A——Mutablity/","permalink":"https://izayoisakuye.github.io/2025/03/19/CS61A%E2%80%94%E2%80%94Mutablity/","excerpt":"","text":"Mutablity Objects 对象用于表达信息，是一种包含了数据与行为的数据抽象 有属性的东西都可以作为对象，python中一切皆对象 Python中，优先级最高的对象被称为类（class） 面向对象编程（OOP）： 对象是OOP的核心 OOP使用一种暗喻来组织大型程序 使用一种特殊语法可以提高程序的可读性与组织 很多数据操作都是通过对象实现的 对象可以做许多相关的事情，而函数只能做一件事 e.g. String 字符串是一种表达文本的数据抽象 ### 字符串的表示 目前常见的表示方法是用ASCII与Unicode字符集表示字符 前者包含了控制字符、数字、字母与标点，后者则包含了不同语言中的更多字符 1234from unicodedata import name, lookup print(name('A')) # 查询字符集中的字符名称 print(lookup('BABY')) # 根据字符名称输出对应字符 print(lookup('BABY').encode()) # 查看该字符的字节编码 LATIN CAPITAL LETTER A 👶 b'\\xf0\\x9f\\x91\\xb6' Mutation Operations 一些对象是可以改变的 1234567891011suits = ['coin', 'string', 'myriad'] original_suits = suits print(suits.pop()) # 弹出一个元素（默认最后一个） suits.remove('string') # 移除指定元素 print(suits) suits.append('cup') # 在尾部增加一个元素 suits.extend(['sword', 'club']) # 添加序列中的多个元素来拓展列表 print(suits) suits[2] = 'spade' suits[0:2] = ['heart', 'diamond'] print(original_suits) myriad ['coin'] ['coin', 'cup', 'sword', 'club'] ['heart', 'diamond', 'spade', 'club'] 根据以上代码发现，我们可以对一个对象（suits）进行若干操作来变化其值 而我们在最初将suits与original_suits进行绑定，故变化也会在original_suits中体现 综上，所有指向相同对象的names都会受到Mutation的影响，其中这里的mutation指对象发生的变化 只有可变类型的对象才能更改，如列表与字典 函数调用时发生的Mutation 函数可以更改其作用域中任何可变对象的值 12345def mystery(s): s.pop() s.pop() four = [1,2,3,4] mystery(four) mystery函数实现了对列表对象值的更改，甚至mystery不需要传入参数，直接更改其所在作用域（全局作用域）中four列表的内容 表达式的Mutation 表达式的值会随着names绑定值或对象的改变而改变 1234x = [1,2] print(x+x) x.append(3) print(x+x) [1, 2, 1, 2] [1, 2, 3, 1, 2, 3] Tuples 元组是一种不可变的序列，使用圆括号包裹起来 实际上，任何以逗号隔开的元素都会被解释成元组，非必须加圆括号 使用tuple()创建元组或将其他序列转化为元组 在单个元素后加一个逗号可以将单个元素转化成元组 元组可以相加，也可以使用成员运算符in来判断元素是否存在 由于元组不可变，可以将其作为字典的键使用 若元组中包含了可变对象，则该对象可以被更改 123s = ([1,2],3) s[0][0]=4 print(s) ([4, 2], 3) Mutation 相同与改变 12345a = [10] b = a print(a==b) a.append(20) print(a==b) True True 在这个例子中，我们可以说a与b是相同的，因为b与a绑定到了同一个对象，当对其中一个发生变化，另一个也会同时改变 12345a = [10] b = [10] print(a==b) b.append(20) print(a==b) 在这个例子中，a与b是不同的，尽管它们曾有过相同的内容，但对b进行改变后，a会随之改变，因此这时二者便不同了 Identity Operators Identity： &lt;exp0&gt; is &lt;exp1&gt; 当两个表达式指向相同对象时返回True Equality &lt;exp0&gt; == &lt;exp1&gt; 当两个表达式拥有相同值时返回True 相同对象始终拥有相等的值，但反之不一定成立 12345a = [10] b = [10] c = b print(a is b) print(b is c) False True 可变对象在函数中的默认值 函数中声明的默认值是函数值的一部分，而不是每次调用时才生成 这导致了若该对象是可变的，而且在函数中间进行了修改，则该修改会在下次调用函数时保留 如下面的代码，每次调用增加的值会保留在默认值中 12345def f(s=[]): s.append(3) return len(s) for i in range(3): print(f()) 1 2 3 Mutable Fuctions 在函数中使用可变对象可以在多次调用时保留上次操作的值 12345678910111213def make_withdraw_list(balance): b = [balance] def withdraw(amount): if amount &gt; b[0]: return 'Insufficient funds' b[0] = b[0] - amount return b[0] return withdraw withdraw = make_withdraw_list(100) print(withdraw(25)) print(withdraw(25)) withdraw(100) 75 50 'Insufficient funds' 该函数将存款存在作为可变对象的列表中 函数中的withdraw函数始终指向列表b并修改其值，该列表总是这个列表，随着时间其中的内容被更改 为了实现每次更改列表中的值，该函数使用了可变对象来创建了一个可变函数","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Trees","slug":"CS61A——Trees","date":"2025-03-09T05:38:32.956Z","updated":"2025-03-09T05:39:18.214Z","comments":true,"path":"2025/03/09/CS61A——Trees/","permalink":"https://izayoisakuye.github.io/2025/03/09/CS61A%E2%80%94%E2%80%94Trees/","excerpt":"","text":"Trees 描述树形结构的术语 递归描述 - 一课树有一个根节点和一系列分支节点 - 每个分支也是一棵树，也有根节点与分支节点 - 没有分支节点的树被称为叶子节点 亲戚描述 树的每个位置被称为节点 每个节点可以表示任何值 一个节点可以称为另一个节点的父节点/子节点 实现树形结构的抽象 12345678910111213141516171819202122232425262728293031def tree(label, branches=[]): for branch in branches: assert is_tree(branch), \"branches must be trees\" # 确保构造的是一棵树 return [label] +list(branches) # 将同一层的分支节点放在一个列表中 def label(tree): return tree[0] def branches(tree): return tree[1:] def is_tree(tree): \"\"\"判断是不是一棵树\"\"\" if type(tree) != list or len(tree) &lt;1: # 确保树的分支是树，以及存在一个值 return False for branch in branches(tree): # 确保树的分支的分支都是树 if not is_tree(branch): return False return True def is_leaf(tree): \"\"\"判断树本身是不是叶子节点\"\"\" return not branches(tree) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(t) print(label(t)) print(branches(t)) print(label(branches(t)[0])) [1, [5, [7]], [6]] 1 [[5, [7]], [6]] 5 Tree Processing 处理叶子节点 使用递归，将会在每个分支节点进行递归调用，最后合并 12345678910def count_leaves(t): \"\"\"Count the leaves of tree T\"\"\" if is_leaf(t): return 1 else: return sum([count_leaves(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(count_leaves(t)) 2 返回叶子节点的值 实现leaves函数，返回树的叶子节点的值的列表 12345678910def leaves(tree): \"\"\"return a list containing the leaf labels of tree\"\"\" if is_leaf(tree): return [label(tree)] else: return sum([leaves(b) for b in branches(tree)], []) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) [7, 6] 根据树创建树 使用递归根据另一棵树创建一颗新树 如让叶子节点值+1的树 或让所有节点都+1的树 1234567891011121314151617def increment_leaves(t): \"\"\"return a tree like t but with leaf labels incremented\"\"\" if is_leaf(t): return tree(label(t)+1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t), bs) def increment(t): \"\"\"return a tree like t but with all labels incremented\"\"\" return tree(label(t)+1, [increment(b) for b in branches(t)]) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(leaves(t)) print(increment_leaves(t)) print(increment(t)) [7, 6] [1, [5, [8]], [7]] [2, [6, [8]], [7]] 例：print_tree 按节点在树中的深度缩进打印一颗树 12345678def print_tree(t, indent = 0): print(' '*indent + str(label(t))) for b in branches(t): print_tree(b, indent+1) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_tree(t)) 1 5 7 6 None 例： 求从根节点沿路径到叶子节点求和并打印 1234567891011def print_sums(t, so_far): so_far = so_far +label(t) if is_leaf(t): print(so_far) else: for b in branches(t): print_sums(b,so_far) if __name__ == \"__main__\": t = tree(1, [tree(5, [tree(7)]), tree(6)]) print(print_sums(t, 0)) 13 7 None 1","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab4","slug":"CS61A——Lab4","date":"2025-03-06T09:57:15.925Z","updated":"2025-03-06T09:57:37.807Z","comments":true,"path":"2025/03/06/CS61A——Lab4/","permalink":"https://izayoisakuye.github.io/2025/03/06/CS61A%E2%80%94%E2%80%94Lab4/","excerpt":"","text":"Dictionaries 部分跳过 Divide 传入一组商数与一组除数，返回字典，键为每个商数，值为表示每个商数能整除的除数的列表 12345678910def divide(quotients, divisors): \"\"\"Return a dictonary in which each quotient q is a key for the list of divisors that it divides evenly. &gt;&gt;&gt; divide([3, 4, 5], [8, 9, 10, 11, 12]) {3: [9, 12], 4: [8, 12], 5: [10]} &gt;&gt;&gt; divide(range(1, 5), range(20, 25)) {1: [20, 21, 22, 23, 24], 2: [20, 22, 24], 3: [21, 24], 4: [20, 24]} \"\"\" return {i: [x for x in divisors if x%i==0] for i in quotients} 注意用表达式建立列表与字典的方法 Buying Fruit 实现buy函数，通过给定的水果与价格，用恰好为传入的total_amount的价格购买指定的水果（每种指定水果至少买一次） 用display函数输出所有结果 123456789101112131415161718192021222324252627282930313233343536def buy(required_fruits, prices, total_amount): \"\"\"Print ways to buy some of each fruit so that the sum of prices is amount. &gt;&gt;&gt; prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9} &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 12) [2 apples][1 orange][1 banana] &gt;&gt;&gt; buy(['apples', 'oranges', 'bananas'], prices, 16) [2 apples][1 orange][3 bananas] [2 apples][2 oranges][1 banana] &gt;&gt;&gt; buy(['apples', 'kiwis'], prices, 36) [3 apples][3 kiwis] [6 apples][2 kiwis] [9 apples][1 kiwi] \"\"\" def add(fruits, amount, cart): if fruits == [] and amount == 0: print(cart) elif fruits and amount &gt; 0: fruit = fruits[0] price = prices[fruit] for k in range(1,amount//price+1): add(fruits[1:], amount-k*price, cart+display(fruit,k)) add(required_fruits, total_amount, '') def display(fruit, count): \"\"\"Display a count of a fruit in square brackets. &gt;&gt;&gt; display('apples', 3) '[3 apples]' &gt;&gt;&gt; display('apples', 1) '[1 apple]' \"\"\" assert count &gt;= 1 and fruit[-1] == 's' if count == 1: fruit = fruit[:-1] # get rid of the plural s return '[' + str(count) + ' ' + fruit + ']' 返回条件是fruits为空或钱被花光，且递归时每次都取fruits的首个元素 可以推断递归时对fruits数组进行了切片，每次往后切一个元素 for循环遍历选择每个水果的个数，从至少选一个到最多能选的个数 递归时传入总价格减去已经使用的价格数的不同情况，并使用display函数进行字符串拼接来显示 Cities ADT 以下问题基于建立的该ADT 一个城市由以下参数描述：名称、经度、维度 包括一个构造函数 - make_city(name, lat, lon)：建立一个城市对象，存储其名称、经度、维度 以下选择器 - get_name(city)：获取城市名称 - get_lat(city)：获取城市经度 - get_lon(city)：获取城市维度 该抽象数据类型已经在文件中实现，你不需要知道是怎么实现的 Distance 计算并返回两城市的距离 12345678910111213from math import sqrt def distance(city_a, city_b): \"\"\" &gt;&gt;&gt; city_a = make_city('city_a', 0, 1) &gt;&gt;&gt; city_b = make_city('city_b', 0, 2) &gt;&gt;&gt; distance(city_a, city_b) 1.0 &gt;&gt;&gt; city_c = make_city('city_c', 6.5, 12) &gt;&gt;&gt; city_d = make_city('city_d', 2.5, 15) &gt;&gt;&gt; distance(city_c, city_d) 5.0 \"\"\" return sqrt(abs(get_lat(city_a)-get_lat(city_b))**2+abs(get_lon(city_a)-get_lon(city_b))**2) Closer City 比较两个城市离给定经纬度的远近，返回更近的那个城市 1234567891011121314151617181920def closer_city(lat, lon, city_a, city_b): \"\"\" Returns the name of either city_a or city_b, whichever is closest to coordinate (lat, lon). If the two cities are the same distance away from the coordinate, consider city_b to be the closer city. &gt;&gt;&gt; berkeley = make_city('Berkeley', 37.87, 112.26) &gt;&gt;&gt; stanford = make_city('Stanford', 34.05, 118.25) &gt;&gt;&gt; closer_city(38.33, 121.44, berkeley, stanford) 'Stanford' &gt;&gt;&gt; bucharest = make_city('Bucharest', 44.43, 26.10) &gt;&gt;&gt; vienna = make_city('Vienna', 48.20, 16.37) &gt;&gt;&gt; closer_city(41.29, 174.78, bucharest, vienna) 'Bucharest' \"\"\" fake_city = make_city('fake', lat, lon) if distance(fake_city,city_a)&lt;distance(fake_city,city_b): return get_name(city_a) else: return get_name(city_b) 可以将指定的经纬度看作第三个城市并构造这么一个对象 通过上面已经写完的distance函数计算两城市与第三个城市的距离并比较，输出更近的 若相同输出city_b","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Data Abstraction","slug":"CS61A——Data Abstraction","date":"2025-03-03T12:52:03.826Z","updated":"2025-03-03T13:06:05.083Z","comments":true,"path":"2025/03/03/CS61A——Data Abstraction/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Data%20Abstraction/","excerpt":"","text":"Data Abstraction Data Abstraction 大多数值都是复合值，由多种对象组成 抽象数据类型可以让我们将符合对象作为一个单元操作，允许我们隔离使用数据的程序的两个部分： 数据的表示 数据的操作 即在数据的表示与操作之间建立一个抽象屏障 Example——Rational Numbers 表示 任何有理数可以表示为一个最简分数 这为小数提供了更精确的表示方法 故我们需要分开分子分母，作为一个复合数据类型： rational(n,d)返回一个有理数x numer(x)返回有理数x的分子 denom(x)返回有理数的分母 第一个函数称为构造函数（constructor），它用于构造一个新值作为抽象数据类型的实例（instance） 第二、三个函数称为选择器（selectors），它们返回得到的有理数的整数部分 这三个函数作为有理数的抽象数据类型使用，用它们进行数字操作 算术 根据小学二年级知识，我们根据分数来执行有理数加乘，公式如下 有理数算术 12345678910def mul_rational(x,y): return rational(numer(x)*numer(y),denom(x)*denom(y)) def add_rational(x,y): nx, dx = numer(x), denom(y) ny, dy = numer(y), denom(y) return rational(nx*dy+ny*dx, dx*dy) def equal_rational(x,y): return numer(x)*denom(y)==numer(y)*denom(x) Abstraction Barriers 拿上方的有理数函数作为例子 抽象屏障 抽象屏障表示使用由有理数计算时使用的函数只能是对应相关的，而不能越界表示 用有理数计算时只需要使用计算相关函数 用来表示有理数和进行操作时只需要使用对应构造函数与选择器 用来构建构造函数与选择器时需要用到列表与元素选择 一种跨越了抽象屏障的反例： 1234add_rational([1,2],[1,4]) def divide_rational(x,y): return [x[0]*y[1], x[1]*y[0]] Pair 创建与访问 通常使用列表表示一个pair 123&gt;&gt;&gt; pair = [1,2] &gt;&gt;&gt; pair [1,2] 通过序列解包或列表下标获得pair中的两个值 1234567&gt;&gt;&gt; x,y=pair &gt;&gt;&gt; x 1 &gt;&gt;&gt; y 2 &gt;&gt;&gt; pair[0] 1 还可以用getitem函数获得值，在operator库中 用法：getitem(&lt;list&gt;, &lt;index&gt;) 1234&gt;&gt;&gt; getitem(pair, 0) 1 &gt;&gt;&gt; getitem(pair, 1) 2 用pair表示有理数 123def rational(n,d): \"\"\"Construct a rational number that represents N/D\"\"\" return [n, d] 返回一个列表，记录分子分母用来表示有理数 1234567def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x[0] def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x[1] 通过访问列表中的元素返回分子分母 应用 分数通分 有理数的分子分母应互质，故我们可以用gcd获取它们的最大公因数来同时除以分子分母以确保获得互质的分子分母 1234from fractions import gcd def rational(n,d): g = gcd(n,d) return [n//g, d//g] Data Representation 数据抽象的基本思想：通过它的行为来识别该抽象数据类型 改变有理数的表现形式 1234567891011121314def rational(n,d): def select(name): if name == 'n': return n elif name == 'd': return d return select def numer(x): \"\"\"Return the numerator of rational number x\"\"\" return x('n') def denom(x): \"\"\"Return the denominator of rational number x\"\"\" return x('d') 这里使x成为一个函数，这样就可以不需要内置的列表数据类型了 此时rational是一个高阶函数，返回一个表示有理数的函数","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Lab3","slug":"CS61A——Lab3","date":"2025-03-03T12:51:43.540Z","updated":"2025-03-03T13:04:15.175Z","comments":true,"path":"2025/03/03/CS61A——Lab3/","permalink":"https://izayoisakuye.github.io/2025/03/03/CS61A%E2%80%94%E2%80%94Lab3/","excerpt":"","text":"WWPD部分省略 Print If 返回列表中满足函数f的元素 12345678910111213141516def print_if(s, f): \"\"\"Print each element of s for which f returns a true value. &gt;&gt;&gt; print_if([3, 4, 5, 6], lambda x: x &gt; 4) 5 6 &gt;&gt;&gt; result = print_if([3, 4, 5, 6], lambda x: x % 2 == 0) 4 6 &gt;&gt;&gt; print(result) # print_if should return None None \"\"\" for x in s: if f(x): print(x) return None Close 返回列表中元素大小与下标差的绝对值小于规定值的元素个数 123456789101112131415161718def close(s, k): \"\"\"Return how many elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close(t, 0) # Only 3 is equal to its index 1 &gt;&gt;&gt; close(t, 1) # 2, 3, and 5 are within 1 of their index 3 &gt;&gt;&gt; close(t, 2) # 2, 3, 4, and 5 are all within 2 of their index 4 &gt;&gt;&gt; close(list(range(10)), 0) 10 \"\"\" count = 0 for i in range(len(s)): # Use a range to loop over indices if abs(s[i]-i)&lt;=k : count+=1 return count Close List 返回一个列表，元素为给定列表中元素大小与下标差的绝对值小于规定值的元素 123456789101112def close_list(s, k): \"\"\"Return a list of the elements of s that are within k of their index. &gt;&gt;&gt; t = [6, 2, 4, 3, 5] &gt;&gt;&gt; close_list(t, 0) # Only 3 is equal to its index [3] &gt;&gt;&gt; close_list(t, 1) # 2, 3, and 5 are within 1 of their index [2, 3, 5] &gt;&gt;&gt; close_list(t, 2) # 2, 3, 4, and 5 are all within 2 of their index [2, 4, 3, 5] \"\"\" return [s[i] for i in range(len(s)) if s[i]-i&lt;=k] Squares Only 返回一个列表，元素为给定列表中为完全平方数的元素 1234567891011121314from math import sqrt def squares(s): \"\"\"Returns a new list containing square roots of the elements of the original list that are perfect squares. &gt;&gt;&gt; seq = [8, 49, 8, 9, 2, 1, 100, 102] &gt;&gt;&gt; squares(seq) [7, 3, 1, 10] &gt;&gt;&gt; seq = [500, 30] &gt;&gt;&gt; squares(seq) [] \"\"\" return [int(sqrt(n)) for n in s if sqrt(n)==round(sqrt(n))] 注意返回的是开方后的数，是整数 Double Eights 使用递归判断给定的数中是否存在相邻的两个8 123456789101112131415161718192021222324252627def double_eights(n): \"\"\" Returns whether or not n has two digits in row that are the number 8. Assume n has at least two digits in it. &gt;&gt;&gt; double_eights(1288) True &gt;&gt;&gt; double_eights(880) True &gt;&gt;&gt; double_eights(538835) True &gt;&gt;&gt; double_eights(284682) False &gt;&gt;&gt; double_eights(588138) True &gt;&gt;&gt; double_eights(78) False &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(LAB_SOURCE_FILE, 'double_eights', ['While', 'For']) True \"\"\" if n==0: return False if n%100==88: return True else: return double_eights(n//10) Making Onions 判断是否能通过f函数与g函数进行至多limit次操作实现将x转化为y 1234567891011121314151617181920212223242526272829303132def make_onion(f, g): \"\"\"Return a function can_reach(x, y, limit) that returns whether some call expression containing only f, g, and x with up to limit calls will give the result y. &gt;&gt;&gt; up = lambda x: x + 1 &gt;&gt;&gt; double = lambda y: y * 2 &gt;&gt;&gt; can_reach = make_onion(up, double) &gt;&gt;&gt; can_reach(5, 25, 4) # 25 = up(double(double(up(5)))) True &gt;&gt;&gt; can_reach(5, 25, 3) # Not possible False &gt;&gt;&gt; can_reach(1, 1, 0) # 1 = 1 True &gt;&gt;&gt; add_ing = lambda x: x + \"ing\" &gt;&gt;&gt; add_end = lambda y: y + \"end\" &gt;&gt;&gt; can_reach_string = make_onion(add_ing, add_end) &gt;&gt;&gt; can_reach_string(\"cry\", \"crying\", 1) # \"crying\" = add_ing(\"cry\") True &gt;&gt;&gt; can_reach_string(\"un\", \"unending\", 3) # \"unending\" = add_ing(add_end(\"un\")) True &gt;&gt;&gt; can_reach_string(\"peach\", \"folding\", 4) # Not possible False \"\"\" def can_reach(x, y, limit): if limit &lt; 0: return False elif x == y: return True else: return can_reach(f(x), y, limit - 1) or can_reach(g(x), y, limit - 1) return can_reach","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【算法】BFS","slug":"BFS","date":"2025-03-01T03:30:53.100Z","updated":"2025-03-01T03:31:12.066Z","comments":true,"path":"2025/03/01/BFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/BFS/","excerpt":"","text":"BFS 参考视频1_ 参考视频2 预备知识：队列 特点：先进先出（FIFO），队头删除元素，队尾插入元素 基本用法：见文件 对于bfs，我们需要一层一层遍历所有节点，那么相邻节点的访问顺序该如何确定？因此我们需要队列去存储和操作，需要使先遍历到的结点先被存储，直到当前层都被存储之后，按存储的先后顺序，先被存储的节点也会先被取出，继续遍历子节点。符合队列的FIFO特点 基本思想 解决问题 从A出发是否存在到达B的路径（DFS也行） 从A出发到达B的最短路径（DFS+剪枝也行，容易TLE） 基本思想 从初始状态s（图上某个节点出发）开始利用规律，生成所有可能状态，构成树的下一层节点 检查是否出现目标状态g，若未出现则对该层所有状态节点分别利用规则，生成在下一层的所有状态节点 对新一层继续检查重复上述操作直到出现目标状态 注意：BFS实际上是传回经过边数最少的解，因此对于所有边长度（边权）相同的情况，此时就一定是从根节点到目标节点最短的路径，BFS先找到的就一定是最短的，但如果是加权边，BFS传回的就不一定最短了。对于加权路径的最短路，我们使用Dijkstra算法求解。 基本步骤 起始：将起点（根节点）放入队列中 扩散：从队列中取出队头结点，将其相邻节点放入队列，不断重复 终止：当队列为空是，说明遍历完了所有节点 空间复杂度 ：b为最大分支系数，n为树高 板子 1234567891011121314151617Node bfs(node source, node target){ memset(visit, 0 , sizeof(visit)); queue&lt;node&gt; q; q.push(source); visit[source] = 1; while(!q.empty()){ Node a = q.front(); q.pop(); if (a==target) return a; for (/*对于a所有的后继节点b*/){ if (visit[b]) continue; q.push(b); visit[b]=1; // 剪枝,保证节点只进队列一次 } return NULL; } } 例：二叉树的层次遍历-queue的实现解释 层次遍历：从上到下，从左到右进行遍历 思想 维护队列，用于存放节点信息，当访问到一个节点时，先访问该节点，然后将该节点的左右儿子分别入队列 伪代码 12345678910bfs(int root){ queue&lt;int&gt; q; q.push(root); while q不为空： 获得队首元素 队首元素出队 输出当前节点值 if 该节点左儿子不为空：将左儿子加入队列 else if 该节点右儿子不为空：将右儿子加入队列 } 例：对于一个层次遍历：5172463的树 ​ 队列q： ​ 放入root节点：q：5 ​ 队列空否？ 不空，输出5并删除，q： ​ 有孩子否？有，放入5的左右孩子1 7，q：1 7 ​ 队列空否？ 不空，输出1并删除，q：7 ​ 有孩子否？有，放入1的左右孩子2 4，q：7 2 4 ​ 队列空否？ 不空，输出7并删除，q：2 4 ​ 有孩子否？有，放入7的左右孩子6 3，q：2 4 6 3 ​ 队列空否？ 不空，输出2并删除，q：4 6 3 ​ 有孩子否？无，继续，q：4 6 3 ​ 剩下三个相同 q：6 3 q：6 q： ​ 例：图的bfs image-20241112203528097 图与树类似，但图任何两点间都可以有边，故方法相似 但图没有层次关系，访问的是某点的邻接点，若一个点已经访问过就没必要在访问了：如B的邻接点AEC，若想要放进去子节点，则AE没有必要再入队列 步骤：放入起始节点，循环判断队列空不空，若不空则放入相邻节点 BFS最适合的：寻找最少几步能达到目标（特殊的最短路问题） 例：奇怪的电梯 奇怪的电梯 题目描述 呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 层楼（）上有一个数字 （）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： 代表了 （，，……），从 楼开始。在 楼，按“上”可以到 楼，按“下”是不起作用的，因为没有 楼。那么，从 楼到 楼至少要按几次按钮呢？ 输入格式 共二行。 第一行为三个用空格隔开的正整数，表示 （，）。 第二行为 个用空格隔开的非负整数，表示 。 输出格式 一行，即最少按键次数，若无法到达，则输出 -1。 样例 #1 样例输入 #1 125 1 5 3 3 1 2 5 样例输出 #1 13 提示 对于 的数据，，，。 本题共 个测试点，前 个每个测试点 分，最后一个测试点 分。 如样例：从1楼到5楼，可以从1-&gt;4-&gt;2-&gt;5 按三次按钮 搜索状态：从一个状态出发，根据题目不断转移状态直到到达目标状态，对实例如图： 如题：从1楼开始 1楼只能往上到4楼，四楼只能往下到2楼，二楼只能往上到五楼 ​ 所以这是一个典型的二叉树，起始状态为起点，目标状态为样例输入的楼层 记录按按钮次数：使用结构体将楼层和按钮次数封装 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 300; struct node{ // 保存按钮次数 int level; // 当前楼层 int steps; // 走到当前楼层所需要步数 }floors[N]; int n,st,ed; // 总楼层数,起始楼层,目标楼层 int a[N], vis[N]; // 分别保存每个楼层可以移动几层, 该楼层是否来过 void bfs(){ queue&lt;node&gt; q; node cur, net; // 记录当前状态与下一状态 cur.level = st; // 当前位于起点，楼层为起始楼层 cur.steps = 0; // 所需步数为0 q.push(cur); // 存入根节点 vis[st]=1; // 起始已经走过，设为1；因为过去以后无需返回，返回得到的值一定更大 while(!q.empty()){ // 队列非空 cur = q.front(); // 取出队首 q.pop(); // 删掉 if (cur.level == ed){ // 如果取出的对手即为目标楼层，则可以结束 cout &lt;&lt; cur.steps; return ; } // 向上扩展 net.level = cur.level + a[cur.level] ; // 下一步可以走到哪个楼层 net.steps = cur.steps+1; // 步数加1 if (net.level&lt;=n){ // 不超最高楼层 if (vis[net.level]==0){ // 若没有来过 vis[net.level] = 1; // 可以去 去完标记已来过 q.push(net); // 将子节点放到队列里 } } // 向下扩展 net.level = cur.level - a[cur.level]; net.steps = cur.steps+1; if (net.level&gt;=1){ if (vis[net.level]==0){ vis[net.level] = 1; q.push(net); } } } cout &lt;&lt; -1; // 找不到咯 return ; } int main(){ ios; cin &gt;&gt; n &gt;&gt; st &gt;&gt; ed; for (int i = 1; i&lt;= n;i++){ cin &gt;&gt; a[i]; vis[i]=0; // 初始化 } bfs(); return 0; } 例：非常可乐 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出”NO”。 Sample 输入 1237 4 3 4 1 3 0 0 0 输出 12No 3 看似找不出图的一个搜索：只要根据信息能表示出状态，且状态能根据规则进行转移就可以用搜索 定义节点状态：三杯水量+当前状态最少倒水次数 状态转移如图（以4 1 3为例，最后一位是次数）： image-20241112220340957 目标状态：达到两个量相等一个量为0 倒水要求：只能倒满或者倒空 这种题目称为隐式图 如何剪枝：访问过的节点不在访问 例：离开中山路 离开中山路 题目背景 《爱与愁的故事第三弹·shopping》最终章。 题目描述 爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 处，车站在 处。现在给出一个 的地图， 表示马路， 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 ）。你能帮他解决吗？ 输入格式 第 行包含一个数 。 第 行到第 行：整个地图描述（ 表示马路， 表示店铺，注意两个数之间没有空格）。 第 行：四个数 。 输出格式 只有 行，即最短到达目的地距离。 样例 #1 样例输入 #1 123453 001 101 100 1 1 3 3 样例输出 #1 14 提示 对于 数据，满足 。 对于 数据，满足 。 可以使用方向数组来转移状态: 对于网格地图,可以定义一个二维数组 int dir[4][2]={{0,-1},{0,1},{1,0},{-1,0}}; 则遍历四个方向可以 1234for (int i = 0; i &lt;4; i++){ x2 = x1+dir[i][0]; y2 = y1+dir[i][1]; } 坑点：输入中间无空格，是一起输入的，需要用字符串转换为某行某列（ascii转化，char - 'a'）存入数组 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*迷宫问题如果要求最短路径（权值为1）相关，则可以选用bfs 这里可以将迷宫看作图，详见markdown中图的遍历 */ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; const int N = 1010; typedef pair&lt;int,int&gt; PII; int n,sx,sy,ex,ey; // 记录地图大小，起点终点 int mmap[N][N], vis[N][N]; // 记录地图和是否走过（走过不用再往回走，不然步数一定更长） int dx[]={-1,0,1,0}; // 方向数组x int dy[]={0,1,0,-1}; // 方向数组y // 结构体记录坐标与步数 struct node{ int first; // 当前x坐标 int second; // 当前y坐标 int steps; // 当前步数 }; void bfs(){ queue&lt;node&gt; q; // 队列 node cur, net; // 记录当前状态与下一状态 cur.first = sx, cur.second = sy, cur.steps = 0; // 初始化为起始坐标，步数为0 vis[sx][sy] = 1; // 不要忘了起始坐标设为1 q.push(cur); // 根节点入队 while(!q.empty()){ // 队列变空时搜索完毕 cur = q.front(); // 取出队首 q.pop(); // 删除队首 if (cur.first == ex &amp;&amp; cur.second == ey){ // 到达终点 cout &lt;&lt; cur.steps; //输出步数 return ; // 跳出 } for (int i = 0;i &lt;4; i++){ net.first = cur.first+dx[i]; // 下一步的x坐标 net.second = cur.second+dy[i]; // 下一步的y坐标 if (net.first&lt;1||net.second&lt;1||net.first&gt;n||net.second&gt;n) continue; // 超出边界 if (mmap[net.first][net.second]) continue; // 碰到障碍 if (vis[net.first][net.second]) continue; // 已经访问 net.steps = cur.steps +1; // 若满足前进的条件就前进一步 vis[net.first][net.second] = 1; // 把访问过的地方标记 q.push(net); // 将子节点入队列 } } return ; } int main(){ ios; cin &gt;&gt; n; string s; // 注意：这里题目输入间没有空格，相当于是输入一整个数字，需要手动拆开 // 这里用转成字符串用ascii转化的方法 for (int i = 1;i &lt;=n;i++){ cin &gt;&gt; s ; for (int j = 1;j &lt;=n;j++){ mmap[i][j] = s[j-1]-'0'; vis[i][j]=0; } } cin &gt;&gt; sx &gt;&gt;sy &gt;&gt; ex &gt;&gt; ey; bfs(); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【算法】DFS","slug":"DFS","date":"2025-03-01T03:29:57.440Z","updated":"2025-03-01T03:30:36.654Z","comments":true,"path":"2025/03/01/DFS/","permalink":"https://izayoisakuye.github.io/2025/03/01/DFS/","excerpt":"","text":"DFS 参考视频 前置知识：二叉树的遍历 三种遍历 先根遍历（根左右） 中根遍历（左根右） 后根遍历（左右根） 注意：这里的左右为左右子树 e.g. 1. 先根遍历：271653894 1. 中根遍历：175632849 1. 后根遍历：153674982 二叉树的确定 给定先根和中根、中根和后根遍历结果，可以唯一确定二叉树 e.g. 上面，在先根中确定2为根，在中根中找到2，则2前后分别为其左右子树；再在先根中找到7，在中根中找到7，则7前后为其左右子树，以此类推。中根后根与前根后根是对称的。 给定先根和后根遍历结果，不能唯一确定二叉树 只知道根数量而不知道左右子树数量 递归 递归特征：大问题与子问题除了规模其他都一样 斐波那契数列的递归实现 1234int fi(int a){ if (a==0||a==1) return 1; else return fi(a-1)+fi(a-2); } 即有一个特定模板： 即先写程序出口（不需要递归的特殊情况），再写普通情况（递归） 全排列问题 输入一个正整数n，按字典序输出n-1的全排列 递归特征 若第一个数确定，剩余的问题就是其余n-1个数的全排列 若前k个数已经排好，剩余问题就是其余n-k个数的全排列 代码实现 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; using namespace std; int n; int num[10], vis[10]; void dfs(int step); int main(){ while (scanf(\"%d\",&amp;n)==1){ memset(vis,0,sizeof vis); dfs(1); // 从第一位开始处理 } return 0; } void dfs(int step){ // 接下来准备处理第step位 if (step==n+1){ // 前n位都放好了，进行输出 for (int i = 1; i &lt;=n; i++) printf(\"%d\", num[i]); printf(\"\\n\"); return ; } for (int i = 1;i &lt;= n;i++){ if (vis[i]==0){ // 第i位数没用过 num[step]=i; // nun中当前这一位保存一个i vis[i]=1; // i被用过了，做标记1 dfs(step+1); vis[i]=0; } } } 若n==3： vis：0 0 0 0 step==1 ​ 进入for循环: vis[1]==0 ​ 使num[1]=1 vis[1] = 1 ​ num： 0 1 0 0 0 ​ vis：0 1 0 0 表示1用过了 vis： 0 1 0 0 step==2 ​ 进入for循环: vis[2]==0 ​ num[2]=2 vis[2] = 1 ​ num： 0 1 2 0 0 ​ vis：0 1 1 0 表示1,2用过了 vis：0 1 1 0 step==3 ​ 进入for循环: vis[3]==0 ​ num[3]=3 vis[3] = 1 ​ num： 0 1 2 3 0 ​ vis：0 1 1 1 表示1,2,3用过了 vis：0 1 1 1 step==4 ​ step == 3+1成立，到达边界，则输出num[1]到num[n] 123 ​ return 到dfs(3)中（谁调用的返回谁） dfs(3)：vis[3]=0 vis：0 1 1 0 程序结束返回dfs(2) dfs(2)：vis[2]=0 vis：0 1 0 0 ​ 此时进行下一次循环 i==3，vis[3]==0 ​ num[2]=3,vis[3]=1 ​ num： 0 1 3 0 ​ vis：0 1 0 1 表示1,3用过了 ​ 再进入dfs(3)，重复上述操作后 ​ num：0 1 3 2 ​ vis：0 1 1 1 ​ 进入dfs(4)到达边界输出 132 ​ return 到dfs(3)中重复上述过程 若没有vis[i]=0的回溯，则第一遍return后vis仍保持全标记1状态，则无法再输出其他排列直接结束 基本模型 关键在于着眼于当下如何做，下一步的做法与当前一样，只是参数不同 123456void dfs(int step){ 特殊情况处理(结束递归情况) 枚举当前每一种可能for(int i=1;i&lt;=;i++) 在枚举的每一种可能中，递归dfs(step+1); 回溯 } 例：迷宫搜索 Tempter of the Bone Problem Description The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze. The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. Input The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following: ‘X’: a block of wall, which the doggie cannot enter; ‘S’: the start point of the doggie; ‘D’: the Door; or ‘.’: an empty block. The input is terminated with three 0’s. This test case is not to be processed. Output For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise. Sample Input 123456789104 4 5 S.X. ..X. ..XD .... 3 4 5 S.X. ..X. ...D 0 0 0 Sample Output 12NO YES 分析： 每个block只能走一次 恰好给定时间到达出口 剪枝条件： 若可走的block总数小于时间：全走完都开不了门，肯定NO 若起点在左上角，门在右下角，没有障碍物且最短路径（曼哈顿距离：行坐标差减列坐标差）都比时间长，肯定NO 奇偶性剪枝（应用条件：每个格子只能等一秒）： 使行列坐标相加为偶数的标为0，为奇数的标为1，发现1的下一步一定为0，0的下一步一定为1 那么如果从0走到1或从1走到0，所需时间为奇数；如果从1走到1或从0走到0，所需时间为偶数 那么如果规定时间为偶数，则从0到1或从1到0肯定NO，反之亦然。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); #define endl '\\n' using namespace std; using ll = long long; char mmap[9][9]; // 存储地图 注意地图要比数据范围大一点 int n,m,t,escape; int si,sj,di,dj; // 记录起始与结束点坐标 int dir[4][2]={{0,-1},{0,1},{-1,0},{1,0}}; // 进行上下左右四个方向的行走 void dfs(int x, int y, int cnt){ // 行列坐标，已经花的时间 if (x&gt;n||y&gt;m||x&lt;=0||y&lt;=0) return ; // 越过边界，跳过 if (cnt==t&amp;&amp;x==di&amp;&amp;y==dj) { // 在开门时间到达出口 escape=1; // 标记逃离成功 } if (escape) return ; // t-cnt:剩余时间 两abs:剩余距离 int tmp=((t-cnt)-abs(di-x)-abs(dj-y)); // 小于零：剩余时间内走不到终点 /* 是奇数：为了到达门口，剩余时间与剩余距离的奇偶性一定要相同 奇数-奇数=偶数 偶数-偶数=偶数 故tmp一定要是偶数才能保证走到门口，否则包走不到 即奇偶性剪枝 */ // 该奇偶性剪枝可以在主函数里写，因为时间和距离是同步进行的 if (tmp&lt;0) return ; // 四个方向遍历 for (int i = 0 ;i &lt; 4;i++){ if (mmap[x+dir[i][0]][y+dir[i][1]]!='X'){ // 不是障碍物 mmap[x+dir[i][0]][y+dir[i][1]]='X'; //修改 dfs(x+dir[i][0],y+dir[i][1],cnt+1); //递归 mmap[x+dir[i][0]][y+dir[i][1]]='.'; //回溯，这样可以回到上一步换一条路走 } } return ; } int main(){ while(cin &gt;&gt; n &gt;&gt; m &gt;&gt;t){ if (n==0&amp;&amp;m==0&amp;&amp;t==0) break; // 结束条件 int block = 0; // 障碍物数量：用来剪枝 for(int i = 1;i &lt;=n;i++){ for(int j = 1; j&lt;=m;j++){ cin &gt;&gt; mmap[i][j]; if (mmap[i][j]=='S') { si=i; sj=j; } else if (mmap[i][j]=='D') { di=i; dj=j; } else if (mmap[i][j]=='X') block++; } } // 剪枝1：迷宫格子数量减去障碍物数量小于等于开门时间，一定出不去 if (n*m-block&lt;=t) { cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // 剪枝2：见dfs里的解释 if ((t-(abs(di-si)+abs(dj-sj)))%2==1){ cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } // escape标记是否成功，把起点标为障碍物，确保不会再回来 escape = 0, mmap[si][sj]='X'; dfs(si,sj,0); // 判断是否能逃离 if (escape) cout &lt;&lt;\"YES\" &lt;&lt;endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【算法】前缀和与差分","slug":"前缀和与差分","date":"2025-03-01T02:53:46.740Z","updated":"2025-03-01T03:30:26.716Z","comments":true,"path":"2025/03/01/前缀和与差分/","permalink":"https://izayoisakuye.github.io/2025/03/01/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和与差分 一维前缀和 e.g. 给定长度为n的数组arr, 求q次询问中每次arr在[l,r]的区间和 暴力枚举的时间复杂度为O(qn) 容易TLE 使用前缀和可以极大减少运行时间 前缀和数组 定义一个前缀和数组prefix[i]=prefix[i-1]+arr[i]，其中i&gt;0 i=0时sum[0]=arr[0] 则对于数a1,a2,a3,a4,a5…. prefix[1]=a1 prefix[2]=a1+a2 prefix[3]=a1+a2+a3 … 可以看出，prefix[i]为区间[0,i]的和 在求区间的和时，如2-4，就可以使用prefix[4]-prefix[1],通式为prefix[r]-prefix[l-1], l=0时为prefix[r] 其中，求前缀和的过程成为预处理 板子 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; //#define get_sum(l, r) ((l)?(sum[r]-sum[l]):(sum[r])) using namespace std; const int N = 10000; int a[N], prefix[10000]; int get_sum(int l , int r){ if (l) return prefix[r]-prefix[l-1]; else return prefix[r]; } int main(){ ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // 预处理，一般以1开始为下标 for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // 访问 int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; //cout &lt;&lt; prefix[r]-prefix[l-1]; cout &lt;&lt; get_sum(l,r); } return 0; } 二维前缀和 给定一个长n,宽m的矩阵: 求矩阵任意两点间矩形的数字之和 二维前缀和数组 定义一个二维前缀和数组prefix[i][j] =prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]，其中i&gt;0 其中，prefix[i][j]为从(0,0)到(i,j)的和 当i=0且j=0时，prefix[0][0]=a[0][0] 当i=0且j!=0时，prefix[0][j]=prefix[0][j-i]+a[0][j] 当i!=0且j=0时，prefix[i][0]=prefix[i-1][0]+a[i][0] 如下图： 即prefix[i][j]是由a[i][j],prefix[i-1][j],prefix[i][j-1]组成的，但两块加多了一块prefix[i-1][j-1]，故减去 若要求解某部分矩形，就可以进行以上的逆过程 a[i][j]=prefix[i][j]-prefix[i-1][j]-prefix[i][j-1]+prefix[i-1][j-1] 从prefix[i][j]开始，求a[i][j]，则可以依次减去prefix[i-1][j],prefix[i][j-1]，但会多减一块prefix[i-1][j-1]，故加上 板子 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m; int a[N][N]; int prefix[N][N]; void pre_sum(){ /*以下代码是当for循环从0开始时的初始化 prefix[0][0]=a[0][0]; for (int i = 1;i &lt;n;i++) prefix[i][0] = prefix[i-1][0]+a[i][0]; for (int j = 1;j &lt;m;j++) prefix[0][j] = prefix[0][j-1]+a[0][j]; */ for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+a[i][j]; } } } int get_sum(int x1, int y1, int x2, int y2){ /*以下为从0开始时的特殊情况 // 从0,0开始加 if (!x1 &amp;&amp; !y1) return prefix[x2][y2]; // 成行相加 if (!x1) return prefix[x2][y2]-prefix[x2][y1-1]; // 成列相加 if (!y1) return prefix[x2][y2]-prefix[x1-1][y2]; */ return prefix[x2][y2]-prefix[x1-1][y2]-prefix[x2][y1-1]+prefix[x1-1][y1-1]; } int main(){ int x1,y1,x2,y2; cin &gt;&gt; n &gt;&gt;m; for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; } } cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; pre_sum(); cout &lt;&lt; get_sum(x1,y1,x2,y2); return 0; } 一维差分 给定长度为n的数组arr，进行m个操作，使[l,r]区间内的值都加一个value，操作结束后，询问arr 暴力解法：每次遍历数组[l,r]执行加value操作，遍历m次，时间复杂度O(n*m) 例如 arr中有五个数 1 3 7 5 2 对[2,4] +5 [1,3] +2 [0,2] -3 对于下标为2的数分析，7+5+2-3=11. 若不管中间，则相当于7+4=11. 则我们的目的即为让中间的步骤省略，最后只+4. 差分数组 定义一个差分数组d[i]=arr[i]-arr[i-1] 则对d进行前缀和，得到前缀和数组sum，我们可以发现： ​ 差分数组可以通过前缀和得到原数组 ​ 即d[i]+=d[i-1] 差分标记 对于一位差分区间修改：[l,r]+valued[l]+value, d[r+1]-value 对于以上arr 对应差分数组d为1 2 4 -2 -3 第一次操作等价于d[2]+5 结果为1 2 9 -2 -3 第二次等价于d[1]+2,d[4]-2 结果为1 4 9 -2 -5 第三次：-2 4 9 1 -5 进行前缀和得到sum -2 2 11 12 7 注意： 把标记后的差分数组进行一次前缀和操作 每进行m次操作后都要进行一次前缀和 即适用于多次操作单次询问（单次操作单次询问不适用） 原理： 差分数组中，标记位加了一个数，还原成原数组的时候，后面的数都会累加，然后再r+1位在减去这个数停止累加 最终实现的效果为：sum[l,r]+value, sum[r+1,n-1] +value - value 如：对于差分数组d 0 1 0 0 0，进行一次前缀和后其sum为 0 1 1 1 1，即标记位加的数会作用与该标记之后每一位，即d[i]+value sum[i,n-1]+value 若想在某位置停止累加，在该位置+1处减掉value即可，如 d 0 1 0 0 -1，前缀和后sum为 0 1 1 1 0，加一减一抵消为0，即d[r+1]-value sum[r+1,n-1]-value 板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt; using namespace std; int main(){ int a[10000]={0}, diff[10000]={0}, prefix[10000]={0}; int n; cin &gt;&gt; n; for (int i = 1; i &lt;=n ; i++) { cin &gt;&gt; a[i]; } // 预处理，得到差分数组，一般以1开始为下标 for (int i = 1; i &lt;= n; i++) { diff[i] = a[i]-a[i-1]; } // 对区间元素处理 // 想让区间元素都+x，则可以让l右边都加x，再r右边都-x int m; cin &gt;&gt; m; while(m--){ int l, r, x; cin &gt;&gt; l&gt;&gt; r&gt;&gt; x; // 进行差分标记 diff[l]+=x, diff[r+1]-=x; } // 对差分数组进行前缀和得出结果 for (int i = 1; i &lt;=n; i++) { a[i] = a[i-1] +diff[i]; } // 再进行前缀和以应对接下来的访问 for (int i = 1; i &lt;= n; i++) { prefix[i] = prefix[i-1]+a[i]; } // 访问 int q; cin &gt;&gt; q; while (q--){ int l, r ; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; prefix[r]-prefix[l-1]; } return 0; } 二维差分 给定长n,宽m的矩阵，从(xi,yi)到(xj,yj)执行m次操作，使两点间矩形中的值都加一个value，操作结束后，询问矩阵 大体思路与一维差分差不多 差分矩阵 定义一个差分矩阵：d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1] 或者可以将差分矩阵中的元素一个个插入： 即若原矩阵(x,y)处值为value，则相当于从左上角(x,y) 到右下角(x,y)都加value,也可以使用差分标记实现 差分标记 对于二位差分区间修改：[(xi,yi),(xj,yj)]+valued[xi][yi]+value, d[xj+1][yi]-value, d[xi][yj+1]-value, d[xj+1][yj+1]+value 原理如图： 板子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; using namespace std; const int N = 10000; int n,m,cnt=0; int a[N][N]; int prefix[N][N]; int d[N][N]; // 差分标记 &amp;&amp;初始化差分矩阵 void add(int x1, int y1, int x2, int y2,int value){ d[x1][y1]+=value; d[x2+1][y1]-=value; d[x1][y2+1]-=value; d[x2+1][y2+1]+=value; } int main(){ cin &gt;&gt; n &gt;&gt;m &gt;&gt; cnt; // 输入每个数并计算差分矩阵 for (int i = 1; i &lt;=n; i++){ for (int j = 1;j &lt;=m; j++){ cin &gt;&gt; a[i][j]; add(i,j,i,j,a[i][j]); } } // 进行差分标记 for (int i = 1; i &lt;=cnt;i++){ int x1,y1,x2,y2,value; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2&gt;&gt;value; add(x1,y1,x2,y2,value); } // 对差分数组进行一次前缀和得到结果 for (int i = 1 ;i &lt;=n;i++){ for (int j = 1;j &lt;=m;j++){ a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + d[i][j]; } } for (int i = 1;i &lt;= n; i++){ for (int j = 1; j &lt;= m; j++){ cout &lt;&lt; a[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【Python】CS61A——Containers","slug":"CS61A——Containers","date":"2025-02-25T08:44:27.451Z","updated":"2025-02-25T08:45:19.402Z","comments":true,"path":"2025/02/25/CS61A——Containers/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Containers/","excerpt":"","text":"Containers Slicing 切片可以简洁的获取列表中的子列表，实质是创建了新的列表而不影响原始列表 如列表odds = [3,5,7,9,11] odds[1:3] -&gt; [5,7] 默认也是包括起始值不包括结束值 odds[:3] -&gt; [3,5,7] 省略开头将从列表头开始算起 odds[1:] -&gt; [5,7,9,11] 省略结尾将覆盖至列表尾 内置函数 sum sum(&lt;可迭代对象&gt;, [起始值]) 返回所有可迭代元素和并加上起始值，起始值默认为0 sum还可以实现列表相加：sum([[2,3],[4]],[]) 注意起始值类型要和前面相同 max max(&lt;可迭代对象&gt;, [键函数]) max(a,b,c,..., [键函数]) 返回对象中的最大值或返回若干值中的最大值 键函数：考虑对每个元素执行键函数并根据返回值比较大小（返回原始值） e.g. max(range(10), key=lambda x: 7-(x-4)*(x-2)) all all(&lt;可迭代对象&gt;) 对每个元素执行bool(x)操作，若所有元素都返回True则返回True，否则返回False，空列表返回True e.g. all([x&lt;5 for x in range(5)]) 返回True len len(&lt;可迭代对象&gt;) 获取某个序列长度 有关string string可以用于表示：数据、语言、程序 表示字符串 使用单引号 使用双引号 使用一对连续的三个双引号：可以跨行 string也是一种sequence 求解长度与选择元素与列表相同 获取到的string中的元素本身也是一个字符串，但只有它本身一个元素 in与not in可以在字符串中寻找连续字符 e.g. 'here' in 'where's waldo? 返回True Dictionary dictionary用于存储键值对，使用花括号和冒号分隔键值 创建： numerals = {'I':1, 'V':5, 'X':10} 可以用数字，字符串当键值，列表或字典 当值 注意：键本身不能是列表或字典，键不能重复 查找： 输入对应的键来查找对应的值，但不能通过值查找键 numerals['V'] &gt;&gt;&gt; 5 遍历： dictionary是键的序列，通过list()创建列表可以获得所有的键，因此可以用for循环遍历所有的键 使用numerals.value()获得字典中所有的值，存储在一个序列中（非列表） Dictionary Comprehensions 可以使用表达式来创建列表 格式：{&lt;key exp&gt;: &lt;val exp&gt; for &lt;name&gt; in &lt;iter exp&gt; if &lt;filter exp&gt;} 过程： 添加以当前作用域为父作用域的新作用域 建立一个空的result字典存储表达式的值 对每个中的元素： 在新作用域中将绑定到每一个元素 若为真，则将与配对并添加到result字典中 e.g. {x*x: x for x in [1,2,3,4,5] if x&gt;2} 结果为{9:3, 16:4, 25:3}","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Sequence","slug":"CS61A——Sequence","date":"2025-02-25T08:44:27.448Z","updated":"2025-02-25T07:38:25.423Z","comments":true,"path":"2025/02/25/CS61A——Sequence/","permalink":"https://izayoisakuye.github.io/2025/02/25/CS61A%E2%80%94%E2%80%94Sequence/","excerpt":"","text":"Sequence Lists 列表是python中的内置数据类型 使用[]创建列表 使用赋值语句命名列表 使用name[下标]访问列表元素(0-index)，或使用getitem( ,)(operator模块)来访问元素 使用len()函数获取元素个数 name[下标]是一种元素评估表达式，可以依次评估下标对应元素 列表中的元素可以是表达式，此时列表中的值将绑定为表达式的结果 digits = [2//2,2+2,2,2*2] 列表间可以相加与相乘（运算符或函数） [2,7]+[1,8,2,8]*2 == [2,7,1,8,2,8,1,8,2,8] 列表中的元素可以是任何东西，包括列表 12pairs = [[10,20],[30,40]] pairs[1][0] # 结果是30 in运算符 in运算符可以判断某元素是否存在于列表中 not in 运算符可以判断某元素是否不存在于列表中 返回值为True 或 False 这两个运算符寻找的是单独元素，而非子序列 e.g. 123456789digits = [1,8,2,8] &gt;&gt;&gt; 1 in digits True &gt;&gt;&gt; '1' in digits False &gt;&gt;&gt; [1,2] in [[1,2],3,4] True &gt;&gt;&gt; [1,2] in [[[1,2],3],4] False For Statement 执行过程 12for &lt;name&gt; in &lt;expression&gt;: &lt;suite&gt; 执行，该表达式必须是一个可迭代的量（如一个序列） 对序列中的每个元素，按序进行如下操作： 在当前作用域中将每个元素赋给 执行语句块中的语句 ### 序列解包 e.g.寻找序列中相同元素的数对 pairs = [[1,2],[2,2],[3,2],[4,4]] 123for x, y in paris: if x==y: same_count+=1 该循环中，for循环会自动将paris中的内层列表中的两个元素赋给x,y两个变量 Ranges range是表示连续整数的序列，通过给出起始与结束值获得范围内的整数 range包括起始值而不包括结束值 用法：range(&lt;起始值(默认为0)&gt;, &lt;结束值&gt;, [步长]) 作用： 计算长度：结束值-起始值 选择元素：起始值+index 作为计数器：用_等当作name而不实际使用它 转换列表：使用list() - 列表构造函数 List Comprehension 列表中可以写一些语句来构造列表 e.g.1 12345&gt;&gt;&gt; odds = [1,3,5,7,9] &gt;&gt;&gt; [x+1 for x in odds] [2,4,6,8,10] &gt;&gt;&gt; [x for x in odds if 25%x == 0] [1,5] e.g.2 查找某个数的因数 12def divisors(n): return [1]+[x for x in range(2,n) if n%x==0]","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Homework3","slug":"CS61A——Homework3","date":"2025-02-05T08:58:25.385Z","updated":"2025-02-05T09:00:31.656Z","comments":true,"path":"2025/02/05/CS61A——Homework3/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Homework3/","excerpt":"","text":"Homework 3 Q1: Num Eights 用递归函数求一个数中有几位8 12345678910111213141516171819202122232425262728def num_eights(n): \"\"\"Returns the number of times 8 appears as a digit of n. &gt;&gt;&gt; num_eights(3) 0 &gt;&gt;&gt; num_eights(8) 1 &gt;&gt;&gt; num_eights(88888888) 8 &gt;&gt;&gt; num_eights(2638) 1 &gt;&gt;&gt; num_eights(86380) 2 &gt;&gt;&gt; num_eights(12345) 0 &gt;&gt;&gt; num_eights(8782089) 3 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all assignment statements &gt;&gt;&gt; check(HW_SOURCE_FILE, 'num_eights', ... ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'For', 'While']) True \"\"\" if n==0: return 0 else: if n%10 ==8: return num_eights(n//10)+1 else: return num_eights(n//10) 递归出口：每一位都减完后n==0时 每次返回时递归调用自身，传入未判断的部分 若发现该位是8，则返回值加一，否则不变 Q2: Digit Distance 用递归函数求每两位的差的绝对值之和 12345678910111213141516171819202122232425def digit_distance(n): \"\"\"Determines the digit distance of n. &gt;&gt;&gt; digit_distance(3) 0 &gt;&gt;&gt; digit_distance(777) 0 &gt;&gt;&gt; digit_distance(314) 5 &gt;&gt;&gt; digit_distance(31415926535) 32 &gt;&gt;&gt; digit_distance(3464660003) 16 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all loops &gt;&gt;&gt; check(HW_SOURCE_FILE, 'digit_distance', ... ['For', 'While']) True \"\"\" if n&lt;10: return 0 else: res,last = n//10,n%10 sec_last = res%10 return digit_distance(res)+abs(sec_last-last) 递归出口：当查到最后一位时绝对值为0，返回0 否则将最后一位与倒数第二位取出，将取完最后一位的剩余部分传入递归函数继续判断，返回值加上两位数绝对值之差 Q3: Interleaved Sum 写一个函数，要求对1-n中的所有奇数传入odd_func，所有偶数传入even_func，返回所有数计算后和 123456789101112131415161718192021222324252627def interleaved_sum(n, odd_func, even_func): \"\"\"Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up to n. &gt;&gt;&gt; identity = lambda x: x &gt;&gt;&gt; square = lambda x: x * x &gt;&gt;&gt; triple = lambda x: x * 3 &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1 + 2*2 + 3 + 4*4 + 5 29 &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2 + 3*3 + 4 + 5*5 41 &gt;&gt;&gt; interleaved_sum(4, triple, square) # 1*3 + 2*2 + 3*3 + 4*4 32 &gt;&gt;&gt; interleaved_sum(4, square, triple) # 1*1 + 2*3 + 3*3 + 4*3 28 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and % True \"\"\" def check_num(k): if k&gt;n: return 0 elif k==n: return odd_func(k) else: return check_num(k+2)+odd_func(k)+even_func(k+1) return check_num(1) 由于题目不让使用循环与取模运算判断奇偶，我们只能使用递归函数 由于奇数与偶数是分开的，我们可以发现，奇数+2=奇数，奇数+1=偶数 因此我们可以写一个内嵌函数，让一个计数变量k从1开始，将k传入odd_func，k+1传入even_func 然后递归调用该函数从k+2开始 递归出口即k&gt;n或k=n（此时k一定为奇数，直接传入odd_func并返回） Q4: Count Coins 给予n刀乐，把他分为面值分别为1刀乐，5刀乐，10刀乐，25刀乐的四种货币，输出分法数 1234567891011121314151617181920212223242526272829def count_coins(total): \"\"\"Return the number of ways to make change using coins of value of 1, 5, 10, 25. &gt;&gt;&gt; count_coins(15) 6 &gt;&gt;&gt; count_coins(10) 4 &gt;&gt;&gt; count_coins(20) 9 &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar? 242 &gt;&gt;&gt; count_coins(200) 1463 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(HW_SOURCE_FILE, 'count_coins', ['While', 'For']) True \"\"\" def cal(total,spl_coin): if total==0: return 1 elif total&lt;0: return 0 elif spl_coin==None: return 0 else: with_coin = cal(total-spl_coin,spl_coin) without_coin = cal(total,next_smaller_coin(spl_coin)) return with_coin+without_coin return cal(total,25) Q5: Towers of Hanoi 实现汉诺塔游戏并描述每次移动过程 12345678910111213141516171819202122232425262728293031323334353637def move_stack(n, start, end): \"\"\"Print the moves required to move n disks on the start pole to the end pole without violating the rules of Towers of Hanoi. n -- number of disks start -- a pole position, either 1, 2, or 3 end -- a pole position, either 1, 2, or 3 There are exactly three poles, and start and end must be different. Assume that the start pole has at least n disks of increasing size, and the end pole is either empty or has a top disk larger than the top n start disks. &gt;&gt;&gt; move_stack(1, 1, 3) Move the top disk from rod 1 to rod 3 &gt;&gt;&gt; move_stack(2, 1, 3) Move the top disk from rod 1 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 3 &gt;&gt;&gt; move_stack(3, 1, 3) Move the top disk from rod 1 to rod 3 Move the top disk from rod 1 to rod 2 Move the top disk from rod 3 to rod 2 Move the top disk from rod 1 to rod 3 Move the top disk from rod 2 to rod 1 Move the top disk from rod 2 to rod 3 Move the top disk from rod 1 to rod 3 \"\"\" assert 1 &lt;= start &lt;= 3 and 1 &lt;= end &lt;= 3 and start != end, \"Bad start/end\" def hanoi(n,start,mid,end): if n == 1: print_move(start, end) return else: hanoi(n - 1, start,end, mid) hanoi(1,start,mid,end) hanoi(n - 1, mid, start,end) return hanoi(n,start,6-start-end,end) 详见五点七边讲解视频","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Tree Recursion","slug":"CS61A——Tree Recursion","date":"2025-02-05T08:57:40.975Z","updated":"2025-02-05T08:57:00.742Z","comments":true,"path":"2025/02/05/CS61A——Tree Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Tree%20Recursion/","excerpt":"","text":"Tree Recursion Order of Recursive Calls e.g.1:Cascade 1234567def cascade(n): if n&lt;10: print(n) else: print(n) cascade(n//10) print(n) 结果为 12345678910&gt;&gt;&gt; cascade(12345) 12345 1234 123 12 1 12 123 1234 12345 首先一直调用cascade到底，返回None，从调用入口出来后继续执行cascade下面的语句 cascade 还可以缩短为以下 12345def cascade_short(n): print(n) if n&gt;10: cascade(n//10) print(n) e.g.2:Inverse Cascade 123456789101112def inverse_cascade(n): grow(n) print(n) shrink(n) def f_then_g(f,g,n): if n: f(n) g(n) grow = lambda n: f_then_g(grow,print,n//10) shrink = lambda n: f_then_g(print,shrink,n//10) grow先进行处理，每次将数字缩短一节，到达递归底部后退出时便是从小到大依次输出 shrink先打印出来当前n，然后将数字缩短一节，这样递归过程便实现了从大到小依次输出 Tree Recursion 当递归函数对自身调用超过一次时，发生树形递归，产生树状过程 e.g.1 斐波那契数列 树形斐波那契 1234567def fib(n): if n==0: return 0 elif n==1: return 1 else: return fib(n-1)+fib(n-2) e.g.2 计算分区 将正整数n分为大小不超过m的分区的方式有多少种，即n能以多少种方式表示为递增的不超过m部分之和 e.g. count_partitions(6,4) 有以下可能： …… 分为两种情况考虑： 至少分一个4 不分4 这样我们可以把递归问题拆分为两个小问题，将两种情况相加 count_partitions(2,4) count_partitions(6,3) 以此类推，count_partitions(6,3)按同样方式考虑，分3与不分3，直到递归底部 1234567891011def count_partitions(n,m): if n==0: return 1 elif n&lt;0: return 0 elif m==0: return 0 else: with_m = count_partitions(n-m,m) without_m = count_partitions(n,m-1) return with_m+without_m","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Recursion","slug":"CS61A——Recursion","date":"2025-02-05T08:57:40.973Z","updated":"2025-02-05T08:56:45.164Z","comments":true,"path":"2025/02/05/CS61A——Recursion/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Recursion/","excerpt":"","text":"Recursion Recursive Functions 定义：在函数体中直接或间接调用自身的函数叫递归函数 即在执行函数体时还会调用若干次函数自身 递归函数的结构： def头定义 条件语句用来判断基本条件，无递归调用（递归出口） 递归条件用来递归调用 判断递归是否正确： 验证基本条件 将递归函数看作函数抽象 假设f(n-1)正确，验证f(n)的正确性 e.g.1:用递归求各位数字和 1234567891011def split(n): \"\"\"把n分成最后一位与其他位两部分\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"求和各位数字\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last e.g.2:阶乘（使用diagram） 阶乘 递归与迭代 递归与迭代 递归转换到迭代：弄清需要通过迭代保持的状态 迭代转换到递归：迭代保持的状态可以通过参数传递 互递归（Mutual Recursion） e.g. Luhn Algorithm 改算法常用于信用卡等的校验码计算，步骤如下： 步骤 1：反转数字 算法首先通过反转您正在检查的数字的数字。 步骤 2：每隔一个数字翻倍 从左侧的第一个数字开始（由于反转，现在是原始数字的最后一个数字），对每个第二个数字进行翻倍。 步骤 3：求乘积的数字之和 如果翻倍后的数字大于 9，则将乘积的数字相加（例如，翻倍 8 得到 16，因此相加 1 + 6 = 7）。 步骤 4：将所有数字相加 在上述操作后，将所有数字相加。 步骤 5：检查是否能被 10 整除 如果总和能被 10 整除（即以 0 结尾），则该数字根据 Luhn 算法是有效的。否则，它是无效的。 1234567891011121314151617181920212223242526def split(n): \"\"\"把n分成最后一位与其他位两部分\"\"\" return n//10, n%10 def sum_digits(n): \"\"\"求和各位数字\"\"\" if n&lt;10: return n else: all_but_last,last = split(n) return sum_digits(all_but_last)+last def luhn_sum(n): if n&lt;10: return n else: all_but_last, last = split(n) return luhn_sum_double(all_but_last)+last def luhn_sum_double(n): all_but_last, last = split(n) luhn_digit = sum_digits(2*last) if n&lt;10: return luhn_digit else: return luhn_sum(all_but_last)+luhn_digit 这里使用互递归让分离出来的数字奇数位不执行乘二操作，偶数位执行乘二操作","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Functional Abstraction","slug":"CS61A——Design","date":"2025-02-05T08:57:40.971Z","updated":"2025-02-05T08:57:28.693Z","comments":true,"path":"2025/02/05/CS61A——Design/","permalink":"https://izayoisakuye.github.io/2025/02/05/CS61A%E2%80%94%E2%80%94Design/","excerpt":"","text":"Functional Abstraction Lambda表达式所在的environment关系 如下例子 12345a = 1 def f(g): a = 2 return lambda y:a*g(y) f(lambda y: a+y)(a) 注意行4与行5的lambda函数的区别： 行4的lambda函数是f函数内定义的函数，他的父级为f，因此此时传入的a=2 行5的lambda函数是f函数外定义的函数，他的父级为global，因此此时传入的a=1 Choosing Names 给函数或变量命名时，要注重传达意思 命名需要传达与之相关值的意义或目的 值的类型最好记录在函数的docstring中 函数名一般包括它们的作用，表现或返回值 为一些重复使用的复合表达式命名 如果需要注释代码，命名可以长一些 如果用于数字，数学运算与函数抽象，命名可以短一些 Error&amp;Traceback 报错有三种形式： Syntax errors：执行前即可发现，通常由于表达式不正确引起 Runtime errors：执行时由python解释器发现的错误。当这些错误发生时，会得到一个Traceback，来提示是在哪里发生了何种错误，错误发生时程序在做什么 Logical error：不会被解释器发现，需要自己进行测试发现问题 Decorator 装饰器用于给现有模块（原函数）进行功能拓展，通过接受一个函数来返回一个新的函数或修改原来的函数 例如： 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced @trace1 def square(x): return x*x 等同于 12345678910111213def trace1(fn): \"\"\" return a version of fn that first print before it is called fn - a function of 1 argument \"\"\" def traced(x): print(\"Calling\",fn,\"on argument\",x) return fn(x) return traced def square(x): return x*x square = trace1(square) 返回值都相同 123&gt;&gt;&gt; square(5) Calling &lt;function square at 0x000001C1247A9240&gt; on argument 5 25","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【算法】KMP","slug":"KMP","date":"2025-02-03T13:17:16.129Z","updated":"2025-02-03T13:18:42.295Z","comments":true,"path":"2025/02/03/KMP/","permalink":"https://izayoisakuye.github.io/2025/02/03/KMP/","excerpt":"","text":"KMP 给予主串S与模式串P，寻找模式串在主串中是否出现过以及出现位置 匹配过程 设主串S：abcxabcdabxabcdabcdabcy，模式串P：abcdabcy 构建Next数组 针对模式串P，我们有一个Next数组，Next[i]指P[0…i]的最长公共前后缀的长度 如例子中P的Next数组为0 0 0 0 1 2 3 0 ，如下表 下标 1 2 3 4 5 6 7 8 字符串 a b c d a b c y 前后缀 a ab abc abcd abcda abcdab abcdabc abcdabcy 最长公共前后缀 / / / / a ab abc / Next[i] 0 0 0 0 1 2 3 0 让两个指针j，i指向P头，让i逐个移动，与j所指的比较，若不同，则j跳转到该位的前一位Next数组值对应的下标，该位Next数组值为0；若相同，则j向右移动一位，该位Next数组值为移动后的j值（即Next[i]=++j） 性质：i+1-Next[i]为前缀循环节的大小 或把P与S合并成一个串，算出Next数组值，若某位值n等于P的长度，说明找到了和P匹配的字串，因为该处合并串的前后缀相同，该位置向前n长度的字串即为P 在构造Next数组时，假如需要计算Next[i]的值，此时前Next[i-1]位相等，记为len-1，若两侧字串加上第len与第i位，字串仍相等，则Next[i]=len+1，若不相等，则寻找第二长的Next，重复判断直到找到最小的Next(len=0) 搜索模式串 用两个指针指向两串头，逐个匹配，当遇到不同字符时，查看该字符前一个字符对应next数组中的值，让模式串指针跳到该值对应的P的下标位置，继续与主串指针逐个匹配 当找到对应模式串在主串出现时，通过i-len(p)+1计算起始位置 注意：整个匹配过程中主串指针不会后退，只会停留；而模式串指针根据next数组反复横条 板子-1 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt; using namespace std; void Next_pre(string p, vector&lt;int&gt; &amp;Next){ for(int i = 1,j=0;i&lt;p.size();i++){ // i是当前遍历到的后缀 while(j&amp;&amp;p[i]!=p[j]) j=Next[j-1]; // 两指针指向不同时按Next中值跳转直到跳到0 if(p[i]==p[j])j++; // 前后缀一样时，前缀向后移动 Next[i]=j; } } int kmp(string s,string p,int begin){ // begin表示从哪里开始匹配 vector&lt;int&gt; Next(p.size()); Next_pre(p,Next); for(int i = begin,j=0;i&lt;s.size();i++){ while(j&amp;&amp;s[i]!=p[j]) j=Next[j-1]; // 两指针指向不同时按Next中值跳转直到跳到0 if (s[i]==p[j])j++; // 前后缀一样时，前缀向后移动 if (j==p.size()){ // 匹配成功后的操作 // 该部分操作按题目要求 return i-p.size()+1; } } return -1; } int main(){ string s,p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; kmp(s,p,0); return 0; } 板子-2 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt; using namespace std; int kmp(string s,string p){ int n = s.size(); int m = p.size(); string mer = p+'#'+s; vector&lt;int&gt; Next(mer.size()); for (int i = 1;i&lt;mer.size();i++){ int len = Next[i-1]; while(len&amp;&amp;mer[i]!=mer[len]) len = Next[len-1]; if (mer[i]==mer[len]){ Next[i]=len+1; if (Next[i]==m){ return i-m*2; } } } return -1; } int main(){ string s,p; cin &gt;&gt; s&gt;&gt;p; cout &lt;&lt; kmp(s,p); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【数据结构】字典树","slug":"字典树","date":"2025-02-01T09:02:16.436Z","updated":"2025-02-03T13:18:56.752Z","comments":true,"path":"2025/02/01/字典树/","permalink":"https://izayoisakuye.github.io/2025/02/01/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"字典树(trie) 给予n个单词，在这n个单词中查询给定的单词是否存在 遍历 使用string遍历每一个单词比较，s1==s2，时间复杂度为，m为单词长度 若询问q次，则复杂度高达 字典树 字典树是一种树形结构，树的每个节点上存储了一个字符 标红的节点表示存在一个以该节点字符结尾的字符串 可以发现，以某个字符结尾的字符串在trie树上是唯一的，因为该节点只有一个父节点，沿着往上即可获得唯一的字符串。 还可以发现，若按照前序遍历，每个节点的字符是按字典序排列的，故trie树还可以用于排序 建树 建立一个根节点，将字符串每一个字符依次从根节点插入，若存在对应字符节点便沿用，否则在上个父节点基础上新建节点，传入结尾位置时标记（是否结尾或第几个相同单词） 时间复杂度 询问 将读入的字符串从根节点开始一个个字符比对，若某个字符在同层节点中都没有则不存在该字符串，若到达该字符串末尾，但此时节点并未标记结尾位置，也判断为不存在该字符串。否则判断为存在 时间复杂度：，x为每次询问字符串长度，共q次询问 删除 判断是否有子节点 若没有子节点，标记不为一时-1，为1时递归删除到根节点 存储 用数组表示层数，每层再用数组表示26个字符在该层出现的次数 缺点：若字符少可行，若字符数过多，或每层分配的节点过多，占用空间会过大 时间换空间：使用map或unordered_map，但时间复杂度会变高 板子 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; // 开辟空间 struct trieNode{ char val; trieNode** son; int cnt; trieNode(char c){ val = c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; // 插入操作 void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c])p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; } p-&gt;cnt++; } // 查询操作 int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main(){ root = new trieNode(' '); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 int trie[M][N]; int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } map实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 26; const int M = 105; // 开辟空间 vector&lt;map&lt;char,int&gt;&gt; trie; // 或使用unordered_map int cnt[M]; int idx = 0; // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c])trie[p][c]=++idx; p = trie[p][c]; } cnt[p]++; } // 查询操作 int query(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = s[i]-'a'; if (!trie[p][c]) return 0; p = trie[p][c]; } return cnt[p]; } int main(){ trie = vector&lt;map&lt;char,int&gt;&gt;(M); for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;5;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } return 0; } 应用-查询前缀 题目描述 给定 个模式串 和 次询问，每次询问给定一个文本串 ，请回答 中有多少个字符串 满足 是 的前缀。 一个字符串 是 的前缀当且仅当从 的末尾删去若干个（可以为 0 个）连续的字符后与 相同。 输入的字符串大小敏感。例如，字符串 Fusu 和字符串 fusu 不同。 输入格式 本题单测试点内有多组测试数据。 输入的第一行是一个整数，表示数据组数 。 对于每组数据，格式如下： 第一行是两个整数，分别表示模式串的个数 和询问的个数 。 接下来 行，每行一个字符串，表示一个模式串。 接下来 行，每行一个字符串，表示一次询问。 输出格式 按照输入的顺序依次输出各测试数据的答案。 对于每次询问，输出一行一个整数表示答案。 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 3e6 + 10; const int M = 70; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int trie[N][M]; int cnt[N]; int idx = 0; // char到int的转换 int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } // 插入操作 void insert(string s){ int p = 0; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!trie[p][c]) trie[p][c]=++idx; p=trie[p][c]; cnt[p]++; // 这里与查询整个单词不同，需要每层计数 } } // 询问操作 int query(string s){ int p = 0; //int sum = 0; for (int i = 0;i&lt;s.size();i++){ int c =ascii(s[i]); if (!trie[p][c]) return 0; p=trie[p][c]; // sum+=cnt[p]; } return cnt[p]; } int main() { ios cin &gt;&gt; t; while(t--){ int n , q; cin &gt;&gt; n &gt;&gt; q; // 每次清空使用过的部分 for (int i = 0;i&lt;=idx;i++){ for (int j = 0;j&lt;=M;j++){ trie[i][j]=0; } } for(int i = 0;i&lt;=idx;i++){ cnt[i]=0; } idx = 0; for (int i = 0; i&lt;n;i++){ string s; cin &gt;&gt; s; insert(s); } for (int i = 0;i&lt;q;i++){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s) &lt;&lt; endl; } } return 0; } 缺点是每次查询后数组重置时容易TLE，解决方法为只清空使用的部分 结构体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 63; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; struct trieNode{ char val; int cnt; trieNode** son; trieNode(char c){ val =c; son = new trieNode*[N]; for (int i = 0;i&lt;N;i++) son[i]=nullptr; cnt = 0; } }; trieNode* root; int ascii(char c){ if (c&gt;='a'&amp;&amp; c&lt;='z') return c-'a'+26; else if (c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'; else return c-'0'+52; } void insert(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) p-&gt;son[c] = new trieNode(c); p = p-&gt;son[c]; p-&gt;cnt++; } } int query(string s){ trieNode* p = root; for (int i = 0;i&lt;s.size();i++){ int c = ascii(s[i]); if (!p-&gt;son[c]) return 0; p = p-&gt;son[c]; } return p-&gt;cnt; } int main() { ios cin &gt;&gt; t; while(t--){ int n,q; cin &gt;&gt; n &gt;&gt; q; root = new trieNode(' '); while(n--){ string s; cin &gt;&gt; s; insert(s); } while(q--){ string s; cin &gt;&gt; s; cout &lt;&lt; query(s)&lt;&lt;endl; } } return 0; } 缺点是滥用指针容易MLE，解决方法为N开小一点（差点炸的程度）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【Python】CS61A——Lab2","slug":"CS61A——Lab2","date":"2025-01-30T13:44:27.000Z","updated":"2025-01-30T14:56:07.204Z","comments":true,"path":"2025/01/30/CS61A——Lab2/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Lab2/","excerpt":"","text":"WWPD部分省略 Composite Identity Function 题意：写一个函数，传入f与g两个函数，返回一个含有参数x的函数，用于判断是否等于 123456789101112131415def composite_identity(f, g): \"\"\" Return a function with one parameter x that returns True if f(g(x)) is equal to g(f(x)). You can assume the result of g(x) is a valid input for f and vice versa. &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 # squares x [returns x^2] &gt;&gt;&gt; b1 = composite_identity(square, add_one) &gt;&gt;&gt; b1(0) # (0 + 1) ** 2 == 0 ** 2 + 1 True &gt;&gt;&gt; b1(4) # (4 + 1) ** 2 != 4 ** 2 + 1 False \"\"\" return lambda x: f(g(x))==g(f(x)) 按照题意返回一个lambda函数，传入x即可 Count Cond predicate function: 返回True或False的函数 题意：写一个函数，传入一个两个参数的predicate function condition，返回一个含有参数n的函数，判断1-n中有几个数满足condition函数 1234567891011121314151617181920212223242526272829303132def count_cond(condition): \"\"\"Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_fives = count_cond(lambda n, i: sum_digits(n * i) == 5) &gt;&gt;&gt; count_fives(10) # 50 (10 * 5) 1 &gt;&gt;&gt; count_fives(50) # 50 (50 * 1), 500 (50 * 10), 1400 (50 * 28), 2300 (50 * 46) 4 &gt;&gt;&gt; is_i_prime = lambda n, i: is_prime(i) # need to pass 2-argument function into count_cond &gt;&gt;&gt; count_primes = count_cond(is_i_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 \"\"\" def judge(n): cnt = 0 for i in range(1,n+1): if condition(n,i): cnt+=1 return cnt return judge 遍历1-n，传入condition函数并计数即可 注意返回的是函数，传入n Multiple 题意：写一个函数求参数a，b的最小公倍数 12345678910111213def multiple(a, b): \"\"\"Return the smallest number n that is a multiple of both a and b. &gt;&gt;&gt; multiple(3, 4) 12 &gt;&gt;&gt; multiple(14, 21) 42 \"\"\" def gcd(a,b): if b==0: return a return gcd(b,a%b) return a*b//gcd(a,b) 辗转相除法求gcd，用gcd求lcm I Heard You Liked Functions… 题意：定义一个函数传入三个函数f1,f2,f3，返回一个参数为n的函数g，函数g返回一个参数为x的函数h 函数x将会循环传给函数f1，f2，f3，具体如下： n=0时返回x，n=1时返回f1(x)，n=2时返回f2(f1(x))，n=3时返回f3(f2(f1(x)))，n=4时返回f1(f3(f2(f1(x))))，以此类推 12345678910111213141516171819202122232425262728293031323334353637383940414243def cycle(f1, f2, f3): \"\"\"Returns a function that is itself a higher-order function. &gt;&gt;&gt; def add1(x): ... return x + 1 &gt;&gt;&gt; def times2(x): ... return x * 2 &gt;&gt;&gt; def add3(x): ... return x + 3 &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3) &gt;&gt;&gt; identity = my_cycle(0) &gt;&gt;&gt; identity(5) 5 &gt;&gt;&gt; add_one_then_double = my_cycle(2) &gt;&gt;&gt; add_one_then_double(1) 4 &gt;&gt;&gt; do_all_functions = my_cycle(3) &gt;&gt;&gt; do_all_functions(2) 9 &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4) &gt;&gt;&gt; do_more_than_a_cycle(2) 10 &gt;&gt;&gt; do_two_cycles = my_cycle(6) &gt;&gt;&gt; do_two_cycles(1) 19 \"\"\" def g(n): def h(f,g): return lambda x: f(g(x)) if n==0: return lambda x : x elif n==1: return f1 else: temp = f1 i=2 while i&lt;=n: if i%3==1: temp= h(f1,temp) elif i%3==2: temp= h(f2,temp) else: temp= h(f3,temp) i+=1 return temp return g 遍历1-n，每次取模3来判断该套哪个函数，注意0和1时特判，2开始从f1往外套 即执行顺序为","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Hog","slug":"Project1-Hog","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:08.930Z","comments":true,"path":"2025/01/30/Project1-Hog/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project1-Hog/","excerpt":"","text":"Project1-Hog 实现一个掷骰子游戏 规则 两位玩家依次掷任意数量(不多于10个)骰子，点数之和先达到GOAL的胜利。 Sow Sad: 若其中一个骰子点数为一，则该玩家此轮得分为1 Boar Brawl: 玩家可以选择不掷骰子，得分为max(1,3*abs(对手得分十位数-自己得分个位数))，位数不够补零。 Sus Fuss: 若一局结束后，玩家点数数值有三或四个因数(包括1和点数本身)，该玩家点数会变为比当前数值大的最近的一个质数 Phase 1: Rules of the Game 模拟游戏的进行 Problem 0 熟悉dice.py，了解骰子的生成 make_fair_dice()用于生成每面概率相等的SIDE面骰子 make_test_dice()用于测试循环投出一系列指定值 掷出一次骰子的方法：调用生成骰子赋值给的变量e.g. six_sided() Problem 1 实现掷骰子函数，并实现规则Sow Sad 在定义函数时，若出现形参后已经赋值的情况，该值代表该函数不传入参数时形参默认值 如def roll_dice(num_rolls, dice=six_sided)，若不传入dice参数则默认为six_sided roll_dice()函数： 参数： num_rolls指掷骰子次数 dice指传入的骰子（默认值为六面骰子） 理解： 该函数返回的是num_roll次结果之和，若其中有1则返回1 若上次调用函数掷骰子次数少于掷骰子次数，则下次掷骰子时会接着上次开始而非从头开始 在循环中return语句会结束一个循环 My code： 1234567891011121314151617181920212223def roll_dice(num_rolls, dice=six_sided): \"\"\"Simulate rolling the DICE exactly NUM_ROLLS &gt; 0 times. Return the sum of the outcomes unless any of the outcomes is 1. In that case, return 1. num_rolls: The number of dice rolls that will be made. dice: A function that simulates a single dice roll outcome. Defaults to the six sided dice. \"\"\" # These assert statements ensure that num_rolls is a positive integer. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt; 0, 'Must roll at least once.' # BEGIN PROBLEM 1 total = 0 flag = 0 for i in range(num_rolls): temp = dice() if temp==1: flag = 1 total += temp if flag: return 1 else: return total # END PROBLEM 1 Problem 2 实现规则Boar Brawl boar_brawl()函数： 参数： player_score：自己的分数 opponent_score：对手的分数 理解： 获取自己分数的个位数与对手分数的十位数 相减并取绝对值后乘三 若小于1则输出1，否则输出计算结果 My code： 1234567891011121314151617def boar_brawl(player_score, opponent_score): \"\"\"Return the points scored by rolling 0 dice according to Boar Brawl. player_score: The total score of the current player. opponent_score: The total score of the other player. \"\"\" # BEGIN PROBLEM 2 player_one = player_score%10 opponent_ten = opponent_score%100//10 result = 3*abs(opponent_ten-player_one) if result&gt;=1: return result else: return 1 # END PROBLEM 2 注意：传入的参数不一定是十位数，需要进行一些处理 Problem 3 实现函数，将前两个规则结合，输出正确结果 take_turn()函数： 参数： num_rolls：掷骰子次数 player_score：自己的分数 opponent_score：对手的分数 dice：使用的骰子 理解： 若num_rolls&gt;0，则按照正常规则进行，获得本轮掷骰点数之和 若num_rolls=0，即不掷骰子，等同于选择使用Boar Brawl规则，执行该函数 My code： 12345678910111213141516171819def take_turn(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the points scored on a turn rolling NUM_ROLLS dice when the player has PLAYER_SCORE points and the opponent has OPPONENT_SCORE points. num_rolls: The number of dice rolls that will be made. player_score: The total score of the current player. opponent_score: The total score of the other player. dice: A function that simulates a single dice roll outcome. \"\"\" # Leave these assert statements here; they help check for errors. assert type(num_rolls) == int, 'num_rolls must be an integer.' assert num_rolls &gt;= 0, 'Cannot roll a negative number of dice in take_turn.' assert num_rolls &lt;= 10, 'Cannot roll more than 10 dice.' # BEGIN PROBLEM 3 if num_rolls==0: return boar_brawl(player_score,opponent_score) else: return roll_dice(num_rolls,dice) # END PROBLEM 3 Problem 4 实现Sus Fuss规则 num_factors()函数： 参数： n：要计算的数n 理解： 返回数n的因数个数 1和n本身也算进去 My code： 123456789def num_factors(n): \"\"\"Return the number of factors of N, including 1 and N itself.\"\"\" # BEGIN PROBLEM 4 total = 0 for i in range(1,n+1): if n%i==0: total+=1 return total # END PROBLEM 4 sus_points()函数： 参数： score：某玩家的分数 理解： 该函数用于更新玩家在Sus Fuss规则下新的分数 即用于判断符合条件下大于该分数数值的下一个质数 若该数值不符合条件，则返回本身 My code: 1234567891011def sus_points(score): \"\"\"Return the new score of a player taking into account the Sus Fuss rule.\"\"\" # BEGIN PROBLEM 4 if num_factors(score)==3 or num_factors(score)==4: while True: score+=1 if is_prime(score): return score else: return score # END PROBLEM 4 sus_update()函数： 参数： num_rolls：掷骰子次数 player_score：自己的分数 opponent_score：对手的分数 dice：使用的骰子 理解： 用于输出num_rolls次掷骰子后，考虑以上三种规则后的点数之和 现根据take_turn()函数求出满足前两个规则的本轮分数之和，并累加到当前分数上 再判断此时分数是否满足第三个规则，进行相应分数改动 My code: 12345678def sus_update(num_rolls, player_score, opponent_score, dice=six_sided): \"\"\"Return the total score of a player who starts their turn with PLAYER_SCORE and then rolls NUM_ROLLS DICE, *including* Sus Fuss. \"\"\" # BEGIN PROBLEM 4 score = player_score + take_turn(num_rolls, player_score, opponent_score, dice) return sus_points(score) # END PROBLEM 4 Problem 5 完整实现游戏模拟 play()函数： 参数： strategy0：player0使用的策略 strategy1：player1使用的策略 update：使用的更新函数（有无sus） score0：player0的起始分数 score1：player1的起始分数 dice：使用的骰子 goal：实现游戏结束的数值 理解： strategy指的是玩家掷骰子数量 strategy函数传入自己与对手的分数，根据两者分数得出下次掷骰子数量 使用传入的update函数来决定分数改变策略（是否采用sus fuss规则） My code： 123456789101112131415161718192021222324252627282930313233343536def play(strategy0, strategy1, update, score0=0, score1=0, dice=six_sided, goal=GOAL): \"\"\"Simulate a game and return the final scores of both players, with Player 0's score first and Player 1's score second. E.g., play(always_roll_5, always_roll_5, sus_update) simulates a game in which both players always choose to roll 5 dice on every turn and the Sus Fuss rule is in effect. A strategy function, such as always_roll_5, takes the current player's score and their opponent's score and returns the number of dice the current player chooses to roll. An update function, such as sus_update or simple_update, takes the number of dice to roll, the current player's score, the opponent's score, and the dice function used to simulate rolling dice. It returns the updated score of the current player after they take their turn. strategy0: The strategy for player0. strategy1: The strategy for player1. update: The update function (used for both players). score0: Starting score for Player 0 score1: Starting score for Player 1 dice: A function of zero arguments that simulates a dice roll. goal: The game ends and someone wins when this score is reached. \"\"\" who = 0 # Who is about to take a turn, 0 (first) or 1 (second) # BEGIN PROBLEM 5 while score0&lt;goal and score1 &lt; goal: if who==0: score0 = update(strategy0(score0, score1), score0, score1, dice) else: score1 = update(strategy1(score1, score0), score1, score0, dice) who = 1 - who # END PROBLEM 5 return score0, score1 Phase 2: Strategies 这部分将会根据自己与对手的分数生成每轮玩家的掷骰数（0-10） Problem 6 返回一个函数，获取自己与对手分数并输出指定骰子个数 理解： 返回的是函数，有两个参数：自己与对手分数 无论两者分数多少，返回的总是一开始传入的指定骰子个数 My code： 1234567891011121314151617def always_roll(n): \"\"\"Return a player strategy that always rolls N dice. A player strategy is a function that takes two total scores as arguments (the current player's score, and the opponent's score), and returns a number of dice that the current player will roll this turn. &gt;&gt;&gt; strategy = always_roll(3) &gt;&gt;&gt; strategy(0, 0) 3 &gt;&gt;&gt; strategy(99, 99) 3 \"\"\" assert n &gt;= 0 and n &lt;= 10 # BEGIN PROBLEM 6 return lambda x,y: n # END PROBLEM 6 Problem 7 判断每种分数组合是否都有一种对应的掷骰个数（分数组合指一种自己与对手的分数） is_always_roll()函数： 参数： strategy：掷骰策略 goal：玩家胜利要达到的目标分数 理解： 自己与对手的得分在胜利之前可能性均有100种（0-99），故可能性组合有10000种 该函数实现了判断每种可能性组合下返回的掷骰数是否相同 goal不一定是100 My code： 12345678910111213141516171819def is_always_roll(strategy, goal=GOAL): \"\"\"Return whether STRATEGY always chooses the same number of dice to roll given a game that goes to GOAL points. &gt;&gt;&gt; is_always_roll(always_roll_5) True &gt;&gt;&gt; is_always_roll(always_roll(3)) True &gt;&gt;&gt; is_always_roll(catch_up) False \"\"\" # BEGIN PROBLEM 7 num = strategy(0,0) for i in range(0,goal): for j in range(0,goal): if strategy(i,j)!=num: return False return True # END PROBLEM 7 Problem 8 返回一个函数，用来调用n次掷骰函数，并返回这n次掷骰得到的值之和的平均值 语法特性：*args *args参数允许函数接受任意数量的位置参数，以元组形式传入 args可以改为其他名称，*必须有 应用： 定义的函数接受不定数量位置参数时 编写高阶函数（higher-order function）时，传递参数给内部的定义的函数 make_averaged()函数 参数： original_function：调用的掷骰函数 times_called：调用次数 理解： 函数需要做到执行n次掷骰函数，并将返回值累加，最后求这n次和的平均值 在内联函数中使用了*args来表示若干参数，与调入的掷骰函数参数数量一致 My code： 1234567891011121314151617181920def make_averaged(original_function, times_called=1000): \"\"\"Return a function that returns the average value of ORIGINAL_FUNCTION called TIMES_CALLED times. To implement this function, you will have to use *args syntax. &gt;&gt;&gt; dice = make_test_dice(4, 2, 5, 1) &gt;&gt;&gt; averaged_dice = make_averaged(roll_dice, 40) &gt;&gt;&gt; averaged_dice(1, dice) # The avg of 10 4's, 10 2's, 10 5's, and 10 1's 3.0 \"\"\" # BEGIN PROBLEM 8 def average_cal(*args): suma = 0 for i in range(times_called): suma+=original_function(*args) return suma/times_called return average_cal # END PROBLEM 8 Problem 9 实现函数，枚举掷骰次数（1-10），看哪次的分数平均值最大 max_scoring_num_rolls()函数 参数： dice：使用的骰子 times_called：调用次数 理解 遍历掷骰次数，调用make_averaged函数计算平均值，取1-10掷骰次数中平均值最大值 当平均值相等时取更小的 My code： 123456789101112131415161718def max_scoring_num_rolls(dice=six_sided, times_called=1000): \"\"\"Return the number of dice (1 to 10) that gives the maximum average score for a turn. Assume that the dice always return positive outcomes. &gt;&gt;&gt; dice = make_test_dice(1, 6) &gt;&gt;&gt; max_scoring_num_rolls(dice) 1 \"\"\" # BEGIN PROBLEM 9 maxi = 0 maxc = 0 for i in range(1,11): temp = make_averaged(roll_dice,times_called)(i,dice) if temp &gt; maxc: maxc = temp maxi = i return maxi # END PROBLEM 9 Problem 10 采用Boar Brawl规则，若roll出0时根据该规则得到的分数比threshold大，返回0，否则返回掷骰次数 boar_strategy()函数 参数： score：自己的分数 opponent_score：对手的分数 threshold：阈值分数，若采用boar brawl得到的分数大于它则返回掷骰0次 num_rolls：掷骰次数 理解： boar brawl规则是在掷骰0次下的特殊规则 若采用该规则策略获得的分数要比正常掷骰获得的分数更高，就采用该策略（返回掷骰次数0次） 否则按正常掷骰次数掷骰 My code： 12345678def boar_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice if Boar Brawl gives at least THRESHOLD points, and returns NUM_ROLLS otherwise. Ignore score and Sus Fuss. \"\"\" # BEGIN PROBLEM 10 if boar_brawl(score,opponent_score)&gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 10 Problem 11 采用Sus Fuss规则，若roll出0时根据该规则与Boar Brawl规则得到的分数与起始分数差值比threshold大，返回0，否则返回掷骰次数 sus_strategy()函数 参数： score：自己的分数 opponent_score：对手的分数 threshold：阈值分数，若采用boar brawl得到的分数大于它则返回掷骰0次 num_rolls：掷骰次数 理解： 即在boar brawl规则下采用sus fuss规则得到分数 若采用该规则策略获得的分数要比正常掷骰获得的分数更高，就采用该策略（返回掷骰次数0次） 否则按正常掷骰次数掷骰 My code： 123456def sus_strategy(score, opponent_score, threshold=11, num_rolls=6): \"\"\"This strategy returns 0 dice when your score would increase by at least threshold.\"\"\" # BEGIN PROBLEM 11 if sus_update(0,score,opponent_score) - score &gt;=threshold: return 0 return num_rolls # Remove this line once implemented. # END PROBLEM 11 Problem 12 结合上述所有策略与自己的策略，实现最终策略 My code： 12345678910def final_strategy(score, opponent_score): \"\"\"Write a brief description of your final strategy. *** YOUR DESCRIPTION HERE *** \"\"\" # BEGIN PROBLEM 12 threshold = GOAL-score if score&gt;80 and score-opponent_score&gt;20: return 0 return 6 # Remove this line once implemented. # END PROBLEM 12","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Cat","slug":"Project2-Cat","date":"2025-01-30T13:44:27.000Z","updated":"2025-03-03T11:04:21.217Z","comments":true,"path":"2025/01/30/Project2-Cat/","permalink":"https://izayoisakuye.github.io/2025/01/30/Project2-Cat/","excerpt":"","text":"Project2-Cat 实现一个金山打字通（？） 具体实现：记录打字速度以及自动修正拼写错误的字符 Phase 1: Typing 实现打字以及检测打字速度相关功能 Problem 1 挑选用户打字的段落 pick函数 参数： paragraphs：一串字符串记录了打字内容 select：一个函数，检测段落是否能被选择 k：非负数，作为index 思路： 函数功能实现了用户选择第k个段落作为打字内容 若选择的k没有对应段落则返回空字符串 选择的字符串要符合select函数的条件 符合条件的才能编号第k个字符串 code： 1234567891011121314151617181920212223242526272829def pick(paragraphs, select, k): \"\"\"Return the Kth paragraph from PARAGRAPHS for which SELECT called on the paragraph returns True. If there are fewer than K such paragraphs, return the empty string. Arguments: paragraphs: a list of strings select: a function that returns True for paragraphs that can be selected k: an integer &gt;&gt;&gt; ps = ['hi', 'how are you', 'fine'] &gt;&gt;&gt; s = lambda p: len(p) &lt;= 4 &gt;&gt;&gt; pick(ps, s, 0) 'hi' &gt;&gt;&gt; pick(ps, s, 1) 'fine' &gt;&gt;&gt; pick(ps, s, 2) '' \"\"\" # BEGIN PROBLEM 1 valid_para = [] for s in paragraphs: if select(s): valid_para.append(s) if k&gt;=len(valid_para): return '' else: return valid_para[k] # END PROBLEM 1 Problem 2 通过给定的关键词选取段落 about函数 参数：subject：关键词列表 思路： about函数用于pick函数中的select选项，用于筛选指定关键字的段落 故它返回的是一个select函数，若段落满足条件则返回True否则返回False 单词匹配时不区分大小写，但要是一个完整单词，且不能是单词的字串 可以使用给定的函数remove_punctuation-去除标点，lower-变小写，split-将一句话分割为若干单词存入列表 code： 1234567891011121314151617181920212223242526def about(subject): \"\"\"Return a select function that returns whether a paragraph contains one of the words in SUBJECT. Arguments: subject: a list of words related to a subject &gt;&gt;&gt; about_dogs = about(['dog', 'dogs', 'pup', 'puppy']) &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup!'], about_dogs, 0) 'Cute Dog!' &gt;&gt;&gt; pick(['Cute Dog!', 'That is a cat.', 'Nice pup.'], about_dogs, 1) 'Nice pup.' \"\"\" assert all([lower(x) == x for x in subject]), 'subjects should be lowercase.' # BEGIN PROBLEM 2 def select(para): sp_para = split(remove_punctuation(para)) for i in range(0,len(sp_para)): sp_para[i]=lower(sp_para[i]) for s in subject: if s in sp_para: return True return False return select # END PROBLEM 2 Problem 3 计算已经输入且匹配单词占需要输入内容的百分比 accuracy函数 参数： typed：已经输入的内容 source：需要输入的内容 思路： 按单词顺序匹配指定输入内容，第一个对第一个，第二个对第二个…. 区分大小写，且包含标点符号 若已经输入内容比需要输入内容长，则长的部分认定为不正确 若两者均为空字符串则准确率为100.0，若前者为空后者非空或前者非空后者为空则准确率为0.0 code： 12345678910111213141516171819202122232425262728293031323334353637def accuracy(typed, source): \"\"\"Return the accuracy (percentage of words typed correctly) of TYPED when compared to the prefix of SOURCE that was typed. Arguments: typed: a string that may contain typos source: a string without errors &gt;&gt;&gt; accuracy('Cute Dog!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('A Cute Dog!', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('cute Dog.', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute Dog. I say!', 'Cute Dog.') 50.0 &gt;&gt;&gt; accuracy('Cute', 'Cute Dog.') 100.0 &gt;&gt;&gt; accuracy('', 'Cute Dog.') 0.0 &gt;&gt;&gt; accuracy('', '') 100.0 \"\"\" typed_words = split(typed) source_words = split(source) # BEGIN PROBLEM 3 cnt = 0 for t, s in zip(typed_words, source_words): if t==s: cnt+=1 if len(typed_words)==0 and len(source_words)==0: return 100.0 elif len(typed_words)==0 or len(source_words)==0: return 0.0 else: return (cnt/len(typed_words))*100 # END PROBLEM 3 注意： 同时遍历两个列表时，使用zip函数解包，因为原代码实现的是遍历一个包含两个列表的元组 空字符部分特判，因为计算百分比时可能会导致分母为0 计算的是已经输入字符与需要输入字符匹配的字符个数在已经输入字符中的占比，分母是typed_words的长度 Problem 4 按照words/min计算打字速度 wpm函数 参数： typed：已经输入的内容 elapsed：总共打字时间（按秒计） 思路： wpm的计算是按照字符数来的，单位是每五个字符数，这样可以减少单词长度对结果的影响 字符数时间 code: 1234567891011121314151617def wpm(typed, elapsed): \"\"\"Return the words-per-minute (WPM) of the TYPED string. Arguments: typed: an entered string elapsed: an amount of time in seconds &gt;&gt;&gt; wpm('hello friend hello buddy hello', 15) 24.0 &gt;&gt;&gt; wpm('0123456789',60) 2.0 \"\"\" assert elapsed &gt; 0, 'Elapsed time must be positive' # BEGIN PROBLEM 4 length = len(typed) return (length/5)/(elapsed/60) # END PROBLEM 4 注意：elapsed单位是秒，wpm使用的时间是分钟 Phase 2: Autocorrect 按下空格触发单词自动纠正，若最近的一个词接近正确词汇但不正确，则会用正确词汇替代 Problem 5 返回一个列表，内部提供了几个接近输入单词的正确单词 参数： typed_word：一个字符串，表示输入的单词 word_list：源单词列表 diff_function：评估单词不同程度的函数 limit：单词能否被更改的阈值 思路： autocorrect实现的 若输入字符已经在word_list中，将会直接返回该字符 否则会返回基于diff函数计算的不同程度最小的单词 若输入单词与word_list中最小的不同程度仍大于limit，则返回输入单词 所有输入单词和word_list中的单词都是小写且没有标点 若多个单词与输入字符不同程度最小相同，则返回最靠前的 不同程度可以使用两个单词相同部分长度衡量 code： 123456789101112131415161718192021222324252627282930def autocorrect(typed_word, word_list, diff_function, limit): \"\"\"Returns the element of WORD_LIST that has the smallest difference from TYPED_WORD. If multiple words are tied for the smallest difference, return the one that appears closest to the front of WORD_LIST. If the difference is greater than LIMIT, instead return TYPED_WORD. Arguments: typed_word: a string representing a word that may contain typos word_list: a list of strings representing source words diff_function: a function quantifying the difference between two words limit: a number &gt;&gt;&gt; ten_diff = lambda w1, w2, limit: 10 # Always returns 10 &gt;&gt;&gt; autocorrect(\"hwllo\", [\"butter\", \"hello\", \"potato\"], ten_diff, 20) 'butter' &gt;&gt;&gt; first_diff = lambda w1, w2, limit: (1 if w1[0] != w2[0] else 0) # Checks for matching first char &gt;&gt;&gt; autocorrect(\"tosting\", [\"testing\", \"asking\", \"fasting\"], first_diff, 10) 'testing' \"\"\" # BEGIN PROBLEM 5 if typed_word in word_list: return typed_word word_diff = [diff_function(typed_word, s, limit) for s in word_list] min_diff = min(word_diff) if min_diff &gt; limit: return typed_word else : return word_list[word_diff.index(min_diff)] # END PROBLEM 5 注意： 可以使用list.index(&lt;val&gt;)获取列表中某值的下标 Problem 6 返回为纠正单词需要修改的字符个数 参数： typed：输入单词 source：目标单词 limit：最多修改字符数 思路： 比较个位字符，若不同则执行更改，记录更改数 若一边比另一边长，长度的不同也算入更改数 若更改数比limit打，则返回任何大于limit的数（为了避免多余的计算） 要求使用递归 code： 123456789101112131415161718192021222324252627282930313233343536373839def feline_fixes(typed, source, limit): \"\"\"A diff function for autocorrect that determines how many letters in TYPED need to be substituted to create SOURCE, then adds the difference in their lengths and returns the result. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of chars that must change &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; feline_fixes(\"nice\", \"rice\", big_limit) # Substitute: n -&gt; r 1 &gt;&gt;&gt; feline_fixes(\"range\", \"rungs\", big_limit) # Substitute: a -&gt; u, e -&gt; s 2 &gt;&gt;&gt; feline_fixes(\"pill\", \"pillage\", big_limit) # Don't substitute anything, length difference of 3. 3 &gt;&gt;&gt; feline_fixes(\"roses\", \"arose\", big_limit) # Substitute: r -&gt; a, o -&gt; r, s -&gt; o, e -&gt; s, s -&gt; e 5 &gt;&gt;&gt; feline_fixes(\"rose\", \"hello\", big_limit) # Substitute: r-&gt;h, o-&gt;e, s-&gt;l, e-&gt;l, length difference of 1. 5 \"\"\" # BEGIN PROBLEM 6 # assert False, 'Remove this line' def compute(typed_w,source_w,count): if count &gt; limit: return limit+1 if typed_w == \"\" and source_w == \"\": return count elif typed_w == \"\": return compute(typed_w,source_w[1:],count+1) elif source_w == \"\": return compute(typed_w[1:],source_w,count+1) elif typed_w[0]==source_w[0]: return compute(typed_w[1:],source_w[1:],count) else: return compute(typed_w[1:],source_w[1:],count+1) return compute(typed,source,0) # END PROBLEM 6 注意： 超过limit限制的一律设为limit+1 通过slice来每次递归往后截取一位字符，比较每次截取后的首字符来判断相同与否，不相同让count+1 递归出口为两字符串均被截取成空串，返回计数 长度不同的情况下，已经被截成空串的不再截取，长串继续截取，该情况下直接让count+1 Problem 7 返回将输入字符改为目标字符所需要执行的操作次数，操作有以下： 添加字符 删除字符 替换字符 参数： typed：输入单词 source：目标单词 limit：最多修改字符数 思路： 比较输入单词与指定单词，寻找不同位置 若需要修改数量大于limit，则返回任何大于limit的值 代码需要使用递归，应需要三个递归调用以及两个递归出口 code： 123456789101112131415161718192021222324252627282930313233343536def minimum_mewtations(typed, source, limit): \"\"\"A diff function that computes the edit distance from TYPED to SOURCE. This function takes in a string TYPED, a string SOURCE, and a number LIMIT. Arguments: typed: a starting word source: a string representing a desired goal word limit: a number representing an upper bound on the number of edits &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; minimum_mewtations(\"cats\", \"scat\", big_limit) # cats -&gt; scats -&gt; scat 2 &gt;&gt;&gt; minimum_mewtations(\"purng\", \"purring\", big_limit) # purng -&gt; purrng -&gt; purring 2 &gt;&gt;&gt; minimum_mewtations(\"ckiteus\", \"kittens\", big_limit) # ckiteus -&gt; kiteus -&gt; kitteus -&gt; kittens 3 \"\"\" # assert False, 'Remove this line' if limit&lt;0: # Base cases should go here, you may add more base cases as needed. # BEGIN return 0 # END # Recursive cases should go below here if typed == \"\" and source == \"\": # Feel free to remove or add additional cases # BEGIN return 0 # END elif typed == \"\" or source == \"\": return abs(len(typed)-len(source)) elif typed[0] == source[0]: return minimum_mewtations(typed[1:],source[1:],limit) else: add = minimum_mewtations(typed,source[1:],limit-1) remove = minimum_mewtations(typed[1:],source,limit-1) substitute = minimum_mewtations(typed[1:],source[1:],limit-1) # BEGIN return min(add,remove,substitute)+1 # END 注意： 和上一个problem类似，使用递归与slice一位位判断 三种操作依次递归，并取最小值 Phase 3: Multiplayer 实现多人对战模式 Problem 8 将玩家输入进度与信息传入多人服务器并返回对应信息 report_progress函数 参数： typed：输入的字符，列表存储 source：需要输入的字符，列表存储 user_id：当前玩家id upload：上传进度的函数 思路： 将输入字符与需要输入字符比较，计算输入进度 输入进度指已经输入正确单词与需要输入正确单词的比例（因此，若中间有一个单词打错，后面再正确也不会记录） 函数的返回值是计算的进度 code： 123456789101112131415161718192021222324252627282930313233def report_progress(typed, source, user_id, upload): \"\"\"Upload a report of your id and progress so far to the multiplayer server. Returns the progress so far. Arguments: typed: a list of the words typed so far source: a list of the words in the typing source user_id: a number representing the id of the current user upload: a function used to upload progress to the multiplayer server &gt;&gt;&gt; print_progress = lambda d: print('ID:', d['id'], 'Progress:', d['progress']) &gt;&gt;&gt; # The above function displays progress in the format ID: __, Progress: __ &gt;&gt;&gt; print_progress({'id': 1, 'progress': 0.6}) ID: 1 Progress: 0.6 &gt;&gt;&gt; typed = ['how', 'are', 'you'] &gt;&gt;&gt; source = ['how', 'are', 'you', 'doing', 'today'] &gt;&gt;&gt; report_progress(typed, source, 2, print_progress) ID: 2 Progress: 0.6 0.6 &gt;&gt;&gt; report_progress(['how', 'aree'], source, 3, print_progress) ID: 3 Progress: 0.2 0.2 \"\"\" # BEGIN PROBLEM 8 typed_count = 0 for t,s in zip(typed,source): if t != s: break typed_count+=1 ratio = typed_count/len(source) upload({'id': user_id, 'progress': ratio}) return ratio # END PROBLEM 8 注意： 判断是否相等时，若发现不等就需要break结束循环 Problem 9 计算两个玩家输入每个单词时的用时差 time_per_word函数 参数： words：按输入顺序排列的单词列表 timestamps_per_player：一个二维列表，记录了每位玩家开始与结束输入每个单词的时间 data abstraction：match 参数： words：输入单词组成的单词列表 times：二维列表，记录了每个玩家输入每个单词需要多长时间，如times[i][j]指玩家i输入单词words[j]所花费的时间 思路： timestamps_per_player记录的是每个玩家敲每个单词的开始与结束时间 传入match后，时间会自动计算为敲每个单词使用的时间（结束-开始），并存入每个单词key对应的value中 通过get_all_word与get_all_times函数可以返回match中对应的键与值形成的列表 通过get_word与time函数可以返回指定的键与值 code: 123456789101112131415161718192021222324252627def time_per_word(words, timestamps_per_player): \"\"\"Given timing data, return a match data abstraction, which contains a list of words and the amount of time each player took to type each word. Arguments: words: a list of words, in the order they are typed. timestamps_per_player: A list of lists of timestamps including the time the player started typing, followed by the time the player finished typing each word. &gt;&gt;&gt; p = [[75, 81, 84, 90, 92], [19, 29, 35, 36, 38]] &gt;&gt;&gt; match = time_per_word(['collar', 'plush', 'blush', 'repute'], p) &gt;&gt;&gt; get_all_words(match) ['collar', 'plush', 'blush', 'repute'] &gt;&gt;&gt; get_all_times(match) [[6, 3, 6, 2], [10, 6, 1, 2]] \"\"\" # BEGIN PROBLEM 9 times = [] for l in timestamps_per_player: each_times = [] for i in range(1,len(l)): each_times.append(l[i]-l[i-1]) times.append(each_times) return match(words,times) # END PROBLEM 9 注意： 该函数的作用是通过调用match函数构造该抽象类型 但match函数需要每个单词的时间差，故需要在该函数中处理输入的时间列表（结束-开始） 将处理后的列表与传入该函数的单词列表传入match函数并返回获得的抽象类型 Problem 10 返回每个单词哪位玩家敲得块 fastest_words函数 参数： match：match函数中获得的抽象数据类型 思路： 比较多个玩家输入每个字符时间，选择输入时间最少的 返回的列表中存储了每个玩家输入最快的单词组成的列表 若多个玩家输入时间相同，则取编号更小的玩家 code: 123456789101112131415161718192021222324252627def fastest_words(match): \"\"\"Return a list of lists of which words each player typed fastest. Arguments: match: a match data abstraction as returned by time_per_word. &gt;&gt;&gt; p0 = [5, 1, 3] &gt;&gt;&gt; p1 = [4, 1, 6] &gt;&gt;&gt; fastest_words(match(['Just', 'have', 'fun'], [p0, p1])) [['have', 'fun'], ['Just']] &gt;&gt;&gt; p0 # input lists should not be mutated [5, 1, 3] &gt;&gt;&gt; p1 [4, 1, 6] \"\"\" player_indices = range(len(get_all_times(match))) # contains an *index* for each player word_indices = range(len(get_all_words(match))) # contains an *index* for each word # BEGIN PROBLEM 10 result = [[] for i in player_indices] for i in word_indices: min_player = -1 for j in player_indices: if min_player == -1 or time(match, j, i) &lt; time(match, min_player, i): min_player = j result[min_player].append(get_word(match,i)) return result # END PROBLEM 10 注意： 列表中创建多个列表要用for表达式[[] for _ in player_indices] result列表中下标表示玩家，对应元素表示该玩家最快的单词组成的列表 我们首先遍历单词，然后遍历玩家找出时间最小的玩家，并将对应单词存入该玩家对应列表","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【Python】CS61A——Environments","slug":"CS61A——Environments","date":"2025-01-30T08:23:18.274Z","updated":"2025-01-30T13:43:44.143Z","comments":true,"path":"2025/01/30/CS61A——Environments/","permalink":"https://izayoisakuye.github.io/2025/01/30/CS61A%E2%80%94%E2%80%94Environments/","excerpt":"","text":"Environments Environments in Higher-orde function Local Names e.g. 123456def f(x,y): return g(x) def g(a): return a+y result = f(1,2) 该代码会报错NameError: global name 'y' is not defined 原因很明显：当执行到行4时，系统在g的作用域中找不到y，接着去全局作用域中也找不到y，因而报错 而对于嵌套函数，函数中定义的函数是可以直接使用嵌套外函数的参数的，因为在同一个作用于下 Function Composition e.g. 123456789101112def make_adder(n): def adder(k): return k+n return adder def square(x): return x*x def triple(x): return 3*x def compose1(f,g): def h(x): return f(g(x)) return h compose1函数将两个函数结合起来计算 compose1(triple,square)(5)的结果为225 compose1(square,triple)(5)的结果为75 compose1(square, makek_adder(2))(3)的结果为25 该函数实际上开辟了两个environments用来分别计算两个函数的return值 如图中蓝色和绿色的两个environments，每个中都包含了三个作用域，分别用来计算square与make_adder(2)的值，其中make_adder还会先进入adder函数的作用域 Self-Reference e.g.1 12345def print_all(x): print(x) return print_all print_all(1)(3)(5) 该函数执行后会输出1 即print_all函数可以在函数体内以return值形式返回自身，因此该函数被调用的次数与第五行后面的括号数一致（即被调用几次） e.g.2 1234567def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) 函数会把括号后面的数依次相加，输出每次相加的和 首先传入x=1，打印1，定义next_sum函数，print_sums函数返回该函数，并传入y=3，next_sum返回print_sums函数，传入值为x+y=4 再次打印4，定义next_sum函数，print_sums函数返回该函数，并传入y=5，next_sum返回print_sums函数，传入值为x+y=9 再次打印9，没有参数传入，结束 因此要注意调用表达式中传入的参数去了哪里： 1传入了print_sums，而3和5传入了print_sums的返回值next_sum函数用于求和 Currying 注意以下两种函数 12345def make_adder(n): return lambda k:n+k def add(x,y): return x+y make_adder函数一次调用一个参数，返回一个函数再调用参数 add函数调用多个参数，返回最终结果 我们可以用以下函数将add函数转换为make_adder函数 123456def curry(f): def g(x): def h(y): return f(x,y) return h return g 这样，当我们把add函数传入curry函数，我们就可以通过一次调用一个参数的方法实现相同效果 add_three = curry(add) add_three(3)(2) &gt;&gt;&gt; 5 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c)","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【数据结构】ST表","slug":"st表","date":"2025-01-28T03:05:06.000Z","updated":"2025-02-23T14:20:11.737Z","comments":true,"path":"2025/01/28/st表/","permalink":"https://izayoisakuye.github.io/2025/01/28/st%E8%A1%A8/","excerpt":"","text":"ST表 给n个数，进行m次询问，每次寻找区间[l,r]中的最大值 DP打表 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; using namespace std; int arr[N]; int ans[N][N]; int n, m; int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i&lt;n;i++) cin &gt;&gt; arr[i]; for(int i = 0;i&lt;n;i++){ for(int j = i;j&lt;n;j++){ if (i==j) ans[i][j]=arr[j]; else ans[i][j]=max(ans[i][j-1],arr[j]); } } int l,r; while(m--){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ans[l][r]&lt;&lt;' '; } return 0; } 时间复杂度： 这种打表方式会很紧凑，用到了许多不用的空间 ST表 基于动态规划与倍增思想，是一种更稀疏的表 定义 dp[i][j]为一个从开始，长度为的区间最值 询问 e.g.询问[0,5] 使用max(dp[0][2],dp[4][1])，即询问区间从0开始，长度为，即[0,3]，与区间从4开始，长度为即[4,5]两个区间中的max值 e.g.询问[0,13] 使用max(dp[0][3],dp[8][2]),dp[12][1])即询问区间[0,7],[8,11],[12,13]三个区间中的max值 对于任意区间都可以分解为若干个小区间求max值 因为根据二进制，任意一个整数都可以分解为若干个2的n次幂的和 因此我们可以将任意区间划分为n个长度为不相交的区间并多次求max 若区间发生重叠，我们可以取重叠区间的max 因此询问步骤如下 求出区间长度 计算dp数组中的 计算最值 预处理 将一个区间分成两半，则每一半的长度均为，后半第一个元素下标即为 处理第一个 处理后面的 时间复杂度： 注意：st表是一个静态表，适用于离线处理 板子 1234567891011121314151617181920212223242526#include &lt;bits\\stdc++.h&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; dp; int query(int l,int r){ int j = (int)log2(r-l+1); return max(dp[l][j],dp[r-(1&lt;&lt;j)+1][j]); } int main(){ vector&lt;int&gt; arr = {9,3,1,7,5,6,0,8}; const int N = 8; // 预处理 dp = vector&lt;vector&lt;int&gt;&gt; (N,vector&lt;int&gt;((int)log2(N)+5,0)); // 初始化dp数组 for (int i = 0;i &lt; N;i++) dp[i][0]=arr[i]; for (int j= 1;j&lt;=log2(N);j++){ for (int i = 0; i+(1&lt;&lt;j)-1&lt;N;i++){ dp[i][j]= max(dp[i][j-1], dp[i+(1&lt;&lt;(j-1))][j-1]); } } // 询问 int l, r; while(cin &gt;&gt; l &gt;&gt; r){ cout &lt;&lt; query(l,r) &lt;&lt; endl; } return 0; } 时间复杂度：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【题解】2025牛客寒假集训-3","slug":"2025牛客寒假集训-3","date":"2025-01-25T16:00:00.000Z","updated":"2025-02-15T04:14:26.702Z","comments":true,"path":"2025/01/26/2025牛客寒假集训-3/","permalink":"https://izayoisakuye.github.io/2025/01/26/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-3/","excerpt":"","text":"","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【数据结构】树状数组","slug":"树状数组","date":"2025-01-25T07:33:06.000Z","updated":"2025-02-21T13:08:51.521Z","comments":true,"path":"2025/01/25/树状数组/","permalink":"https://izayoisakuye.github.io/2025/01/25/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"树状数组 给出一个长度为n的数组，完成以下两个操作 将第x个数加上k 输出区间内每个数的和 前缀和 使用前缀和进行询问时，可以通过询问r与l-1处的前缀和并相减获得区间数之和 但进行增加操作时，若想实现在某位置i处增加v，那么该数后面的所有元素都要对应增加v 对于这个问题，朴素算法能做到的时间复杂度，易TLE 优化思维 单个求区间和会超时，我们可以对数组进行处理： 我们可以把数字两两求和，存到另一个数组中，再进行两两求和，一直到剩一个数字 这样即使要求的数很多，我们也可以利用额外的数组计算答案 如计算前15个数的和，我们只需要计算4个数字即可 但我们可以发现，每层中第偶数个数字是没有用的，因为都可以找到更上一层的代替，去掉以后，剩下的数据恰好为n个，可以装到一个数组中，与原始数组一样长 该数组即为树状数组，每个元素都对应着树的每个节点，而每个节点对应的是原数组的某个区间和 也可以理解为每个元素是以该元素为右边界所管辖的最长区间和中元素个数 求和时只需要找到对应区间，相加即可得到答案 修改某个数据时，也只需要向上找到包含它的区间进行修改即可 lowbit()运算 定义 表示非负整数二进制表示下最低位1及其后面的0构成的数 即实现了提取最右侧1，并让其余位置变为0 e.g. 求解方法 如44，二进制为101100 首先将该数取反： 然后加一： 这时发现除了最低位1与后面的0，其余位上与原数均不同 将这两个数按位与： 故lowbit(n)=n&amp;(~n+1)=n&amp;-n 树状数组实现 我们根据序列建造一棵树，每个节点 保存以为根的子树中叶节点值之和 将每个的x转化为二进制，我们发现每一层末尾0的个数相同，且0的个数与其覆盖长度有关，每层的lowbit()值都相同 故节点覆盖长度就是lowbit(x) ，序号为i的序列正好就是长度为lowbit(i)且以i结尾的序列 且节点的父节点为 整棵树的深度为 add()操作 对于add(x,k)操作，若要在整棵树上维护这个值，需要一层一层找到父节点，并按照需要来修改这个节点的值 123void add(int x,int k){ for(;x&lt;=n;x+=x&amp;-x) t[x]+=k; } 最坏复杂度： ask()操作 向坐上找一个节点，只需要将下标-=lowbit(这个节点的下标) 12345int ask(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t[x]; return ans; } 最坏复杂度： 应用 树状数组是一个动态维护前缀和的工具 单点修改，单点查询 12add(x,k); ans=ask(x)-ask(x-1); 单点修改，区间查询 12add(x,k); ans=ask(r)-ask(l-1); 区间修改，单点查询 由差分可知，原数组第i项可以由差分数组第1项到第i项累加获得 则对于区间修改，只需要在对应l与r+1处进行val的修改即可完成对整个差分数组的修改 引入差分数组b，用树状数组维护b的前缀和，即a数组每个元素的增量 区间修改： add(l,d); add(r+1,-d) 单点查询：ans = a[x]+ask(x) 12add(l,d); add(r+1,-d); ans=a[x]+ask(x); 区间修改，区间查询 将k项数按差分数组和拆开合并如下 故我们可以维护两棵树，转换为四条add 查询操作按找公式分别计算两棵树 设树状数组维护b[i]前缀和，维护i*b[i]前缀和 区间修改： 对，add1(l,d), add1(r+1,-d) 对，add2(l,(l-1)*d), add2(r+1,-r*d) 区间查询：ans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) 12345678910111213141516171819int t1[maxn],t2[maxn]; void add1(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t1[x]+=k; } int ask1(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t1[x]; return ans; } void add2(int x,int k){ for(;x&lt;=n;x+=x&amp;x-x) t2[x]+=k; } int ask2(int x){ int ans = 0; for (; x; x-=x&amp;-x) ans+=t2[x]; return ans; } add1(l,d); add1(r+1,-d); add2(l,(l-1)*d); add2(r+1, -r*d); ans=(sum[r]+(r+1)*ask1(r)-ask2(r))-(sum[l-1]+l*ask1(l-1)-ask2(l-1)) 应用：逆序对 查询符合条件逆序对思路 从右往左遍历，每次将搜到的数计入词频数组++，并查询该位置右侧有多少小于该位置数的数，可以通过对词频数组进行前缀和（求和到该位置-1）获得 由于一直在查询前缀和，可以将词频数组构建树状数组，查询能到到 由于该题数据范围很大，若直接建立树状数组空间会炸，故需要离散化获得数据间的相对大小 离散化 该树状数组叫做值域树状数组：下标为值，对应值为词频，故下标要支持值域的数据范围 处理：将原数组复制并排序，从左到右遍历，且要将相同值去掉 回到原数组，用二分查找当前数在排序数组中的位置，用位置下标替换当前值 这样操作结束后，数与数之间的相对大小没有变化，故逆序对的数量也不会变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt; #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 5e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll arr[N]; ll sorted[N]; ll tree[N]; ll n; void add(ll x,ll k){ for (;x&lt;=n;x+=x&amp;-x)tree[x]+=k; } ll ask(ll x){ ll ans = 0; for (;x;x-=x&amp;-x) ans += tree[x]; return ans; } void solve() { ll re = 0; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; arr[i]; sorted[i]=arr[i]; } sort(sorted+1,sorted+n+1); // 对用于离散化的数组排序 ll m = 1; // 对sorted数组去重，以得到实际参与离散化的范围1-m for (int i = 2;i&lt;=n;i++){ if(sorted[m]!=sorted[i]){ sorted[++m]=sorted[i]; } } // 二分查找 auto b_sort = [&amp;](ll x){ ll l = 0, r = m+1, ans = 0; while(l+1!=r){ ll mid = (l+r)/2; if (sorted[mid]&gt;=x){ //ans = mid; r=mid; } else l = mid; } return r; }; for (int i = 1;i&lt;=n;i++){ arr[i]=b_sort(arr[i]); // 二分查找找到对应数在sorted的位置并将值替换为下标，进行离散化 } for (int i = n;i&gt;=1;i--){ add(arr[i],1); // 词频+1 re += ask(arr[i]-1); // 寻找小于当前数-1的词频前缀和 } cout &lt;&lt;re &lt;&lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int tomorin=1; //cin &gt;&gt; tomorin; while (tomorin--) solve(); return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【题解】2025牛客寒假集训-2","slug":"2025牛客寒假集训-2","date":"2025-01-23T16:00:00.000Z","updated":"2025-01-25T05:02:24.367Z","comments":true,"path":"2025/01/24/2025牛客寒假集训-2/","permalink":"https://izayoisakuye.github.io/2025/01/24/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-2/","excerpt":"","text":"F-一起找神秘的数！ ^：看作不带进位的加法 &amp;：看作哪位发生了进位（进位就是1，不进位就是0） |：不进位下就是a+b，进位就是1 故若两位都为1，则&amp;与^结果都为1，若两位都为0，则&amp;与^结果都为0，若一位是0一位是1则&amp;为0^为1 此时与和或计算求和以后就可与原两数之和相等了 又时有，因此两数相等的时候就可以满足等式 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; while(n--){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (l==0 &amp;&amp; r==0) { cout &lt;&lt; 1 &lt;&lt; endl; continue; } cout &lt;&lt; r-l+1 &lt;&lt; endl; } return 0; } G-一起铸最好的剑！ 枚举，看哪次更接近最佳温度 注意时由于怎么乘温度都不增长，故一次即可最近 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n, m; ll cnt = 1; cin &gt;&gt;n &gt;&gt;m; if (m==1||n==1){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } if (n&lt;m){ cout &lt;&lt; cnt&lt;&lt;endl; continue; } ll tep = m; while(tep&lt;n){ tep*=m; cnt++; } if (abs(tep-n)&gt;=abs(tep/m-n)) cout &lt;&lt;cnt-1&lt;&lt;endl ; else cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } J-数据时间？ 大模拟 注意两点： scanf格式化输入很好用，可以忽略中间的间隔符 由于前导零补齐，日期与时间的大小可以用字符串直接比较 由于同一个人在同一时段多次登录视作一次，我们可以把id插入set去重 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n, h, mon; struct node{ string id; int y, m, d; int hour, min, sec; }user[N]; set&lt;string&gt; work,nap,_sleep; // 对同一个人去重 int main() { scanf(\"%d %d %d\",&amp;n,&amp;h,&amp;mon); //printf(\"%d %d %d\",n,h,mon); for (int i =1;i&lt;=n;i++){ cin &gt;&gt; user[i].id; scanf(\"%d-%d-%d %d:%d:%d \",&amp;user[i].y,&amp;user[i].m,&amp;user[i].d,&amp;user[i].hour,&amp;user[i].min,&amp;user[i].sec ); //好用的格式化输入 } for (int i =1;i&lt;=n;i++){ if (user[i].y==h &amp;&amp; user[i].m==mon){ if ((user[i].hour&gt;=7 &amp;&amp; user[i].hour&lt;9)||(user[i].hour==9&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=18 &amp;&amp; user[i].hour&lt;20)||(user[i].hour==20&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))work.insert(user[i].id); else if ((user[i].hour&gt;=11 &amp;&amp; user[i].hour&lt;13)||(user[i].hour==13&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))nap.insert(user[i].id); else if ((user[i].hour&gt;=22 &amp;&amp; user[i].hour&lt;=23)||(user[i].hour&gt;=0 &amp;&amp; user[i].hour&lt;1)||(user[i].hour==1&amp;&amp;user[i].min==0&amp;&amp;user[i].sec==0))_sleep.insert(user[i].id); } } printf(\"%d %d %d\",work.size(),nap.size(),_sleep.size()); return 0; } 牛可乐在演奏什么好难猜呢 K-可以分开吗？ 離さないでいて~ 递归找到蓝色地板后bfs或dfs搜索连通块，同时找每个连通块的每个蓝色地板四联通周围的灰色地板 取所有连通块周围灰色地板的最小值 注意TLE或MLE：不要在每次搜连通块时memset vis数组，不然会超时 注意注意：题目输入描述输入的是01字符串，调了一下午最后才发现是这里出了问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 510; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int dx[]={1,0,-1,0}; int dy[]={0,1,0,-1}; int n,m; int re = INF; char floors[N][N]; bool vis[N][N]; void bfs(int x, int y){ queue&lt;PII&gt; q; PII cur, net; cur.first = x,cur.second = y; q.push(cur); bool visl[N][N]={}; // bfs搜索蓝瓷砖周围的灰瓷砖时使用的访问数组 int tot = 0; while(!q.empty()){ cur = q.front(); q.pop(); for (int i = 0;i &lt;4;i++){ net.first = cur.first+dx[i], net.second = cur.second+dy[i]; if (net.first&lt;1 || net.first&gt;n || net.second&lt;1 || net.second &gt;m) continue; // 越界 if (vis[net.first][net.second]) continue; // 访问过 if (floors[net.first][net.second]=='0'){ // 搜到灰瓷砖 if (!visl[net.first][net.second]) tot++; // 未访问，计数 visl[net.first][net.second]=true; // 标记访问 continue; } vis[net.first][net.second]=true; // 标记蓝瓷砖已经访问过 q.push(net); } } re = min(re,tot); } int main() { ios cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { cin&gt;&gt;floors[i][j]; } } // 枚举查找蓝瓷砖连通块 for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { if (floors[i][j]=='1'&amp;&amp;!vis[i][j]) { // 碰到未搜过的连通块就开始搜灰瓷砖 bfs(i,j); } } } cout &lt;&lt; re; return 0; } D-字符串里串 该字符串某一个前缀的最后一个字母在后面能出现第二次即可满足 注意，也可以从后往前看，后缀的第一个字母在前面能出现第二次即可满足 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; string s; int main() { ios cin &gt;&gt; n &gt;&gt; s; s=' '+s; map&lt;char,int&gt; mp1; map&lt;char,int&gt; mp2; int ans1=0,ans2=0; for (int i = 1;i&lt;=n;i++){ mp1[s[i]]++; if (mp1[s[i]]&gt;1){ ans1 = n-i+1; break; } } for (int i = n;i&gt;=1;i--){ mp2[s[i]]++; if (mp2[s[i]]&gt;1){ ans2 = i; break; } } int ans = max(ans1,ans2); ans==1?cout &lt;&lt; 0:cout &lt;&lt; ans; return 0; } H-一起画很大的圆！ 由几何知识可得，当三点连线越发接近直线时，这三点所在的圆半径越大（理论上三点在一条直线上时所在的圆是无限大的） 对于以下一种情况是可以实现的： 即找到一条边上最右侧的一点与次右侧的一点，与另一条边（对侧）上最接近另外两点那条边下面的一点 即 若矩形竖起来，对应的三点为 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ vector&lt;PII&gt; re; int a,b,c,d; cin &gt;&gt;a &gt;&gt;b&gt;&gt;c&gt;&gt;d; if (b-a&gt;d-c){ // 横着的矩形 re.push_back({b,d}); re.push_back({b-1,d}); re.push_back({a,d-1}); } else{ // 竖着的矩形 re.push_back({a,c}); re.push_back({a,c+1}); re.push_back({a+1,d}); } for (auto t:re) cout &lt;&lt; t.first &lt;&lt;' '&lt;&lt;t.second &lt;&lt; endl; } return 0; } C-字符串外串 可以将构造的字符串分为两部分，第一部分为满足可爱度的m个字符，第二部分为剩下的字符 由D可知，若第二部分中出现了重复字符，则可爱度一定会大于m，故不满足条件； 若总长度小于可爱度那一定不可能有满足的字符串 这两种情况可以输出NO 故我们只要保证第一部分的结尾字母与第二部分的结尾字母相同即可 一种可能的构造方法： 先构造第二部分，按字母表顺序填充n-m个字符。 再构造第一部分，让第二部分反复出现即可 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n ,m; cin &gt;&gt; n &gt;&gt; m; if (n&lt;=m || m+26&lt;n) { // 特殊条件 cout &lt;&lt; \"NO\"&lt;&lt;endl; continue; } cout &lt;&lt; \"YES\"&lt;&lt;endl; string s; for (int i = 0;i&lt;n;i++){ s.push_back('a'+i%(n-m)); // 循环插入第二部分的字符 } cout &lt;&lt; s &lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【算法】滑动窗口","slug":"滑动窗口","date":"2025-01-23T02:39:01.000Z","updated":"2025-01-23T13:27:35.824Z","comments":true,"path":"2025/01/23/滑动窗口/","permalink":"https://izayoisakuye.github.io/2025/01/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口 定义 在一个数组中框定一段子数组作为窗口 若想让该窗口元素增加，可以考虑让右边界r++，即窗口从右边吸收数字 若想让该窗口元素减少，可以考虑让左边界l++，即窗口从左边弹出数字 一般解决子数组相关问题 例1/模板 给定一个含有个正整数的数组和一个正整数target 找到累加和target的长度最小的子数组并返回长度，如果不存在符合条件的则返回0 我们可以先固定子数组的左端点，让右端点右移，直到数组和大于target，由于数组所有数都为正整数，因此找到第一个累加和大于target后，后面再加一定也大于target 此时循环判断累加和是否target，若成立则剔出左侧数字，记录子数组长度 然后以该子数组为起点，右端点右移，重复上述操作，寻找等于target的子数组，记录数组长度 时间复杂度： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,tar; int a[N]; int main() { ios cin &gt;&gt; n &gt;&gt; tar; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } int ans = 0x3f3f3f3f, sum = 0, l = 0; // 定义记录结果长度，数组元素之和，左端点 for (int r = 1;r&lt;=n;r++){ // 先让右端点右移 sum+=a[r]; // 累加求和 while(sum&gt;=tar){ // 当求和大于等于目标开始移动左端点以寻找更小区间 ans = min(ans,r-l+1); // 更新最小区间 sum-=a[l++]; // 减去滑出窗口的数同时让左端点右移 } } // 找到符合目标的区间 if (ans&lt;=n) cout &lt;&lt; ans; else cout &lt;&lt; 0 ; return 0; } 例2 给定一个字符串，找出不含有重复字符的最长字串长度 即寻找最长无重复字符的窗口 让右边界一直右移，直到遇到重复字符，让左边界移动到max(左边界，重复字符上次位置+1) 因为任何时候窗口情况一定是没有重复数组在内的，若重复字符上次位置比此时左边界小，则若还是移动到重复字符上次位置+1的话，窗口会变长，不保证加长部分会不会又出现重复字符 若右移后无重复字符，可以看作重复字符位置为-1或不存在，用max仍保持原左边界 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s; for (int i = 0;i&lt;s.size();i++) cnt[s[i]]=-1; // 初始化都为第一次出现 int ans = 0; // 记录最长区间 for (int l = 0, r = 0;r&lt;s.size();r++){ l = max(l,cnt[s[r]]+1); // 左边界移动 ans = max(ans,r-l+1); // 记录结果 cnt[s[r]]=r; // 更新上次出现字符位置为当前r位置 } cout &lt;&lt; ans; return 0; } 例3 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 我们可以逆向以一种”debt”思维解决。遍历要查找的字符，发现一个-1，这样需要查找的字符数都为负数，在查找时，每个字符出现后对应加一，则非 要查找字符将始终为正数，而要查找的字符为负数 先让右边界右移，当debt变为0（窗口包含了足够要查找的字串），开始移动左边界，使字串最小，这时debt大于0的都为不需要查找的字符，故可以左移，直到碰到需要查找的不再移动。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; string s,t; unordered_map&lt;char,int&gt; cnt; int main() { ios cin &gt;&gt; s &gt;&gt; t; if (s.size()&lt;t.size()){ cout &lt;&lt; \"\"; return 0; } for (int i = 0;i&lt;t.size();i++) cnt[t[i]]--; int len = INF, start = 0; // len用于记录最小字串，start记录字串开头，便于输出 int debt = t.size(); for (int l = 0, r = 0;r&lt;s.size();r++){ if (cnt[s[r]]++&lt;0) debt--; // 字符计数加一后仍是负的，证明是要查找的(debt的)字符，让debt-- if(debt==0){ // 所有字符都查到后 while(cnt[s[l]]&gt;0){ // 寻找最小子区间 cnt[s[l++]]--; // 若是非查找字符，可以让左边界右移拿回 } if (r-l+1&lt;len){ // 记录最小子区间以及开始位置 len = r-l+1; start = l; } } } // 若查不到则输出空字符串，否则截取字符串输出 len == INF ? cout &lt;&lt;\"\" : cout &lt;&lt; s.substr(start,start+len); return 0; } 总结 关键：找到范围和答案指标之间的单调性关系 求解大流程：求子数组在每个位置开头或结尾情况下的答案","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构】优先队列","slug":"优先队列(priority_queue)","date":"2025-01-22T13:35:19.944Z","updated":"2025-01-23T12:54:03.554Z","comments":true,"path":"2025/01/22/优先队列(priority_queue)/","permalink":"https://izayoisakuye.github.io/2025/01/22/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97(priority_queue)/","excerpt":"","text":"优先队列(priority_queue) 优先队列可以用来存储具有优先级的元素，队头的元素都是当前队列中优先级最高(或最低)的元素 STL中的优先队列默认为最大堆，即优先级最高的先出队 结构 优先队列的结构 优先队列仅维护堆顶(top)，其余元素优先级都比堆顶小 初始化 优先队列使用需要引入头文件queue 如下代码可以声明一个优先队列，其中T为数据类型，优先队列中的数据数据类型都相同 注意：使用结构体时，需要重载小于号或声明一个比较类并重载()运算符 123456789101112131415161718192021222324#include &lt;bits\\stdc++.h&gt; using namespace std; struct node{ int x, y; // 使用结构体需要重载小于号 bool operator &lt; (const node &amp;u)const{ return x == u.x? y&lt;u.y : x&lt;u.x; } }; // 或重载()运算符实现比较 struct cmp{ bool operator ()(const int &amp;u, const int &amp;v)const{ return u&gt;v; } }; int main(){ // 声明优先队列，整型，默认大顶堆(最大元素在顶上) // 一般声明一个空优先队列 priority_queue&lt;T&gt; pque; // 声明一个小顶堆,传入仿函数, 第二个参数表示优先队列底层储存容器为vector priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque; } 基本操作 1234567891011121314// 取出堆顶 cout &lt;&lt; pque.top() &lt;&lt; endl; // 插入元素到队尾并执行上浮操作 pque.push(1); // 弹出堆顶 pque.pop(); // 返回队列元素个数 cout &lt;&lt; pque.size() &lt;&lt; endl; // 判断队列是否为空 cout &lt;&lt; pque.empty() &lt;&lt; endl; //间接修改堆顶元素 int x = pque.top(); pque.pop(); pque.push(x+1); 注意：priority_queue没有迭代器，不能用begin()，end()，auto等遍历，也不能直接修改队列中的元素","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"}]},{"title":"【题解】2025牛客寒假集训-1","slug":"2025牛客寒假集训-1","date":"2025-01-21T14:15:49.000Z","updated":"2025-01-23T02:30:49.763Z","comments":true,"path":"2025/01/21/2025牛客寒假集训-1/","permalink":"https://izayoisakuye.github.io/2025/01/21/2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD-1/","excerpt":"","text":"(按官方难度排序) A-茕茕孑立之影 考虑特殊情况：若数组中包含1，则一定是1的倍数，可以直接输出-1 考虑一般情况：质数的因数只有1和他本身，又数组中不含1，因此任意一个比该数组中最大数还大的质数肯定不是数组中的倍数，又因为该数都比数组中的数大，因此也不可能是他的倍数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; bool is_prime(int n){ if (n==1) return 0; if (n==2) return 1; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0) return 0; } return 1; } int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } for (int i = 1;i&lt;=n;i++){ if (a[i]==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; break; } } if (flag) continue; cout &lt;&lt; 1000000007 &lt;&lt; endl; } return 0; } D-双生双宿之决 用map存储出现数字次数后比较即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,cnt=0; map&lt;int,int&gt; a; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; a[tep]++; } if (n&amp;1){ cout &lt;&lt; \"No\" &lt;&lt; endl; continue; } if (a.size()!=2){ // 判断值的个数用size cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } else{ set&lt;int&gt; tep; for (auto &amp;pr:a){ tep.insert(pr.second); } if (tep.size()!=1) { cout &lt;&lt; \"No\"&lt;&lt;endl; continue; } } cout &lt;&lt; \"Yes\"&lt;&lt;endl; } return 0; } B-一气贯通之刃 即判断这些节点能不能连成一条链，若是的话输出头尾，不是的话输出-1 若有两个节点度数为1，其余节点度数都为2则是一条链 故可以用map记录每个节点出现次数并判断 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=(n-1)*2;i++){ int tep; cin &gt;&gt; tep; num[tep]++; } vector&lt;int&gt; p; for (auto &amp;pr:num){ if (pr.second&gt;2){ cout &lt;&lt; -1 &lt;&lt; endl; return 0; } if (pr.second==1)p.push_back(pr.first); } for (auto t:p) cout &lt;&lt; t &lt;&lt;' '; return 0; } G-井然有序之衡 由于同时加一减一对数组总和没有影响，而最后生成的permutation正好为一个的等差数列，故可以实现的条件为数组数值之和等于该等差数列前项和 将数组排序，每一位正好对应permutation从1开始的每一位，计算每位数与对应permutation之差求和即可以得到需要操作多少次加一或减一才能变成对应permutation 注意：一次操作包含一次加一与一次减一，故最后结果要除二 1234567891011121314151617181920212223242526272829303132333435363738#pragma comment(linker, \"/STACK:102400000,102400000\") #pragma GCC optimize(\"Ofast\") #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; ll n,op; ll a[N]; int main() { ios cin &gt;&gt;n; ll sum=0; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; sum+=a[i]; } if (1ll*n*(n+1)/2!=sum){ cout &lt;&lt; -1; return 0; } sort(a+1,a+1+n); for (int i = 1;i&lt;=n;i++){ op += abs(a[i]-i); } cout &lt;&lt; op/2; return 0; } E-双生双宿之错 中位数定理： 中位数有一个性质：一个数列中所有数与中位数之差的绝对值之和最小，因为中位数是处于中间的数 即若要通过加一减一将一个数组所有数变为相同，最少操作次数即将他们变为中位数 对于这道题，我们要做到的是将数组所有数变为两个数，且出现次数相同，故我们可以按照D题的思路，将数组排序后分为前后两部分，分别求出其中位数后计算两部分各达到各自中位数所需要的操作次数求和 若两侧中位数相同，我们可以选择将前半部分中位数-1或将后半部分中位数+1并计算，取最优 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ ll n,op=0; ll a[N]; cin &gt;&gt; n; for (int i = 1;i&lt;=n;i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); // 排序 ll midl = a[((n/2)+1)/2], midr = a[((n/2)+1)/2+n/2]; // 计算前后两部分中位数 //cout &lt;&lt; midl &lt;&lt; ' ' &lt;&lt; midr &lt;&lt; endl ; if (midl!=midr){ // 正常情况 // 分两部分计算到达中位数所需要的操作次数 for (int i = 1;i&lt;=n/2;i++){ op+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op+=abs(a[i]-midr); } cout &lt;&lt; op &lt;&lt; endl; } else{ // 两侧中位数相等 // 将左侧中位数-1并计算操作次数 ll mid1 = midl-1; ll op1 = 0; for (int i = 1;i&lt;=n/2;i++){ op1+=abs(a[i]-mid1); } for (int i = n/2+1;i&lt;=n;i++){ op1+=abs(a[i]-midr); } // 将右侧中位数+1并计算操作次数 ll mid2 = midr+1; ll op2 = 0; for (int i = 1;i&lt;=n/2;i++){ op2+=abs(a[i]-midl); } for (int i = n/2+1;i&lt;=n;i++){ op2+=abs(a[i]-mid2); } // 输出更优结果 cout &lt;&lt; min(op1,op2)&lt;&lt;endl; } } return 0; } H-井然有序之窗 对于n个区间选数，区间内数多要尽量放在后面选，因为选择可能性更多 在选第i个数时，我们的重点是右界的大小，不管左边从哪开始都可以看成从i开始，因为其余的已经放完了 e.g. 区间 [1,3] [5,5] [3,5] [2,7] [3,4] [2,4] [4,7] permutation 1 5 4 6 3 2 7 因此我们可以总结如下步骤 按左界排序：决定i能不能放进去（左界相等时右界小的在前） 每次询问i放在哪个区间时，找出对应左界为i的区间，放入右界更小的区间内 因此需要一个容器来存储区间 此时，放入的区间应为当前左界为i的区间与左界为i-1且没被用过的区间，要在这些区间中寻找右界更小的区间 也就是每次往该容器里填入区间，并把容器内所有区间排序，取出右界最小的区间，当前i可以放在该区间内 故我们可以使用priority_queue实现，且为小根堆 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios cin &gt;&gt; n; vector&lt;vector&lt;PII&gt;&gt; a(n+10); // 按左端点分类存入区间右端点与区间位置 for (int i = 1;i&lt;=n;i++){ int l,r; cin &gt;&gt; l &gt;&gt; r; a[l].push_back({r,i}); } int ans[N]; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;&gt;&gt; pq; for (int i = 1;i&lt;=n;i++){ // 询问哪个数就把该数所在的区间左界的区间右界与区间位置添入优先队列 for (auto &amp;pr:a[i]) pq.push(pr); // 判断当前数是否能从区间中取到，若不能就pop换下一个 while(!pq.empty() &amp;&amp; pq.top().first&lt;i) pq.pop(); // 若都不能从当前区间中取到，表明不存在满足的，直接-1 if (pq.empty()) { cout &lt;&lt; -1 ; return 0; } // 记录当前数所在的区间位置 ans[pq.top().second]=i; pq.pop(); } for (int i = 1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【题解】Codeforces Round 998 (Div. 3)","slug":"Codeforces-Round-998-Div-3","date":"2025-01-21T14:15:30.000Z","updated":"2025-01-22T06:08:35.976Z","comments":true,"path":"2025/01/21/Codeforces-Round-998-Div-3/","permalink":"https://izayoisakuye.github.io/2025/01/21/Codeforces-Round-998-Div-3/","excerpt":"","text":"A- Fibonacciness 题意 给予，求满足的 思路 枚举所有可能的取最大值，有以下情况 代码 123456789101112131415161718192021222324252627282930313233// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int a1,a2,a4,a5; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a4 &gt;&gt; a5; int a31 = a1+a2; int a32 = a4-a2; int a33 = a5-a4; if (a31==a32 &amp;&amp; a32 == a33) cout &lt;&lt; 3 &lt;&lt; endl; else if (a31==a32 || a32 == a33 || a31==a33) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; } return 0; } B-Farmer John’s Card Game 题意 个人手里有张牌，每个人每轮出一张牌在牌堆上，需要满足牌上数字大于牌堆顶数字，若某人无法防止满足条件的牌（手里有牌的情况下）游戏便失败 构造一个permutation代表出牌顺序，使得所有人最后都能出完牌 思路 考虑特殊情况：时，它只需要按照数值递增顺序放置卡牌即可胜利，故只需要输出1 一般情况：为了按照递增顺序放置卡牌，每个人需要按照从小到大的数值出牌 又因为一个人一轮只能出一张牌，因此如果一个人手里有两张连续数值的卡牌，他出完更小的一张之后，其他人出的牌肯定会比他更大的一张牌大，这样他手里总会留下那张牌，导致失败 若没有上述情况，只要对每个人手里的牌排序，按照第一张牌的大小从小到大出牌即为正确顺序 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e3 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; //t++; while(t--){ int n, m,tep=0; int a[N]={},ord[N]={},b[N]={}; cin &gt;&gt; n &gt;&gt; m; int flag=0; for(int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=m;j++){ cin &gt;&gt; a[j]; tep++; } sort(a+1,a+1+m); if (n==1 &amp;&amp; flag != 1) { cout &lt;&lt; 1 &lt;&lt; endl; flag = 1; break; } for (int j = 1;j&lt;m;j++){ if (abs(a[j+1]-a[j])==1) { cout &lt;&lt; -1 &lt;&lt; endl; flag = 1; for (int i = 1;i&lt;=n*m-tep;i++) { int t; cin &gt;&gt; t; } break; } } if (flag) break; ord[a[1]]=i; } if (flag) continue; for (int i = 0;i&lt;n*m;i++){ if (ord[i]!=0) cout &lt;&lt; ord[i]&lt;&lt;' '; } cout &lt;&lt; endl; } return 0; } C-Game of Mathletes 题意 个数，Alice和Bob轮流每次选择一个数并去除，若两数之和等于则分数加一，求最终分数 思路 对于每组数分数是固定的，因为只要Alice选一个数，Bob就会选择数，因此只要看有几组数满足即可 这里单纯枚举会TLE，可以使用双指针优化 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,k,score=0; int a[N]; cin &gt;&gt; n &gt;&gt; k; for (int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } sort(a+1,a+1+n); // 排序 int l = 1, r = n; // 对撞指针，分别指向头尾 while(l&lt;r){ int sum = a[l]+a[r]; // 计算和 if (sum==k){ // 满足条件 score++; // 分数加一 l++,r--; // 两端指针同时移动，计算下一组数 } else if (sum&lt;k)l++; // 若和比条件小，则让和变大，左指针右移 else r--; // 若和比条件大，则让和变小，右指针左移 } cout &lt;&lt; score &lt;&lt; endl; } return 0; } D-Subtract Min Sort 题意 一个数组，你每次可以让两个相邻的数一起减去他们之中的最小值。问能不能使数组非递减 思路 对于数与，在进行操作后一定会有一个数变为0，若为0，则之后的操作一定会让变为0以保证数组非递减 考虑最右端的与，若为0，则这之前的所有数都为0 因此我们考虑两个元素与，将两者减去最小的那个，其中一个变为0，则该数之前一定都为0，而后面的不变 考虑特殊情况，若想让变为0，那么只能让同时减去而没有其他方法，这导致恒成立 对于一般情况，三个连续的数,与，我们希望先算后面两个数，这样可以让减去更多的值，以确保小于，此时若变为0，连带着也会变为0，若不变为0，则之后一定需要同时减一个让他们保证是非递减的 因此我们可以反过来，先从头对与操作，一步步往后操作。若每一组都操作结束后仍有，则无法实现，否则我们可以通过排序实现非递减数组。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int main() { ios cin &gt;&gt; t; while(t--){ int n,flag = 0; int a[N]; cin &gt;&gt; n; for (int i = 0;i&lt;n;i++) cin &gt;&gt; a[i]; if (a[0]&gt;a[1]){ // 特判第一个和第二个 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } for (int i = 1;i&lt;n-1;i++){ a[i]-=a[i-1]; // 往前减 if (a[i]&gt;a[i+1]){ // 减后若还是大则不行 cout &lt;&lt; \"NO\" &lt;&lt; endl; flag = 1; break; } } if (!flag) cout &lt;&lt; \"YES\" &lt;&lt; endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"}]},{"title":"【题解】牛客周赛 Round 77","slug":"牛客周赛-Round-77","date":"2025-01-19T13:37:37.000Z","updated":"2025-01-21T14:19:46.159Z","comments":true,"path":"2025/01/19/牛客周赛-Round-77/","permalink":"https://izayoisakuye.github.io/2025/01/19/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9B-Round-77/","excerpt":"","text":"A-时间表 把时间放到数组中按下标搜索即可 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int main() { ios int a[]={20250121,20250123,20250126,20250206,20250208,20250211}; cin &gt;&gt; n; cout &lt;&lt; a[n-1]; return 0; } B- 数独数组 形如以下的数组其实都可以： 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 8 9 1 2 3 4 5 6 7 8 9 … 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 … 即每种数字出现次数要不相等，要不相差1，且都必须出现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n; int a[N]; map&lt;int,int&gt; num; int main() { ios cin &gt;&gt; n; for (int i = 1;i&lt;=9;i++) num[i]=0; // 初始化map for (int i = 1;i&lt;=n;i++){ int tep; cin &gt;&gt; tep; num[tep]++; // 统计数字出现次数 } // 该特判可以不要 for (int i = 1;i&lt;=9;i++) { if (num[i]==0){ cout &lt;&lt; \"NO\"; return 0; } } for (int i = 1;i&lt;=9;i++){ for (int j = 1;j&lt;=9;j++){ if (num[i]!=num[j]) { // 两数不等的情况下 if(abs(num[i]-num[j])!=1){ // 差值只能为1 cout &lt;&lt; \"NO\"; return 0; } } } } cout &lt;&lt; \"YES\"; return 0; } C-小红走网格 将行列分开看，逻辑相同 由于每次移动距离固定，因此问题可以转化为以下条件： 在x方向是否存在整数（向右次数）与（向左次数）使得 在y方向是否存在整数（向右次数）与（向左次数）使得 即同余方程的可解性，可以见逆元部分 故两方程等价于与 由此我们引入裴蜀定理： 设是不全为0的整数，对任意整数，满足，且存在整数使 因此只要满足是的倍数，是的倍数，就有对应的解，即能到达指定位置 123456789101112131415161718192021222324252627282930313233343536373839// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 2e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int t; int gcd(int a, int b){ return b?gcd(b,a%b):a; } int main() { ios cin &gt;&gt; t; while(t--){ int x,y,a,b,c,d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (x%gcd(c,d)!=0) { cout &lt;&lt; \"NO\" &lt;&lt; endl; } else if (y%gcd(a,b)!=0){ cout &lt;&lt; \"NO\" &lt;&lt; endl; } else cout &lt;&lt; \"YES\"&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【Python】CS61A——Higher-Order Functions","slug":"CS61A——Higher-order Functions","date":"2025-01-19T01:03:01.170Z","updated":"2025-01-30T09:40:55.863Z","comments":true,"path":"2025/01/19/CS61A——Higher-order Functions/","permalink":"https://izayoisakuye.github.io/2025/01/19/CS61A%E2%80%94%E2%80%94Higher-order%20Functions/","excerpt":"","text":"Higher-Order Functions 函数特征 一个函数的定义域(domain)即为所有可能的输入 一个函数的值域(range)即为所有可能的输出 一个纯函数表现即为建立输入与输出之间的映射 assert语句 格式：assert &lt;bool expression&gt; &lt;output information&gt; 用处：当布尔表达式成立时，语句继续执行；当布尔表达式不成立时，程序跳出并提示指定的报错信息。 函数作为形参 设计一个计算求和、立方项求和的函数，我们可以通过在对求和函数中传入对每一位数的操作对应的函数来简化代码，而非为不同种类求和分别设计函数，如下： 1234567891011121314151617181920212223242526272829from math import pow def identity(k): return k def cube(k): return int(pow(k,3)) def summation(n,term): \"\"\"sum the first N terms of a sequence. &gt;&gt;&gt; summation(5,cube) 225 \"\"\" total,k=0,1 while k&lt;=n: total,k = total + term(k), k+1 return total def sum_naturals(n): \"\"\"sum the first N natural numbers &gt;&gt;&gt; sum_naturals(5) 15 \"\"\" return summation(n,identity) # 传入返回原值函数进行计算 def sum_cubes(n): \"\"\"sum the first N cubes of natural numbers &gt;&gt;&gt; sum_cubes(5) 225 \"\"\" return summation(n,cube) # 传入返回每个值的立方函数进行计算 其中，summation函数中的term参数与传入的函数有关 identity与cube函数作为单个参数传入summation函数，以处理不同情况下的求和 形参term函数在计算total时被回调，回调的是传入的对应函数 函数作为返回值 当一个函数在另一个函数体内定义，该函数的名称绑定在本地作用域中 如下： 123456789def make_adder(n): \"\"\"return a function that takes one argument called k and return k+N &gt;&gt;&gt; add_three = make_adder(3) &gt;&gt;&gt; add_three(4) 7 \"\"\" def adder(k): return k+n # adder函数返回数值k+n return adder # make_adder函数返回adder函数 make_adder函数返回一个函数adder，而函数adder是局部定义的函数，它可以使用make_adder内部的变量（k与n） 对于语句make_adder(1)(2)，实现的效果即为1+2 作用 函数是第一类值(first-class)：函数可以作为参数传递，作为返回值返回 higher-order函数指代以函数作为参数或返回值的函数 它可以表示计算的一般情况 它可以防止程序代码过于重复冗杂 它可以将不同功能分离成多个函数 匿名函数(Lambda Expressions ) 格式：lambda &lt;formal parameter&gt;: &lt;return value&gt; lambda指定义一个匿名函数 lambda后紧跟一个形式参数，冒号后为返回值（无return关键字） 返回值只能是一句表达式 使用时将其赋值给一个变量并按照def函数方式调用或直接按照def函数方式调用 与def不同的一点是：def定义的函数拥有一个内部名称(intrinsic name)，而lambda定义的函数即使赋值给了另一个名字的变量，它的名称仍为lambda 返回语句(Return Statements) 函数中的return语句让程序返回到先前的environment，并给函数一个值 在执行函数体时，遇到return语句函数即结束 看如下例子： 123456789101112131415161718192021def search(f): \"\"\"find a number that one more than the square root of the number put in the positive function &gt;&gt;&gt; search(positive) 11 \"\"\" x=0 while not f(x): # 当positive函数返回为0时进入循环 x+=1 return x def square(x): return x**2 def positive(x): return max(0,square(x)-100) def inverse(f): \"\"\"return g(y) such that g(f(x)) -&gt;x &gt;&gt;&gt; inverse(square)(16) 4 \"\"\" return lambda y: search(lambda x:f(x)==y) # 返回某个完全平方数的平方根 positive函数： ​ 传入search后，寻找的是第一个比positive函数中减数的平方根大的数 ​ 因为若数x的平方比减数小，return值肯定是0，while条件成立，x++继续寻找 inverse函数： inverse用于寻找完全平方数y的平方根 传入square函数用于计算search函数中x的平方，与inverse函数返回的lambda函数中传入的y比较是否相等，若不相等，满足while循环条件，x++继续比较，若相等则找到，跳出循环返回此时x值。 控制语句(Control Statements) 条件语句 执行条件：每一句clause按序执行 判断条件判断语句是否成立（若存在） 若值为true或遇到else的clause，执行语句块并跳过其余clauses 但为何没有一个函数能实现条件判断呢？ 对于调用表达式(call expression)的执行如下： 而在if语句中，只有其中一句会被执行，因此使用函数替代并不合适，如下代码： 12345678910111213def if_(c,t,f): if c: return t else: return f from math import sqrt def real_sqrt(x): return if_(x&gt;0,sqrt(x),0.0) if __name__ == '__main__': print(real_sqrt(-4)) 我们需要实现返回一个实数平方根结果的实部，众所周知，负数开平方后实部为0，因此负数应输出0 但执行后发现却出现了sqrt的 ValueError: math domain error 因为在函数调用时，sqrt(x)同时也会执行，此时x小于0故触发了sqrt的assert 因此没有了控制语句，我们只能在值之间选择而不能在条件之间选择 条件语句的简单形式 &lt;consequent&gt; if &lt;predicate&gt; else &lt;alternative&gt; 执行predicate语句 若为真，则整个表达式的值为consequent的值 若为假，则整个表达式的值为alternative的值 逻辑运算符的短路效应 执行一个语句&lt;left&gt; and &lt;right&gt; 计算left语句 若结果是false，则整个表达式的结果是false 若结果是true，则整个表达式的结果是right语句的结果 执行一个语句&lt;left&gt; or &lt;right&gt; 计算left语句 若结果为true，则整个表达式的结果是true 若结果为false，则整个表达式的结果是right语句的结果 HW Lecture4的作业部分 柯里化(Currying) 定义：柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。 即它可以把一个多元函数转换为一系列函数，每个函数传入一个参数，即将f(a,b,c)转换为f(a)(b)(c) 如上文中的makeadder函数，返回的是在内部定义的adder函数，每个函数接受一个参数，等同于makeadder(k,n) 柯里化是函数式编程的一个体现，使得函数代码更简洁 1-Product My solution: 123456x = 1 re = 1 while x&lt;=n: re*=term(x) x+=1 return re product函数有一个term参数用于接收函数，根据不同计算需要可以传入不同计算相关函数(square，identity等) 2- Accumulate My solution: 123456a=1 re=start while a&lt;=n: re = fuse(re,term(a)) a+=1 return re 1return accumulate(add, 0, n, term) 1return accumulate(mul, 1, n, term) 在上一题的基础上添加了选择每个数之间使用加法还是乘法的参数fuse，fuse同时也是接收函数来指定每个term运算之间的运算方式(add,mul 等) 3-Make repeater My solution: 12if n == 0: return lambda x: x return lambda x: f(make_repeater(f,n-1)(x)) 这里需要将传入的数值执行n次指定运算f，即f(f(...f(x)...)) 本人使用了递归实现，即make_repeater(f,n)(x)=f(make_repeater(f,n-1)(x))=f(f(make_repeater(f,n-2)))=...=f(f(...f(x)...)) 每次加一层f()，直到时替换为x","categories":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"}]},{"title":"【题解】牛客小白月赛109-C","slug":"牛客小白月赛109-C","date":"2025-01-17T14:16:39.000Z","updated":"2025-01-17T16:42:49.194Z","comments":true,"path":"2025/01/17/牛客小白月赛109-C/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B109-C/","excerpt":"","text":"题目描述 Tobo 养了 nnn 只猪猪，猪猪们的编号为 。我们规定两种操作： 1. 对于给定的 l,r 表示 Tobo 要和编号为 l 到 r的猪猪按顺序玩耍，但因为 Tobo 喜新厌旧，所以已经玩耍过的猪猪不会再一起玩，会直接跳过它。 2. 对于给定的 x ，表示编号为 x 的猪猪想知道自己是第几个和 Tobo 玩耍的，如果没有玩耍过则输出 0 。 你一共需要处理 q 次操作。 输入描述: 第一行输入两个整数 代表 Tobo 养的猪猪数量、操作次数。 此后 q 行，每行先输入一个整数 表示操作类型，随后： 若 op=1，在同一行上输入两个整数 代表 Tobo 将依次和编号为 l 到 r的猪猪玩耍。 若 op=2，在同一行上输入一个整数 代表一次询问。 输出描述: 对于每一次询问，在单独的一行上输出一个整数，表示询问的猪猪是第几个和 Tobo 玩耍的；若没有玩耍过，则直接输出 0。 输入 123456785 7 1 2 3 2 3 1 3 5 2 4 2 1 1 1 5 2 1 输出 12342 3 0 5 说明 123对于第一次操作，Tobo 将依次和编号为 2,3 的猪猪玩耍； 对于第二次操作，编号为 3 的猪猪想知道自己是第几个和 Tobo 玩的，输出 2 ； 对于第三次操作，Tobo 将依次和编号为 3,4,5的猪猪玩耍，这其中，由于编号为 3 的猪猪已经和 Tobo 玩过，所以 Tobo 会跳过它，直接和编号为 4 的猪猪玩耍。 错解 每次操作1遍历区间，暴力枚举每一只猪，若没有玩过则赋值为当前玩过的第n只猪，若玩过则直接跳过 该方法会TLE（后面又加强数据了优化后的暴力也差一点点ww） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; int play[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; int tep = 0; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l, r; cin &gt;&gt; l &gt;&gt; r; if (tep&gt;=n) continue; // 全部玩过后直接跳过 if (play[l]==0) { // 遍历区间的左端赋值 tep++; play[l]+=tep; } for(int i = l; i&lt;r;i++){ // 遍历l到r并赋值为第tep只玩过的猪 if (play[i+1]==0) { tep++; play[i+1]=tep; } } } else { // 询问操作 int p; cin &gt;&gt;p; cout &lt;&lt; play[p]&lt;&lt;endl; } } return 0; } 正解 前置知识 lower_bound()函数： 定义：const_iterator lower_bound( const K&amp; x ) const; STL内置函数，用于寻找第一个大于等于key的值，返回值为指向刚好大于等于key的下一个元素，若不存在则返回末尾迭代器（指向最后一个元素） 解析 我们可以使用set来优化 由于每只猪的编号都连续且不相同，我们可以用set来存储 使用lower_bound()函数查找在待查找区间里下一个没有玩过的猪 然后将该猪标记为第n个玩的，从集合中删除 这样可以保证集合里始终都是没有被玩过的猪，每次查找都找到离l最近的一个没有被玩过的猪，直到区间删空，即所有猪都被玩过 询问操作直接输出标记 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// #pragma comment(linker, \"/STACK:102400000,102400000\") // #pragma GCC optimize(\"Ofast\") // #pragma GCC target(\"avx,avx2,fma\") #include &lt;bits/stdc++.h&gt; #define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define endl '\\n' using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair&lt;int,int&gt; PII; const int N = 1e5 + 10; const double pi = acos(-1.0); const int mod = 1e9 + 7; const int INF = 0x3f3f3f3f; const double eps = 1e-6; int n,q; set&lt;int&gt; pig; int tag[N]; int main() { ios cin &gt;&gt; n &gt;&gt; q; pig.insert(1e9); // 防止最后全删完后剩下索引0处无法跳出 for (int i = 1;i&lt;=n;i++) pig.insert(i); // 把所有猪存入集合 int cnt = 1; while(q--){ int op; cin &gt;&gt; op; if (op==1){ int l,r; cin &gt;&gt; l &gt;&gt; r; while(1){ int tep = (*pig.lower_bound(l)); // 用lower_bound()返回第一个大于l的数，即找到下一个在区间内且没有玩过的猪 if (tep&gt;r) break; // 区间为空，寻找结束 tag[tep]=cnt; // 标记找到的猪是第几个被玩的 cnt++; pig.erase(tep); // 把被玩过的猪从集合中删除 } } else { // 询问猪是第几个玩的 int p; cin &gt;&gt; p; cout &lt;&lt; tag[p]&lt;&lt;endl; } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"}]},{"title":"【C/C++】指针","slug":"指针","date":"2025-01-17T06:53:15.466Z","updated":"2025-01-22T12:16:27.333Z","comments":true,"path":"2025/01/17/指针/","permalink":"https://izayoisakuye.github.io/2025/01/17/%E6%8C%87%E9%92%88/","excerpt":"","text":"指针 数据在内存中的存储 这是一段内存，他被分成了许多段，每段一个byte 当我们声明一个变量int a，计算机会给该变量分配一块空间，分配取决于数据类型与编译器 如：int 与float占4bytes，char占1bytes 当我们给变量a赋值a=5，计算机会去寻找该变量，去到他的地址，以二进制写入数据 指针的基础使用 指针是一种变量，它可以存储变量的地址 使用数据类型* 变量名创建一个指针：int *p char *c 使用取地址符&amp;获取一个变量的地址，并可以将指针指向该变量地址：p=&amp;a print p，print &amp;a，print &amp;p分别对应打印p指向(a)的地址，a的地址，p的地址 将一个*放在指针变量前，可以对指针进行解引用，即获取p指向地址的值 则print *p会返回a的值，*p = 8会更改a的值到8 实例代码： 1234567891011121314151617181920#include&lt;stdio.h&gt; int main(){ int a=5; int* p; // 若该指针p没有被初始化，p会变成一个野指针，会因为指向任意位置而报错 p = &amp;a; // 储存a的地址 // 上两行等同于int* p = &amp;a; printf(\"A:%d\\n\",p); // a的地址 printf(\"V:%d\\n\",*p); // a的值 printf(\"A:%d\\n\",&amp;a); // a的地址 *p = 12; // 更改p指向地址(a)的元素值 printf(\"A:%d\\n\",a); // 更改后的a值 int b = 20; *p = b; // p不会指向b，只会将b的值赋给a printf(\"A:%d\\n\",p); // 还是a的地址 printf(\"V:%d\\n\",*p); // b的值 return 0; } 指针类型 不同的数据类型占据不同的内存： int：4bytes char：1byte float：4bytes void指针： 可以存放任意类型的指针，且无需强制类型转换 需要进行显式转换后才能赋值给其他类型 可以与其他类型指针直接比较地址值 只有强制类型转换后才能操作（解引用、算术运算等） 可以和普通指针一样传入NULL或nullptr表示空指针 作为函数输入输出时，表示可以接受任意类型和输出任意类型的指针 指针类型间的转换 定义一个变量int a=1025： 他在内存中的布局为（从右到左分别为第0 1 2 3个字节，他们的地址也是连续的）： 其中，最左边的一位为符号位，0为整数1为负数 若我们定义一个字符指针c指向a，由于字符只占一个字节，故c只会指向a的第一个字节： 对c进行算术运算(+1)会让他指向下一个字节 以至于得到4 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt; int main(){ // 一个整形指针 int a = 1025; // 在二进制中为四字节:00000000 00000000 00000100 00000001 int* p; p = &amp;a; printf(\"size of integer is %d\\n\", sizeof(int)); printf(\"Address = %d, value = %d\\n\",p,*p); // 一个字符指针 char *c; c = (char*)p; // 进行强制类型转换 printf(\"size of integer is %d\\n\", sizeof(char)); // 由于char指针只有一个字节,则机器只看从右边开始的一个字节 即00000001 printf(\"Address = %d, value = %d\\n\",c,*c); // 增加一个字节,则指针指向从右边开始的第一个字节 即00000100 printf(\"Address = %d, value = %d\\n\",c+1,*(c+1)); // 一个void指针 void *p0; p0 = p; // 不需要显式的类型转换 // 当p0没指向任何特定类型时,不能解引用 printf(\"Address = %d, value = %d\\n\",p0,*p0); // 也不要进行算术运算 printf(\"Address = %d %d\\n\",p0,p0+1); } 指针算术运算 对一个指针进行加1操作，相当于将该指针增加一个该指针数据类型所占字节数的字节数 例如对int *p=&amp;a; p++;得到p的值为a的地址加4 123456789101112#include &lt;stdio.h&gt; int main(){ int a = 10; int *p; p = &amp;a; // 指针加法 : +1代表增加一个数据类型的字节数 printf(\"Address p is %d\\n\",p); // p的地址 printf(\"Value at address p is %d\\n\",*p); // p指向的值 printf(\"size of integer is %d bytes\\n\", sizeof(int)); // int类型所占的字节数 printf(\"Address p+1 is %d\\n\",p+1); // p+1指向的地址 printf(\"Value at address p+1 is %d\\n\",*(p+1)); // p+1指向的值(垃圾值) } 指向指针的指针 假设定义了一个数据int x = 5; 我们定义一个指针指向x int *p = &amp;x 此时我们可以再定义一个指针指向指针p int **q = &amp;p 甚至还可以定义一个指针指向指针q int ***r = &amp;q (r是205) 示例代码 123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int x =5; int* p = &amp;x; *p = 6; int** q = &amp;p; int*** r = &amp;q; printf(\"%d\\n\",*p); // p指向x的值 printf(\"%d\\n\",*q); // q指向p的值(x的地址) printf(\"%d\\n\",*(*q)); // q指向p的值指向x的值 printf(\"%d\\n\",*(*r)); // r指向q的值,q指向p的值 printf(\"%d\\n\",*(*(*r))); // r指向q的值,q指向p的值,p指向x的值 // 更改x的值 ***r = 10; print(\"x = %d\\n\", x); // **q与*p都指向x的值,则相当于x自加2 **q = *p +2; print(\"x = %d\\n\", x); } 指针用例—函数传引用 or 传值？ e.g. 局部变量与全局变量： 有以下代码 12345678910#include &lt;stdio.h&gt; void f(int x){ x=x+1; } int main(){ int x=10; f(x); printf(\"%d\\n\",x); return 0; } 该代码中的函数想让变量+1，但输出的结果显然还是10，这是为什么呢？ 看以下代码： 1234567891011#include &lt;stdio.h&gt; void f(int x){ printf(\"Address of x in f is:%d\\n\",&amp;x); x=x+1; } int main(){ int x=10; f(x); printf(\"Address of x in main is:%d\\n\",&amp;x); return 0; } 你会惊奇的发现，f函数中的x与main函数中的x的地址不一样，这也就说明了为什么+1不成立 当程序运行时，计算机会预留一部分内存给程序，他们被分为四个部分：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等）。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧 让一个函数调用另一个函数时，两个函数分别称为主调函数与被调函数，在主调函数中调用其他函数用到的参数称为实际参数，被调函数中的函数称为形式参数，实参会被映射到形参。这个操作即传值 当main函数调用f函数时，一块它的栈帧会被创建，其中的参数会被分配到对应空间，执行+1操作后，这个函数的栈帧中的变量执行了+1，但不影响其他地方的变量。 当f函数执行完毕，程序回到main函数，此时f的栈帧会被清除，main函数会被继续执行，故局部变量的生命周期只是函数执行期间。 接下来进行的函数是printf函数，这是一个库函数，在栈中创建它的栈帧并指型。这一个结构被称为(函数)调用栈，即：是将一个个函数的栈帧，按照调用的顺序依次压入栈中，等最上层的函数执行完了，就弹出相应的栈帧的过程 注意：栈是有大小的，如果因为无限递归等原因导致栈帧一直被创建而不清除，程序会因为栈溢出而终止 那传引用能否实现？ 1234567891011#include &lt;stdio.h&gt; void f(int *p){ *p = (*p)+1; } int main(){ int a; a = 10; f(&amp;a); printf(\"a = %d\", a); return 0; } 该函数传的是地址 当调用main函数，它的栈帧被创建，a=10进入栈。 调用f函数，它的栈帧被创建，则p接收到a的地址，入栈，此时p指向a。 在函数中解引用p，并执行操作，p指向的内存(a)的值就会增加，即a的值增加1 回到main函数，a的值就是11 这就是传引用，它可以节省很多内存空间，也可以处理一些复杂数据类型以节省内存 指针与数组 让我们声明一个数组 int a[5] 即我们创建了五个整型变量，在内存中连续存在(int 占四个字节)，则整个数组占的大小为20bytes，作为一个连续的块 我们定义一个指针int* p，将p指向a的第一个元素，则p解引用后打印的是a[0]的值 回忆之前说的指针算术，若我们将p+1，则p会往前移动四个字节，**此时*(p+1)即a[0]后四个字节的值，即a[1]** 与之前不同，一个值它的地址+1后会移动到一个未知内容的地址，而数组a中+1后p指向的值是已知的 若直接将数组名赋值给p，则p默认接收到的是数组a首元素的地址，称为数组的基地址 若想获得数组某个值的地址，可以使用&amp;a[i]或者a+i 若想获得数组某个值，可以使用a[i]或者*(a+i) 注意：对数组名（常量 ）自加是非法的，可以定义一个指针指向数组名让该指针自加 实例代码： 1234567891011#include &lt;stdio.h&gt; int main(){ int a[]={2,4,5,8,1}; for (int i = 0;i&lt;5;i++){ printf(\"Address = %d\\n\",&amp;a[i]); printf(\"Address = %d\\n\",a+i); printf(\"Value = %d\\n\",a[i]); printf(\"Value = %d\\n\", *(a+i)); } } 指针用例—数组传参 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt; int suma(int a[],int size){ int sum = 0; for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int sumb(int a[]){ int sum = 0; int size = sizeof(a)/sizeof(a[0]); printf(\"In sumb - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); for (int i = 0;i&lt;size;i++){ sum+=a[i]; } return sum; } int main(){ int a[]={1,2,3,4,5}; // 计算数组大小 printf(\"In main - size of a = %d, size of a[0] = %d\\n\",sizeof(a),sizeof(a[0])); int size = sizeof(a)/sizeof(a[0]); // 传入数组大小后进行加和 int tot = suma(a,size); // 在函数中计算数组大小并加和 int tot2 = sumb(a); printf(\"tot = %d\\n\", tot); printf(\"tot2 = %d\\n\", tot2); } 以上代码会出现一些问题： 在调用main与sumb函数时，它们的栈帧会被创建 调用sumb函数时，编译器只会创建一个同名的指针在sumb的栈帧中，即它只指向main函数中数组a的首元素地址（即int a[]等同于int *a） 因此函数中的sizeof a是一个8字节的指针。 指针与字符数组 字符数组 C中的字符串存储在数组中，必须以’\\0’结束 字符数组赋值： 可以指定每一位进行赋值， 或者使用字符串字面值（用双引号括起来的字符串）赋值，该方法会隐式地添加一个’\\0’ 或者使用大括号初始化每一位，以逗号间隔并在结尾加上’\\0’ 注意：只能在声明同时用字符串字面值赋值 使用指针 字符数组中数组名代表的是数组首元素的地址，可以用一个指针变量指向它，该变量也可以对字符数组进行操作 12345678910#include &lt;stdio.h&gt; int main(){ char c1[6]=\"Hello\"; char *c2; c2 = c1; c2[0]='A'; // equal to c1[0]='A'; c2++; // 指向下一个元素 c1++; // 非法 } 有等价关系： c2[i]等同于*(c2+i) c1[i]等同于*(c1+i) 函数传参 12345678910111213141516171819#include&lt;stdio.h&gt; void print(char *c){ int i = 0; // while (c[i]!='\\0'){ // *(c+i)也可以 // printf(\"%c\",c[i]); // i++; // } // 由于c是指针，故可以通过自增与解引用来进行访问 while(*c!='\\0'){ printf(\"%c\",*c); c++; } printf(\"\\n\"); } int main(){ char c[20] = \"Hello\"; print(c); return 0; } 指针与二维数组 如果我们要创建一个二维数组b[2][3] 此时，b[0]与b[1]表示三个整数的一维数组，在内存中占用3*4=12个字节，是按行存储的 故int *p=b;指代的是返回一个指向一维数组的指针，此时不能指针运算或解引用，故不能这么用 故应使用int (*p)[3]来创建一个二维指针数组，其中3表示三个指向一维数组的指针 这时print b or &amp;b[0]都指代第一个元素的地址 ​ print *b or b[0] or &amp;b[0][0]都指代第一个元素地址的值 ​ print b+1 or &amp;b[1]会跳到下一个数组的首地址（+12） 使用print *(b+ 1)or b[i]or&amp;b[1][0]指代下一个指向一维数组的并返回 值 解引用时，需要一步步解 例 *(*b+1) *b 为b[0]，一个一维数组的首元素地址，*b+1会让指针移动四个字节带到下一个整型变量， 相当于&amp;b[0][1] 我们解引用后，*(*b+1)就相当于b[0][1] 指针运算：b[i][j]=*(b[i]+j)=*(*(b+i)+j) 指针与多维数组 原理 与二维数组类似 假如我们有一个int数组c[3][2][2]，在内存中的存储如下 简化为三个二维数组线性存储，每个二维数组内两个一维数组线性存储 故我们可以声明一个指针int (*p)[2][2] = c;，指向2*2的二维数组 这时print c，print *c，print c[0]，print &amp;c[0][0]均输出第一个一维数组的地址 指针运算：c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) 可以理解为解引用一次就脱一层[] e.g. print *(c[0][1]+1)指向的是c[0][1][1] print *(c[1]+1)指向的是c[1][1]，即c[1][1][0] 用于函数传参 如一维数组传参，我们可以通过传值或传引用两种方法传参 注意：传值时除了最高维度，其他维度必须要指定偏移量（即形参定义时必须和传入数组长度一样） 123456int two_dim(int a[][3]){ } int three_dim(int a[][2][2]){ } 而根据数组名就是指向第一个元素的指针，我们可以直接传引用来实现降维度 注意：只能降到次一级维度，且其余的必须指定偏移量 123456int two_dim(int (*a)[3]){ } int three_dim(int (*a)[2][2]){ } 指针与动态内存 内存的分配 在一个典型架构中，分配给应用程序的内存分为四个区段：栈、堆、数据区、代码区 栈：非静态局部变量（函数参数等），函数调用信息。栈是向下生长的 堆：用于动态内存分配。堆是向上生长的 数据区：存储全局变量和静态变量 代码区：可执行的代码与常量 栈 当一个程序进行时，main函数被调用，关于这个函数的信息（如参数，局部变量，返回地址）会存在栈上，栈便为该函数开辟一块空间，称为栈帧(stack frame)，每个函数都会有一个栈帧，大小在编译期间决定 所有函数从下往上开辟栈帧后，在执行时总是栈顶的函数在执行，其余函数暂停，等待上方函数返回值等。当上方函数返回后，它占用栈的内存也会被清除，下一个函数运行。任何时候正在执行的函数都是栈顶的那个函数 预留给栈的空间在运行期间并不会增长，也不能请求更多内存。如果运行时的栈增长超过了程序预留的栈内存大小，那么会造成栈溢出(stack overflow) 因此栈有两个限制： 在栈上的变量无法操作骑作用域 当声明一个很大的数据类型，可能会造成溢出；且只能在编译时分配他的大小，无法在程序运行时分配它的大小 堆(动态内存) 这时我们需要用到堆来分配或销毁或内存。我们可以任意使用堆上的内存，只要不超过系统内存限制。 堆又称为动态内存，使用堆内存称为动态内存分配 (注意这里的堆并不是数据结构) C风格： 12345678910111213#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; // 分配到栈上 int *p; // 指向堆内存的指针 p = (int*)malloc(sizeof(int)); // 在堆上开辟一块四字节的内存，让指针p指向其地址 *p=10; // 解引用将值存入堆 free(p); // 释放内存 p = (int*)malloc(20*sizeof(int)); // 在堆上再开辟一块20个四字节的内存作为数组，让指针p指向其首元素地址 // 可以用以下两种方式访问 p[0] = 1; *(p+1) = 2; } 定义一个指针变量p，它被存储在栈中，指向堆中分配的内存地址 通过malloc在堆上分配一块四字节的内存，malloc会返回一个指向这块内存起始地址的指针，void类型。故我们需要进行一个强制类型转换，并赋给指针变量p 使用堆上内存的唯一方式是通过引用，自己维护一个指针指向这块内存。我们通过对指针变量p解引用并赋值来使用。 若我们再以同样方式分配一块四字节内存，让p指向它，并赋值为20，p此时指向的便是堆中的另一块内存。而之前那块内存仍在堆上，并不会被自动回收，此时称为内存泄漏，因此我们需要在用完一块内存后，及时调用free()释放内存。 如果要分配一个数组内存，我们只需要传入数组大小字节数即可，返回的是内存的初始地址 若malloc无法在堆上成功分配内存，会返回NULL C++风格： 123456789101112#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int a; int *p; // 指向堆内存的指针 p = new int; // 在堆上开辟一块int大小的内存(四字节) *p = 10; // 解引用并赋值 delete p; // 释放内存 p = new int[20]; // 在堆上开辟一个20大小的int数组 delete[] p; // 释放数组内存 } c++中使用关键字new与delete开辟与释放内存，不需要类型转换 相关函数 malloc 定义：void* malloc(size_t size)(size_t相当于无符号整数) 用法：int *p = (int*)malloc(分配空间大小) 分配空间大小一般习惯通过sizeof计算，如想要开辟一个存储三个int变量的数组，我们可以用3*sizeof(int)来计算大小，一般不直接写。 由于malloc返回的是void指针，指向其初始地址，而void指针无法解引用，因此我们一般在前面进行强制类型转换来转化成int指针以方便操作 malloc不会将分配的空间初始化，建议使用memset(p,0x00,sizeof(p))初始化 calloc 定义：void* calloc(size_t num, size_t size) 用法：int *p = (int*)calloc(分配元素个数, 每个元素空间大小) calloc可以指定分配的元素个数 calloc在分配空间后会自动将其初始化为0 realloc 定义：void* realloc(void* ptr, size_t size) 用法：realloc(已指向某处内存的指针, 修改空间大小) realloc用于修改分配的内存大小 若需要的新内存块比原来大，程序会创建一块新内存并将内容复制过去 若之前的内存的相邻部分还有可用内存，程序会直接拓展原空间 若需要的新内存块比原来小，则多余部分的内存会被释放掉 注意以下用法： 12int *a = (int*)realloc(a,0); // 相当于free(a) int *b = (int*)realloc(NULL,n*sizeof(int)); // 相当于malloc 内存泄漏 当我们动态申请了内存后，忘记去释放，此时程序占用了一些未使用的内存，称为内存泄露 对于栈：由于栈帧在使用完后会被自动销毁，故不会发生内存泄漏 对于堆：在开辟空间后，堆上的内存必须要被显式地释放掉，否则会一直存在 注意：任何未使用和未引用的堆上内存都是垃圾，程序员要确保不要浪费内存 函数返回指针 我们可以在函数类型处加上*来声明函数返回值是一个指针。 注意以下情况： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int c = (*a)+(*b); return &amp;c; } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 该程序对print的输出正常，而输出sum时出现了异常，从底层原理分析： 执行main函数，开辟栈帧，执行add函数，在main函数上再开辟栈帧，main函数会等待add返回 此时add中a与b存储了main函数中x与y的地址，c存储了*a与*b的和，返回的是c的地址，故main函数中的p指针存储的是c的地址 add执行完毕，占用空间被清除。但注意，此时p指向的内存仍未变化，即此时它指向了被释放掉的内存空间，值是随机的 现在执行print函数，开辟栈帧，原空间被覆盖，因此p存储的地址对应的值已经不是c的值了，因此输出异常。 还有一种情况：若不执行print函数，输出的值可能会正确。因为此时程序还没重写或清除那个空间上的数据（虽然已经释放空间） 而对于main与add函数，由于被调函数的栈空间总是在主调函数之上，因此被调函数执行时主调函数仍在栈内存中，因此add可以访问main函数中的变量。但若我们想要返回被调函数的一个局部变量给主调函数，当被调函数结束后，内存已被释放，因此会出问题。 因此可以从栈底向上传局部变量或局部变量的地址，但不能从栈顶向下传局部变量或局部变量的地址 因此我们可以修改： 1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 现在该函数返回的是一个int类型的指针，即c的地址 void print(){ printf(\"hello world\"); } int* add(int* a,int* b){ int *c = (int*)malloc(sizeof(int)); // 在堆上开辟内存 *c = (*a)+(*b); return c; // 返回的是堆上的指针 } int main(){ int x = 2,y=4; int* p =add(&amp;x,&amp;y); print(); printf(\"sum=%d\",*p); } 我们将c开辟在堆上，此时就不会被清除了，返回c是安全的 函数指针 我们可以用指针指向函数地址，即指向函数的指针。我们可以用这种指针解引用和调用函数。 函数的地址 在内存中，一个函数就是一块连续的内存。 一般程序执行指令会按照地址依次执行，而函数调用可以让程序跳到某一个地址开始执行其中的指令。 此时对应的函数地址可以称为函数的入口点，即函数第一条指令的地址 函数指针的使用 123456789101112131415161718#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(char *name){ printf(\"hello\"); } int add(int a, int b){ return a+b; } int main(){ int c; int (*p)(int,int); // 函数指针 p = &amp;add; // 指针指向add函数的地址(不用&amp;也可) c = (*p)(2,3); // 解引用，并传入参数执行函数(不用解引用也行) printf(\"%d\\n\",c); void (*ptr)(char*); ptr = print; // 不用&amp;的情况 ptr(\"mixbp\"); // 不用解引用的情况 } 由于单纯的函数名代表函数入口点，故不用&amp;与解引用也可以 注意：为了指向一个函数，函数指针的类型必须是正确的 回调函数 将函数指针作为函数参数传入，并在函数内部通过该函数指针调用函数，被调用的函数即为回调函数 123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void print(){ printf(\"hello\"); } void b(void (*ptr)()){ ptr(); // 用ptr回调传进来的函数 } int main(){ void (*p)() = print; // 定义一个指针指向print b(p); // 传入该函数指针 b(print); // 这样也可以传 } 代码中，函数b可以通过函数指针来回调函数print 可以定义一个指向print函数的指针传入，也可以直接传入print，此时指代的是print函数的首地址 应用：排序 设计一个排序函数，并可以按照不同逻辑进行排序 我们可以在普通排序函数中添加一个函数指针参数(比较函数)，通过设计蚂蚁比较逻辑并传入排序函数，可以灵活实现不同情景的比较，而不用每次都根据不同逻辑重新写一遍排序函数 如实现正序、逆序、按绝对值排序 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;math.h&gt; int compare(int a,int b){ if (a&gt;b) return 1; else return -1; } int r_compare(int a, int b){ if (a&gt;b) return -1; else return 1; } int abs_compare(int a, int b){ if (abs(a)&gt;abs(b)) return 1; else return -1; } void sort(int *a, int n, int (*cmp)(int,int)){ int tep; for (int i = 0;i&lt;n;i++){ for (int j = 0;j&lt;n-1;j++){ if (cmp(a[j],a[j+1])&gt;0){ tep = a[j]; a[j] = a[j+1]; a[j+1]=tep; } } } } int main(){ int a[]={3,2,1,5,6,4}; int b[]={-2,-3,5,4,1,-6}; sort(a,6,compare); // 正序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(a,6,r_compare); // 逆序排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",a[i]); printf(\"\\n\"); sort(b,6,abs_compare); // 绝对值排序 for (int i = 0;i&lt;6;i++) printf(\"%d \",b[i]); printf(\"\\n\"); } 同样的逻辑，在c的stdlib.h库中有一个qsort函数，只要给予它排序逻辑并传入就可以对任意数组排序","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"【算法】快速幂","slug":"快速幂","date":"2024-12-20T14:05:04.098Z","updated":"2025-01-17T07:01:52.295Z","comments":true,"path":"2024/12/20/快速幂/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"快速幂 问题引入 如何计算 朴素算法：让n个a相乘，时间复杂度为，当n特别大的时候，耗时特别长 而快速幂算法可以大大减少时间复杂度 n的分类 n为2的幂次时 如 我们可以用上一次的结果当作下一次的乘数： 快速幂原理 这样只需要进行六次乘法就可以得出结果，时间复杂度为 即使用了倍增原理，将每次a的数量翻倍 n不为2的幂次时 我们可以将不是2的幂的数写成若干个2的幂的数的和，如 可以改写为，再根据以上方法计算 如何将n分解为2的幂次之和？ 答案是位运算 让我们看看这几个数的二进制表示形式 二进制表示分解n的原理 会发现，目标数n的二进制中的1的个数与位置正好对应它分解后的数字 伪代码 12345678function bigexp(a,n) r = 1 while n!=0 if n mod 2 == 1 r = r*a a=a*a n=n/2 return r 逻辑 行3，7：每次除二，让二进制位从右到左减少一位，相当于右移一位 行6：每次让翻倍（,,,,…） 行2，4，5，8：如果mod2==1，代表该位是1，则将该位代表的与结果相乘，即让幂次相加 位运算改进 n mod 2==1等同于n&amp;1，n/2等同于n&gt;&gt;1 时间复杂度 ，循环次数为n的二进制位数，对于整数n，它的二进制位数为 板子 123456789int BigExp(int a,int n){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a); a = (a*a); n &gt;&gt;= 1; } return r; } 应用1：幂取模 123456789int ModExpFast(int a,int n,int m){ int r = 1; while (n!=0){ if (n&amp;1) r = (r*a)%m; a = (a*a)%m; n &gt;&gt;= 1; } return r; } 注： 应用2：斐波那契数列 12345678910pair&lt;int, int&gt; fib(int n) { if (n == 0) return {0, 1}; auto p = fib(n &gt;&gt; 1); int c = p.first * (2 * p.second - p.first); int d = p.first * p.first + p.second * p.second; if (n &amp; 1) return {d, c + d}; else return {c, d}; } 用矩阵形式表示斐波那契数列，如下图 斐波那契矩阵表示 我们可以发现它可以分为n个矩阵相乘 再乘列向量F1 F0","categories":[{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"【数学】逆元","slug":"逆元","date":"2024-12-20T14:05:04.096Z","updated":"2025-01-13T04:34:50.274Z","comments":true,"path":"2024/12/20/逆元/","permalink":"https://izayoisakuye.github.io/2024/12/20/%E9%80%86%E5%85%83/","excerpt":"","text":"逆元 前置知识 单位元 在一个集合中，对于某种运算，如果对于任何的集合元素 a，和元素 e 运算，得到还是集合元素 a 本身，则称 e 为这个运算下的单位元。 在加法运算中，对于任意实数，有，则单位元 (可以认作相反数) 在乘法运算中，对于任意实数，有，则单位元 (可以认作倒数) 模乘的单位元是 (证明自己搜) 逆元 在一个集合中，对于某种运算 ，如果任意两个元素的运算结果等于单位元，则称这两个元素互为逆元。 模意义下的乘法逆元 若 且(a与p互质)，则称a关于模p的乘法逆元为x 逆元即数论中的广义倒数。 费马小定理 若p为质数，则，则 或对于任意整数a，有 欧拉函数 ，表示小于等于n的正整数中和n互质的数的个数，如 当n是质数时，有 欧拉函数是积性函数，即对任意满足的整数a,b，有 特别地，当n是奇数时 求一个数的欧拉函数值：在质因数分解的同时求解即可 1234567891011int eular_phi(int n){ int ans = n; for (int i = 2;i*i&lt;=n;i++){ if (n%i==0){ ans = ans/i*(i-1); while(n%i==0) n/=i; } } if (n&gt;1) ans = ans/n*(n-1); return ans; } 欧拉定理 若，则 则对于费马小定理，有更一般的结论： 应用 求除法的模运算时，经常会因为精度或溢出问题而导致结果产生误差。 故我们可以将求转化为的逆元 将除法转为乘法，精度问题便就解决了 扩展欧几里得定理求逆元 给定正整数a，b，求满足的x的最小正整数解，若无解返回-1 结论 当a与b不互质时，逆元必定不存在 当a与b互质时，有 对应系数可得： 若改为求满足 的最小正整数解，经过变形 原式可以由变为，则和上方一致 模板 12345678void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b==0){ x=1,y=0; return ; } exgcd(b, a%b, y, x); y -= a/b*x; } 费马小定理 给定素数p和正整数a，求满足的最小正整数x，若不存在返回-1 此时模数固定为素数，故直接可以用费马小定理求解 当a为p的倍数时，，所以一定不存在，返回-1 根据费马小定理有，又 则，逆元x满足 代码 12345678910int qpow(long long a, int b){ int ans = 1; a = (a%p+p)%p; while(b!=0){ if (b&amp;1) ans = (a*ans)%p; a = (a*a)%p; b&gt;&gt;=1; } return ans; } 线性求逆元 对于求一连串数字模p的逆元，上两种方法容易超时，用这种方法更快一些 结论 (证明见oi-wiki) 有递推式 代码 123456void liner(ll n, ll p){ inv[1]=1; for (ll i = 2;i&lt;=n;i++){ inv[i]=(ll)(p-p/i)*inv[p%i]%p; } } 线性求任意逆元 首先我们求出n个数的前缀积，这时我们可以用exgcd或费马小定理求出的乘法逆元 又因为，，故我们可以将，就会和其逆元抵消，以求出 求出所有前缀积的逆元后，我们可以让前缀积的逆元乘i-1的前缀积来消除其他逆元，以得到的逆元，即 12345s[0]=1; for (int i = 1;i&lt;=n;i++) s[i]=s[i-1]*a[i]%p; sv[n]=qpow(s[n],p-2); // 也可以用exgcd for (int i = n;i&gt;=1;i--) sv[i-1]=sv[i]*a[i]%p; for (int i = 1;i&lt;=n;i++) inv[i]=sv[i]*s[i-1]%p;","categories":[{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【数据结构】并查集","slug":"并查集(Disjoint Set)","date":"2024-12-13T03:05:21.031Z","updated":"2025-01-25T07:36:57.832Z","comments":true,"path":"2024/12/13/并查集(Disjoint Set)/","permalink":"https://izayoisakuye.github.io/2024/12/13/%E5%B9%B6%E6%9F%A5%E9%9B%86(Disjoint%20Set)/","excerpt":"","text":"并查集(Disjoint Set) 概念 不相交集合：若有n个元素，其中的每个元素如果只属于某个集合，则可以把他们划为不想交集合 问题描述：将编号分别为1-n的n个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合 解决的问题： 合并两个集合 查找某个元素属于哪个集合 定义一个数组set，set[i]代表i所在的集合 我们用每个集合编号最小的元素标记所在集合 实现1 如set: 1 2 1 4 2 6 1 6 2 2 他的不相交集合为{1,3,7}, {4}, {2,5,9,10}, {6,8} 效率 查：只需要返回下标对应元素，因为此时对应的就是集合中的最小元素， 123find1(x){ return set[x]; } 并：合并两个集合后，要找出一个更小的作为代表元素，合并时要遍历set中所有元素，把还是原来元素的改成新的更小元素， 1234567merge1(a,b){ i = min(a,b); j = max(a,b); for (int k=1;k&lt;=n;k++){ if (set[k]==j) set[k]==i; } } 实现2 每个集合用一颗有根树表示 定义一个数组set 若set[i]=i, 则i为该树的根节点，i代表本集合 若set[i]=j, 若ji, 则j是i的父节点 效率 查：如果集合对应的不是自己，则自己上面有父节点，将父节点存下来继续查找直到查到根节点，最坏，一般 1234567find2(x){ r = x; while(set[r]!=r){ r = set[r]; } return r; } 并：只需要将根节点改为另一个集合的根节点即可， 123merge2(a,b){ set[a]=b; } 改进 如何避免最坏情况？ 方法：将深度小的树合并到深度大的树，合并后深度不会变化 效果：合并后，包含k个节点的树最大高度不超过 代码： 在合并时记录每棵树的高度，谁的高度大谁是新的根节点 12345678merge3(a,b){ if (height(a)==height(b)){ height(a)=height(a)+1; set[b]=a; } else if (height(a)&lt;height(b)) set[a]=b; else set[b]=a; } 此时查找操作的时间复杂度变成了 路径压缩 问题：若一棵树的高度很大，查找路径很长，查找量很大的时候，很容易tle 思想：查找时如果路径较长，则修改信息，让下次查找的时候速度更快 方案： 找到根节点 修改查找路径上的所有节点，将它们都指向根节点 路径压缩示意 代码 1234find3(x){ if (set[x]!=x) set[x]=find3(set[x]); //当不是根节点时，调用find3找到其父节点的父节点，并赋给他的父节点，此时x的父节点改为他的父节点的父节点，直到指到他的根节点 return set[x]; } 模板 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。 输入格式 第一行包含两个整数 ,表示共有 个元素和 个操作。 接下来 行，每行包含三个整数 。 当 时，将 与 所在的集合合并。 当 时，输出 与 是否在同一集合内，是的输出 Y ；否则输出 N 。 输出格式 对于每一个 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。 样例 #1 样例输入 #1 123456784 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1234N Y N Y 提示 对于 的数据，，。 对于 的数据，，。 对于 的数据，，，，。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; const int N = 1e4+10; int n,m; int disj[N]; // 并查集 // 查找操作，使用路径压缩 int find(int x){ if(disj[x]!=x) disj[x]=find(disj[x]); return disj[x]; } // 合并操作，寻找两者最小根节点并将大的修改成小的 void merge(int a,int b){ if(find(a)&gt;find(b))disj[find(a)]=find(b); else disj[find(b)]=find(a); } int main(){ cin &gt;&gt; n &gt;&gt;m; // 初始化每一位的根节点是他自己 for(int i = 1;i&lt;=n;i++) disj[i]=i; while(m--){ int z, x, y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; // 进行合并 if (z==1){ merge(x,y); } else { // 如果两者的根节点相同，则属于同一集合 if(find(x)==find(y)) cout &lt;&lt; \"Y\"&lt;&lt;endl; else cout &lt;&lt; \"N\"&lt;&lt;endl; } } return 0; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"梦开始的地方","slug":"hello-world","date":"2024-12-03T16:04:41.587Z","updated":"2025-01-17T07:00:58.279Z","comments":true,"path":"2024/12/04/hello-world/","permalink":"https://izayoisakuye.github.io/2024/12/04/hello-world/","excerpt":"","text":"124075351_p0 这是一个测试帖子 三级标题 四级标题 五级标题 测试代码 123456#include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; \"Hello world!\"; return 0; } 将来可以在里面发一些学习笔记 题解 模板之类的 毕竟跌跌撞撞最后还是开始了ACM之路（ ### じや……一生 ACMしてくれる?","categories":[{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/categories/Python/"},{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"https://izayoisakuye.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/categories/C-C/"},{"name":"数论","slug":"数论","permalink":"https://izayoisakuye.github.io/categories/%E6%95%B0%E8%AE%BA/"},{"name":"杂项","slug":"杂项","permalink":"https://izayoisakuye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"表","slug":"表","permalink":"https://izayoisakuye.github.io/tags/%E8%A1%A8/"},{"name":"Web","slug":"Web","permalink":"https://izayoisakuye.github.io/tags/Web/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://izayoisakuye.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"https://izayoisakuye.github.io/tags/Python/"},{"name":"CS61A","slug":"CS61A","permalink":"https://izayoisakuye.github.io/tags/CS61A/"},{"name":"基础算法","slug":"基础算法","permalink":"https://izayoisakuye.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"https://izayoisakuye.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://izayoisakuye.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"牛客题解","slug":"牛客题解","permalink":"https://izayoisakuye.github.io/tags/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3/"},{"name":"ACM","slug":"ACM","permalink":"https://izayoisakuye.github.io/tags/ACM/"},{"name":"STL","slug":"STL","permalink":"https://izayoisakuye.github.io/tags/STL/"},{"name":"CF题解","slug":"CF题解","permalink":"https://izayoisakuye.github.io/tags/CF%E9%A2%98%E8%A7%A3/"},{"name":"C/C++","slug":"C-C","permalink":"https://izayoisakuye.github.io/tags/C-C/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"https://izayoisakuye.github.io/tags/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"数学","slug":"数学","permalink":"https://izayoisakuye.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}